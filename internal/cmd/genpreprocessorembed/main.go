// Copyright 2023 The CUE Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

const target = "gen_preprocessembed.go"

func main() {
	log.SetFlags(0)
	flag.Parse()

	// Get the main module
	modCmd := exec.Command("go", "list", "-m", "-json")
	modOut, err := modCmd.CombinedOutput()
	if err != nil {
		log.Fatalf("failed to determine main module path via [%v]: %v", modCmd, err)
	}
	var mainMod listModule
	if err := json.Unmarshal(modOut, &mainMod); err != nil {
		log.Fatalf("failed to decode main module information: %v", err)
	}

	// Verify we are in the right module!
	const thisModule = "github.com/cue-lang/cuelang.org"
	if mainMod.Path != thisModule {
		log.Fatalf("main module is %s; expected %s", mainMod.Path, thisModule)
	}

	// Write to gen_pkghash.go for the current pkg
	var out bytes.Buffer
	fmt.Fprintln(&out, "// Code generated by internal/cmd/genpreprocessorembed; DO NOT EDIT.")
	fmt.Fprintln(&out)
	fmt.Fprintln(&out, "package preprocessembed")
	fmt.Fprintln(&out)
	fmt.Fprintln(&out, "import \"embed\"")
	fmt.Fprintln(&out)

	embed := func(pattern string) {
		fmt.Fprintln(&out, "//go:embed "+pattern)
	}

	embed("go.mod")
	embed("go.sum")

	depsCmd := exec.Command("go", "list", "-e", "-deps", "-json", "github.com/cue-lang/cuelang.org/internal/cmd/preprocessor")
	depsOut, err := depsCmd.CombinedOutput()
	if err != nil {
		log.Fatalf("failed to determine deps via [%v]: %v\n%s", depsCmd, err, depsOut)
	}

	// Iterate through, and for each package that belongs to the main module,
	// add patterns for the files to embed.
	dec := json.NewDecoder(bytes.NewReader(depsOut))
	for {
		var p listPackage
		if err := dec.Decode(&p); err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			log.Fatalf("failed to decode package deps: %v", err)
		}
		// We only care about packages in the main module
		if p.Module == nil || p.Module.Path != thisModule {
			continue
		}
		// We must ignore the package at the root of the module
		if p.ImportPath == thisModule {
			continue
		}
		relPath, err := filepath.Rel(mainMod.Dir, p.Dir)
		if err != nil {
			log.Fatalf("failed to compute %s relative to %s", p.Dir, mainMod.Dir)
		}
		embed(filepath.Join(relPath, "*.go"))
		for _, pattern := range p.EmbedPatterns {
			embed(filepath.Join(relPath, pattern))
		}
	}

	fmt.Fprintln(&out, "var Files embed.FS")

	// Follow the pattern used in the preprocessor of only writing to the target
	// file if the contents have changed. More a consistency point than an
	// efficiency one.
	targetFile := filepath.Join(mainMod.Dir, target)
	curr, _ := os.ReadFile(targetFile)
	if !bytes.Equal(out.Bytes(), curr) {
		if err := os.WriteFile(targetFile, out.Bytes(), 0666); err != nil {
			log.Fatalf("failed to write output to %s: %v", targetFile, err)
		}
	}

}

type listPackage struct {
	ImportPath string
	Name       string
	Module     *listModule
	Dir        string

	EmbedPatterns []string

	Error any
}

type listModule struct {
	Path string
	Dir  string
}
