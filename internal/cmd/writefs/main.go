// Copyright 2023 The CUE Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

type file struct {
	Type string

	// If typ == "symlink" the contents will be of type string and this is the
	// filepath of the target.
	//
	// Otherwise it is the Contents of the file, in which case the type is
	// whatever the contents of the JSON represented. If the extension of the
	// file is .json or .toml, a filetype known to CUE then raw JSON is
	// evaluated to the target filetype (a noop in the case of JSON) via
	// cmd/cue. If the file extension is unknown, then the type must be string.
	Contents json.RawMessage
}

type args struct {
	// Tool is the name of the tool that initiated the writefs call
	Tool string

	// Remove is a list of globs of files to remove. File
	// removal happens before file creation.
	Remove []string

	// Create is a map of file path (in Unix format) to contents.
	Create map[string]file
}

func main() {
	var todo args
	dec := json.NewDecoder(os.Stdin)
	if err := dec.Decode(&todo); err != nil {
		log.Fatalf("failed to decode arguments from stdin: %v", err)
	}
	for _, glob := range todo.Remove {
		files, err := filepath.Glob(glob)
		if err != nil {
			log.Fatalf("failed to glob %q: %v", glob, err)
		}
		if len(files) == 0 {
			continue
		}
		for _, f := range files {
			if err := os.Remove(f); err != nil {
				log.Fatalf("failed to remove %s: %v", f, err)
			}
		}
	}
	for fp, f := range todo.Create {
		fp = filepath.FromSlash(fp)
		dir := filepath.Dir(fp)
		if err := os.MkdirAll(dir, 0o777); err != nil {
			log.Fatalf("failed to mkdir %s: %v", dir, err)
		}
		switch f.Type {
		case "symlink":
			// f.Contents must be a string
			var contents string
			if err := json.Unmarshal(f.Contents, &contents); err != nil {
				log.Fatalf("%s: Type is symlink, but Contents not a string type", fp)
			}
			target := filepath.FromSlash(contents)
			actualTarget, err := os.Readlink(fp)
			if err == nil && actualTarget == target {
				continue
			}
			if err := os.Symlink(target, fp); err != nil {
				log.Fatalf("failed to symlink %s -> %s: %v", fp, target, err)
			}
		case "file":
			var toWrite bytes.Buffer

			// TODO: more principled checking of whether this filetype is known to
			// CUE.

			// TODO: parsing input JSON into a cue.Value, and properly prepending
			// a comment with the "generated by" header. Also requires the filetype
			// known to CUE to be able to export comments.

			switch ext := filepath.Ext(fp); ext {
			case ".json", ".yaml", ".toml":
				filetype := ext[1:]
				// Can be any type, just encode the JSON as TOML
				// We have concrete JSON; export as TOML
				in := bytes.NewReader(f.Contents)
				var out bytes.Buffer
				cmd := exec.Command("go", "run", "cuelang.org/go/cmd/cue", "export", "--out="+filetype, "json:", "-")
				cmd.Stdin = in
				cmd.Stdout = &out
				cmd.Stdout = &out
				if err := cmd.Run(); err != nil {
					log.Fatalf("failed to run %v: %v\n%s", cmd, err, out.Bytes())
				}

				// Gross: hack in a "code generated by" header for filetypes that support comments
				//
				// TODO: remove this gross hack
				switch filetype {
				case "yaml", "toml":
					fmt.Fprintf(&toWrite, "# Code generated %s; DO NOT EDIT.\n\n", todo.Tool)
				}
				toWrite.Write(out.Bytes())
			default:
				// Must be string
				var contents string
				if err := json.Unmarshal(f.Contents, &contents); err != nil {
					log.Fatalf("%s: unknown file type, Contents must be a string", fp)
				}
				toWrite.WriteString(contents)
			}
			if err := os.WriteFile(fp, toWrite.Bytes(), 0o666); err != nil {
				log.Fatalf("failed to write file %s: %v", fp, err)
			}
		}
	}
}
