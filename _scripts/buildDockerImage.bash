#!/usr/bin/env bash

set -euo pipefail

# cd to the parent directory to that containing the script
cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/.."
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"

cat <<'EOD' > "_scripts/dockerRun.bash"
#!/usr/bin/env bash

# Code generated by buildDockerImage.bash; DO NOT EDIT.

source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"
docker run -e USER_UID=1000 -e USER_GID=1000 --rm -it $(dockerImageTag) bash
EOD

# Change to the directory containing the Dockerfile ahead of building
cd internal/cmd/preprocessor/cmd
tag=$(dockerImageTag)

cat <<EOD > gen_dockerimagetag.go
// Code generated by buildDockerImage.bash; DO NOT EDIT.

package cmd

const dockerImageTag = "$tag"
EOD

# Only build the docker image if it doesn't exist in the local machine's registry.
if docker inspect $tag > /dev/null 2>&1; then
    echo "docker image $tag already exists; skipping build"
    # The registry-prefixed tag's existence is our contract with a subsequent
    # docker-push script; ensure it exists.
    if [[ "${CI:-}" == "true" ]]; then
        docker tag $tag "$NSC_CONTAINER_REGISTRY/$tag"
    fi
	exit 0
fi

# We always require the non-registry-prefixed tag to be added, separately from
# the in-CI tag, so that the image can be found by the preprocessor in the local
# machine's registry.
localTagFlag="-t $tag"
ciTagFlag=""
if [[ "${CI:-}" == "true" ]]
then
    # NSC_CONTAINER_REGISTRY is set automatically inside Namespace CI.
    ciTagFlag="-t $NSC_CONTAINER_REGISTRY/$tag"
fi

commonBuildArgs="$localTagFlag $ciTagFlag --build-arg GOPRIVATE=\"$(go env GOPRIVATE)\" -f ./_docker/Dockerfile ./_docker"

# TODO: pass in host UID and GID and Go cache paths to avoid using a buildkit
# caching layer.  This is particularly important in CI.
if docker help | grep -q podman
then
    docker build $commonBuildArgs
else
    docker buildx build --load $commonBuildArgs
fi
