#!/usr/bin/env bash

set -euo pipefail
set -x

# cd to the parent directory to that containing the script
cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/.."
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"

cat <<'EOD' > "_scripts/dockerRun.bash"
#!/usr/bin/env bash

# Code generated by buildDockerImage.bash; DO NOT EDIT.

source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"
docker run -e USER_UID=1000 -e USER_GID=1000 --rm -it $(dockerImageTag) bash
EOD

# Change to the directory containing the Dockerfile ahead of building
cd internal/cmd/preprocessor/cmd
tag=$(dockerImageTag)

cat <<EOD > gen_dockerimagetag.go
// Code generated by buildDockerImage.bash; DO NOT EDIT.

package cmd

const dockerImageTag = "$tag"
EOD

# Only build the docker image if it doesn't exist
if docker inspect $tag > /dev/null 2>&1; then
	echo "docker image $tag already exists; skipping build"
	echo NOT REALLY # FIXME remove this before submission
	#exit 0
fi

buildArgs="-t $tag --build-arg GOPRIVATE=\"$(go env GOPRIVATE)\" -f ./_docker/Dockerfile ./_docker"
if [[ "${CI:-}" == "true" ]]
then
    nsRegistryUrl="$(nsc workspace describe -o json -k registry_url)"
    # TODO: allow CI to set GOPRIVATE in a workflow, and respect it here.
    # FIXME: make the push conditional
    buildArgs="--push -t $nsRegistryUrl/$tag --build-arg GOPRIVATE= f ./_docker/Dockerfile ./_docker"
fi

# TODO: pass in host UID and GID and Go cache paths to avoid using a buildkit
# caching layer.  This is particularly important in CI.
if docker help | grep -q podman
then
    docker build $buildArgs
else
    docker buildx build --load $buildArgs
fi
