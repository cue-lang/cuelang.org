#!/usr/bin/env bash

set -euo pipefail

# cd to the parent directory to that containing the script
cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/.."
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"

cat <<'EOD' > "_scripts/dockerRun.bash"
#!/usr/bin/env bash

# Code generated by buildDockerImage.bash; DO NOT EDIT.

source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/dockerImage.bash"
docker run -e USER_UID=1000 -e USER_GID=1000 --rm -it $(dockerImageTag) bash
EOD

tag=$(dockerImageTag)
registryTag=ghcr.io/cue-lang/$tag
# TODO: pass in host UID and GID and Go cache paths to avoid using a buildkit
# caching layer.  This is particularly important in CI.
commonBuildArgs="-t $tag --build-arg GOPRIVATE=\"$(go env GOPRIVATE)\" -f ./_docker/Dockerfile ./_docker"

# Change to the directory containing the Dockerfile ahead of building
cd internal/cmd/preprocessor/cmd
cat <<EOD > gen_dockerimagetag.go
// Code generated by buildDockerImage.bash; DO NOT EDIT.

package cmd

const dockerImageTag = "$tag"
EOD

# Only build the docker image if it doesn't exist in the local machine's image store.
if ! docker inspect $tag >/dev/null 2>/dev/null; then
    echo "local container image $tag not found; building ..."
    if docker help | grep -q podman
        then docker build $commonBuildArgs
        else docker buildx build --load $commonBuildArgs
    fi
else
    echo "local container image $tag already exists; skipping build."
fi

# Only push the local container image if we've been asked to, and it doesn't
# exist in the remote registry. The remote existence check handles our
# container image currently not being 100% idempotent, which would cause extra
# layers to be stored in the registry unnecessarily if we always pushed it.
if [[ "${CI_PUSH_CONTAINER_IMAGE:-}" == "true" ]]; then
    echo "ensuring that remote registry contains $tag ..."
    if ! docker manifest inspect $registryTag >/dev/null 2>/dev/null; then
        echo "tagging local image $tag as $registryTag ..."
        docker tag $tag $registryTag
        echo "pushing $registryTag to remote registry ..."
        docker push $registryTag
    else
        echo "remote registry already contains $registryTag; skipping push."
    fi
fi
