#!/usr/bin/env bash
set -euo pipefail

# this script translates the cue CLI's help texts into content pages for
# cuelang.org.
#
# the script operates relative to the directory in which it is invoked. Inside
# this directory, it:
# - deletes all "cue" prefixed directories (and files), in preparation for
#   regenerating their content (and to cater for subcommand removal between cue
#   versions)
# - for each cue subcommand it:
#   - creates a "cue-<subcommand>" directory
#   - templates the output of "cue help <subcommand>" into
#     "cue-<subcommand>/en.md"
#   - templates "cue-<subcommand>/page.cue"

# control is passed to the main function at the bottom of this file
function main() {
    local contentRootAbsoluteSuffix="$1"; shift
    # subCommands lines currently need not to have leading spaces
    local subCommands="cmd
commands
completion
def
eval
export
filetypes
fix
flags
fmt
get
get go
help
import
injection
inputs
mod
mod init
trim
version
vet"

    # remove all existing content matching the glob
    deleteExistingContent "$contentRootAbsoluteSuffix" 'cue*'

    # create (and enforce the deletion of) a local cue.mod directory, to stop
    # "cue help cmd" from traversing the filesystem to the root of the
    # github.com/cue-lang/cuelang.org module, and then emitting output that
    # mentions the commands that are available in *this* module.
    trap "rmdir cue.mod" EXIT
    mkdir cue.mod

    # process each possibly-multi-word line in the subCommands list
    while IFS= read -r line ; do
        local contentDir="cue-$(echo "$line" | tr ' ' '-')"
        local contentTitle="cue $line"
        local contentCommand="go run cuelang.org/go/cmd/cue help $line"
        local displayCommand="cue help $line"
        writeHelpText \
            "$contentRootAbsoluteSuffix" \
            "$contentDir" \
            "$contentTitle" \
            "$contentCommand" \
            "$displayCommand"
    done <<< "$subCommands"

    # "cue" is a special case, as its lack of a subcommand means it can't have
    # its parameters derived in the same manner as the loop, above.
    writeHelpText \
        "$contentRootAbsoluteSuffix" \
        cue \
        cue \
        "go run cuelang.org/go/cmd/cue help" \
        "cue help"
}
# delete all existing content, as dictated by a glob parameter
function deleteExistingContent() {
    local cwdRequiredSuffix="$1"; shift
    local dirGlobToDelete="$1"; shift

    # safety check: only continue if the path we're being asked to delete
    # content from ends with the given string. This (hopefully!) prevents a
    # nasty accident if --say-- the CLI help texts move location in the future.
    if ! [[ $PWD = *$cwdRequiredSuffix ]]; then
        echo "fatal: PWD:$PWD does not have required suffix $cwdRequiredSuffix" >&2
        exit 1
    fi

    rm -rf $dirGlobToDelete
}

# template an individual subcommand's markdown and cue files
function writeHelpText() {
    local cueBaseAddressAsPath="$1"; shift
    local contentDir="$1"; shift
    local pageTitle="$1"; shift
    local helpCommand="$1"; shift
    local displayCommand="$1"; shift

    local thisScript="_scripts/$(basename $BASH_SOURCE)"
    local markdownFile="$contentDir/en.md"
    local cueFile="$contentDir/page.cue"
    # cueBaseAddress will only be valid CUE if cueBaseAddressAsPath contains
    # *only* path elements that are valid CUE identifiers.
    # I.e. nothing that would require quoting when interpreted as CUE.
    local cueBaseAddress="$(echo $cueBaseAddressAsPath | sed 's@/@: @g')"

    mkdir -p "$contentDir"

    # markdown content
    cat <<SCRIPTHEREDOC >"$markdownFile"
---
WARNING: "Code generated by $thisScript; DO NOT EDIT."
title: "$pageTitle"
tags:
  - cue command
---

\`\`\`text
$ $displayCommand
$(eval $helpCommand)
\`\`\`
SCRIPTHEREDOC

    # cue content
    cat <<SCRIPTHEREDOC >"$cueFile"
package site

$cueBaseAddress: "$contentDir": {}
SCRIPTHEREDOC
}

# the script's only parameter serves two purposes:
# - it's used to check that the absolute path of the directory in which the
#   script is invoked ends with this string, as a failsafe.
# - it's translated into a cue address that's baked into the individual content
#   page's page.cue as their path prefix.
#
# e.g. given $1="foo/bar/baz", the directory in which we're invoked must be
# something like "/home/user/a/b/c/foo/bar/baz", and the page.cue for
# "cue-quux" embeds the cue path 'foo: bar: baz: "cue-quux": {}'.
contentRootAbsoluteSuffix="$1"; shift

main "$contentRootAbsoluteSuffix"
