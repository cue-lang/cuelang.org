+++
title = "关于"
weight = 100
description = "CUE是如何诞生的，以及它的原理是什么"
+++

> 译者注：原文中使用的 `Schema`，虽然直译应为 `模式`，但是个人认为此翻译并不是特别好理解。
> 于是与 CUE 的维护者之一 [@myitcv](https://github.com/myitcv) 进行了 [讨论](https://cuelang.slack.com/archives/C032M6T7WAG/p1645762537397239) ，
> 他认为 `specification` 或 `struct` 会更接近，因此下文将 `Schema` 翻译为 `规范`。

## 简介

CUE 是一门开源的数据验证语言和推理引擎，它起源于逻辑编程。
虽然 CUE 不是一种通用型语言，但它有很多的应用领域，比如数据验证、数据模板化、配置、查询、代码生成，甚至脚本。
它的推理引擎可以用于验证代码中的数据或者将其作为代码生成流程中的一部分。

CUE 和其他语言不一样，最关键的是它将 类型 和 值 合并为同一个概念，
而在大多数语言中，类型 和 值 是严格区分的。
CUE 将它们排列在一个单一层次中（准确地说，是一个 [格](https://zh.wikipedia.org/wiki/%E6%A0%BC_(%E6%95%B0%E5%AD%A6)) ）。
这是个非常强大的概念，让 CUE 能实现很多花哨的事情，同时也省去了很多麻烦。
比如，没必要使用 范型 和 枚举，[和类型](https://en.wikipedia.org/wiki/Tagged_union) 和 空值合并 是一样的。

## 应用领域

CUE 的设计确保无论 CUE 的值是什么顺序，总会得到相同的结果（它是可结合的、可交换的并且是幂等的）。
这让 CUE 特别适合当它的约束来自不同来源的情况：

- 数据校验：不同的部门或团队可以各自定义他们自己的约束条件来应用到相同的数据中。

- 代码提取和生成：从多个来源（Go 代码、Protobuf）中提取 CUE 的定义，并将它们合并为单个定义，然后将其生成其他格式的定义（比如： OpenAPI）。

- 配置：值可以从不同来源进行组合，而不需要其中一个必须引用另一个。

值 排序的过程也能对整个配置进行集合包含分析。
当大多数校验系统只能检查一个具体的值是否匹配定义时，CUE 能校验某个 规范 的实例也是另一个 规范 的实例（是否向后兼容？）
或计算一个新的 规范，此 规范 能表示与其他两种 规范 相匹配的所有实例。

## 历史

虽然 CUE 是一门特别不同的语言，但它的根源是 GCL（Google Config Language），到目前 GCL 是 Google 主要使用的配置语言。
它最初是为配置 Kubernetes 的前身 Borg 而设计的。实际上，最开始想的是在 GCL 中使用 CUE 中的图归一化。
GCL 的一位作者对实现这类系统有丰富的经验，也体验到了能够通过计算和推理类型以创建强大工具的好处。

CUE 所基于的图归一化模型是当时在计算机语言学中广泛使用的，并且曾成功管理超过 10 万行声明式定义的语法和词典。
这些实际上是像人类语言这样不规则和复杂的非常大的配置，这些系统一个特点就是定义的 类型 或 约束条件 可以验证数据，并减少重复使用的代码块。
总的来说，这种方法非常适合云上的配置。 

然而，GCL 的早期设计追求的是更简单的东西，巧合的是它与图归一化的概念不相容。
但是这种更简单的方法被证明是不够的，但要转向先前的方法已经太晚了。
相反的，采用了基于继承的覆盖的模型。
但是它的复杂性使得早期的工具难以实现，也从未实现，复制其模型的 GCL 后代也是如此。

CUE 回归最初使用基于约束的的想法，也努力吸收 15 年使用 GCL 的经验教训，
也包括从其后代中吸取的经验教训以及使用配置的不同方法。

## 理念与原则

### 类型 和 值

CUE 没有区分 值 和 类型，这是一个超强的概念，能让 CUE 定义非常详细的约束条件，同时也极大地简化了很多事情：
不需要学习独立的规范和数据定义语言，或相关的语言结构，比如 [和类型](https://en.wikipedia.org/wiki/Tagged_union) 、枚举，甚至某个单一结构的空值合并。

下面是这个结构的演示，左边能看到一个包含 Moscow 城市属性的 JSON 对象（使用的 CUE 语法），
中间的例子展示了可以描述任何 municipality（直辖市） 的 规范，
而右侧，可以看到混合了 数据 和 规范 ，是 CUE 的典型实现。

{{< blocks/sidebyside >}}
<div class="col">
数据
{{< highlight go >}}
moscow: {
  name:    "Moscow"
  pop:     11.92M
  capital: true
}
{{< /highlight >}}
</div>

<div class="col">
规范
{{< highlight go >}}
municipality: {
  name:    string
  pop:     int
  capital: bool
}
{{< /highlight >}}
</div>

<div class="col">
CUE
{{< highlight go >}}
largeCapital: {
  name:    string
  pop:     >5M
  capital: true
}
{{< /highlight >}}
</div>
{{< /blocks/sidebyside >}}

一般情况下，CUE 的这个会首先对一个类型进行宽泛的定义，来覆盖所有可能的实例。
然后慢慢缩小定义范围，可能通过不同来源（部门、用户）来合并约束条件，直到最终剩下一个具体的数据实例。

### 主动而不是被动使用约束

CUE 的约束条件作为数据验证器，但同时也能减少重复使用的代码块。
这是一个强大的方法，但是需要一些不同的思路。
使用传统的继承方法，人们在每一个需要使用的点上都会指定要继承的模板。
相反的，在 CUE 中人们选择配置中的一组节点来应用模板，选择可以在所有配置的不同点上进行。

从另一个角度看，一个 JSON 配置可以被定义为一个 路径和叶 的序列。

比如,

```json
{
  "a": 3,
  "b": {
    "c": "foo"
  }
}
```

可以表示为：

```
"a": 3
"b": "c": "foo"
```

所有原始 JSON 文件中的信息都被保留了下来。

CUE 将这个概念概括为以下模式：

```
<set of nodes>: <constraints>
```

CUE 中每一个字段声明定义一组节点来应用具体的约束条件。
因为顺序是无关的，多个约束条件可以应用到同一个节点，所有的约束条件需要同时应用。
这些约束条件可能甚至会在不同文件中。
但是它们不会相互矛盾：
如果一个声明一个字段值是 `5`，另一个不能使用 `6` 来覆盖它，
但是同时声明 `>5` 和 `<10` 是有效的。

这样的方法比全面继承的方法更有局限性：
它不太可能复用已存在的配置。但另一方面，它在移除引用时更强大。
比如，假设一组工作中的每个工作都需要使用特定的模板,
与其在每一点上都要说明这一点，不如在一个总括的声明中分别声明。

所以，与其
```
jobs: {
  foo: acmeMonitoring & { /* ... */ }
  bar: acmeMonitoring & { /* ... */ }
  baz: acmeMonitoring & { /* ... */ }
}
```

不如

```
jobs: [string]: acmeMonitoring

jobs: {
    foo: { /* ... */ }
    bar: { /* ... */ }
    baz: { /* ... */ }
}
```

没必要为所有 job 都重复 monitoring 模板的引用，随着第一条声明了，所有的 job 都 _必须_ 使用 `acmeMonitoring`，这类需求可以跨文件指定。

这个方法不仅减少了 `acmeMonitoring` 重复代码块，也去掉了 `jobs` 中为每个 job 指定模板的重复部分。
同时，这个声明作为一个类型执行。
这种双重功能是 CUE 和典型的结构化语言的一个关键不同的方面。

当然，当 `acmeMonitoring` 中的限制太过于严格，jobs 会覆盖它们，这种方法会失效。
在这种情况下，CUE提供了允许默认（allow defaults）、选择退出（opt-out）和软约束（soft constraints）的机制。

### 将配置从计算中分离

以后，人们（或许）需要通过复杂的计算来生成一些配置数据。
但是，当需要快速进行修改时，配置语言的简单性可能是最重要的。
这些显然是相互冲突的利益。

CUE 的立场是计算和配置需要分离，而且 CUE 实际上也使其变得简单。
需要计算的数据可以在 CUE 之外进行生成，然后放到需要合并的文件中。
甚至数据可以在 CUE 的脚本层进行生成然后自动的注入到配置中。
两种方法都依赖 CUE 的特性，即这些数据添加的顺序是不相关的。

### 对所有规模都有用

一门语言是否有用可能取决于项目的规模，使用太多的语言会给开发者带来认知上的压力，
而且随着规模的变化，从一门语言转到另一种语言成本非常高。
CUE 的目标是在所有规模的项目都覆盖到大量的数据相关以及配置相关的任务而最小化这些成本。

**小规模**
当项目规模很小时，减少配置中的重复代码块并不是一定要做的事。
但是即使规模很小，重复也容易出错。对于这种情况，CUE 可以定义 规范 用于验证无类型数据文件的有效性。

**中规模**
只要想要减少重复代码块，`cue` 工具就可以帮助来自动重写配置。
请到 [Kubernetes tutorial](/docs/tutorials/kubernetes) 的 Quick and Dirty 
这一节查看关于使用 `import` 和 `trim` 工具的例子。
使用这个方法，可以清理成千上万行。

**大规模**
CUE 就是为大规模配置而生，它的导入模型（import model）包含了大规模开发的最佳实践，而且对自动化进行了优化。
其中一个关键点是高级工具，CUE 的操作所依赖的数学模型（mathematical model）允许实现自动化，这对于大多数其他方法来说是无法实现的。
CUE 的 `trim` 命令就是其中一个例子。

### 工具 

自动化是关键。

现在，机器可以进行生成、分析、重新格式化一段很好的代码。
CUE 语言本身、CUE API 以及工具已经被设计成允许机器操作。

包括以下几方面：

- 使 CUE 易于扫描和解析
- 对 import 进行限制
- 允许任何数据片段跨文件以及从不同来源进行生成
- 以目录级别定义 package
- 当然还有就是它的 value 和 type 的模型

顺序无关性也在其中发挥了关键作用。
它允许通过各种来源合并约束条件，而不需要必须定义任何顺序，以获得想要的结果。

<!-- something about this?
Not turing complete.
Run in contexts where cost is hard to attribute.
Easier to make claims about termination (smart contracts).
-->
