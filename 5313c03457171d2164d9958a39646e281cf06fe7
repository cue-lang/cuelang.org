{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2b55dce3_b9a80f26",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 102,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T11:09:59Z",
      "side": 1,
      "message": "arguably exiting with ^C/SIGINT is normal, and shouldn\u0027t exit with a non-zero status unless there was an error, so I agree with the TODO. it\u0027s fairly normal for apps to run for a little bit longer on SIGINT, to clean up after themselves and exit gracefully.",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9a2c741_c500aa05",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 102,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T12:55:50Z",
      "side": 1,
      "message": "I\u0027ll leave the TODO and the `os.Exit(1)` for now. Because what I don\u0027t want to do (now/at all) is thread `context.Context` through everything. So while there are some critical things that we might need/want to tidy up, we otherwise just want to exit fast. That could mean, however, that the state of files on disk is not consistent. i.e. the `hugo/content` directory structure is in a partially transformed state. Hence, the `os.Exit(1)` at least hints that there might be something wrong. The TODO can, I think, be to update this away from a straight `os.Exit(1)` to an `os.Exit(0)` in the situation we know we left things in a consistent state. \n\nI\u0027ve added much of this response to the TODO comment FYI.",
      "parentUuid": "2b55dce3_b9a80f26",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c1e2818e_802b49f6",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 102,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T13:21:21Z",
      "side": 1,
      "message": "SGTM, definitely not a blocker",
      "parentUuid": "c9a2c741_c500aa05",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b327438a_a6f5b57b",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 112,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T11:09:59Z",
      "side": 1,
      "message": "you could consider using https://pkg.go.dev/os/signal#NotifyContext for handling signals in your serve method, then you can pass this context along to exec.CommandContext to stop hugo as well, and similarly use the context to stop the other goroutines.",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "151cacda_f9ff16b4",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 112,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T12:55:50Z",
      "side": 1,
      "message": "For now at least I\u0027m happy leaving this as is. Because we might well move to a world where we invoke hugo as a library, not via the command.",
      "parentUuid": "b327438a_a6f5b57b",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acda40be_247bd2ee",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 113,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T11:09:59Z",
      "side": 1,
      "message": "nit: since this is for `os/exec`, might as well use an `os.Pipe`, since otherwise `os/exec` will need to spawn goroutines with their own pipes to copy data from the OS pipe to your in-memory `io.Pipe`. you can cut the middleman, with the only caveat that you\u0027ll need to close the two ends of the pipe when the command is done.",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c7bbebd_0efe6a6e",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 113,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T12:55:50Z",
      "side": 1,
      "message": "Done. Thanks, TIL.",
      "parentUuid": "acda40be_247bd2ee",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cce8fbbd_fbade29c",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 182,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T11:09:59Z",
      "side": 1,
      "message": "perhaps this needs a TODO similar to the one on os.Exit, to gracefully stop this goroutine when the user hits SIGINT",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33b2fee2_1012cb4e",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 182,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T12:55:50Z",
      "side": 1,
      "message": "I\u0027ve added a comment linking to the TODO on the `os.Exit(1)` above. Good point.",
      "parentUuid": "cce8fbbd_fbade29c",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05b5fbfb_a0e073d2",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 220,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T11:09:59Z",
      "side": 1,
      "message": "nit: Lstat, unless you want to support symlinks, but in that case you probably need special logic for them as you might be watching both the link source and target.\n\nI also wonder if fsnotify could give you something like a fs.DirEntry so you could tell if it\u0027s a directory without an extra syscall. surely fsnotify already knows.",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7d6293a_0c52b7ea",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 220,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T12:55:50Z",
      "side": 1,
      "message": "\u003e nit: Lstat, unless you want to support symlinks, but in that case you probably need special logic for them as you might be watching both the link source and target.\n\nGood point. The docs probably need making precise in this regard (at some point).\n\n\u003e I also wonder if fsnotify could give you something like a fs.DirEntry so you could tell if it\u0027s a directory without an extra syscall. surely fsnotify already knows.\n\nI\u0027m not sure there\u0027s value in that:\n\n* it costs memory, and you aren\u0027t guaranteed the consume will use it.\n* it\u0027s racey. \n\nSo it feels better the way it is.",
      "parentUuid": "05b5fbfb_a0e073d2",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b8b4e32_13fc8fd3",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 220,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2023-05-05T13:21:21Z",
      "side": 1,
      "message": "I might be wrong, but I would think one fs.DirEntry per modified file will be pretty light, and I think it would be useful more often than not - kinda like a filepath.WalkDir. In fact it would be nice if the two APIs were similar.\n\nYou\u0027re right that there\u0027s an inherent race with getting the DirEntry info, since it may be seconds out of date. Though you doing an Lstat here is also slightly racy, as you use the file shortly after doing the Lstat :) \n\nNot a blocker either way, just an idea. If we ever get to a large enough number of files to process, duplicating syscalls might matter, particularly on OSs like Mac or Windows. Or if we plan to suggest this API to upstream fsnotify, I\u0027d keep it in mind.",
      "parentUuid": "f7d6293a_0c52b7ea",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "15b15a7b_36918c0a",
        "filename": "internal/cmd/preprocessor/cmd/serve.go",
        "patchSetId": 41
      },
      "lineNbr": 220,
      "author": {
        "id": 1017723
      },
      "writtenOn": "2023-05-05T13:29:57Z",
      "side": 1,
      "message": "\u003e I think it would be useful more often than not\n\nI have no way of measuring that. So again I tend towards a simpler, entirely lightweight API as a starting point. I clearly wouldn\u0027t be against something larger, but it\u0027s clearly not that hard to react as each consumer requires. It also means the consumer is forced to consider how to deal with errors. It would be a more complicated API if the consumer received an fs.DirEntry or an error. Not terrible, but not zero cognitive overhead either.\n\n\u003e Though you doing an Lstat here is also slightly racy, as you use the file shortly after doing the Lstat :)\n\nIndeed, which is why we ignore errors and continue. Nothing will be perfect, but I do tend to agree with the underlying fsnotify API of being minimal. \n\n\u003e Not a blocker either way, just an idea. If we ever get to a large enough number of files to process, duplicating syscalls might matter, particularly on OSs like Mac or Windows. Or if we plan to suggest this API to upstream fsnotify, I\u0027d keep it in mind.\n\nHappy to consider any approach for sure. \n\nNot that there are a number of ways in which we can make the batch handling more efficient as we range over evs. The implementation for now is basic for sure. I was leaning on the side of simple correctness for now.",
      "parentUuid": "0b8b4e32_13fc8fd3",
      "revId": "5313c03457171d2164d9958a39646e281cf06fe7",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}