---
title: How to import GitHub Actions workflow files into CUE
weight:
tags:
    - cue command
---

This guide shows you the one-time process of importing pre-existing GitHub
Actions workflow files into CUE. It also shows the related process of exporting
the configuration back into the YAML form that GitHub Actions requires, which
you will perform each time a change is made to a CUE-based workflow file.

## Prerequisites

- You have [CUE installed](https://cuelang.org/docs/install/) locally. This
  allows you to run `cue` commands.
- You have a set of GitHub Actions workflow files.
  - The examples shown in this guide are taken from CUE's
    [github-actions-example repository](https://github.com/cue-examples/github-actions-example/tree/main/.github/workflows),
    but you don't need to use that repository in any way.
- You have a [git client installed](https://git-scm.com/downloads).

## Steps

{{step}}
Change directory into the root of the repository that contains your GitHub
Actions workflow files.

Ensure you start this process with a clean git state, with no modified files.
For example:

```console
$ cd github-actions-example
$ git status
On branch main
nothing to commit, working tree clean
```

{{step}}
Initialise a CUE module named after the organisation and repository you're
working with. For example:

```console
$ cue mod init github.com/cue-examples/github-actions-example
```

{{step}}
Create a directory called `github` that will hold your CUE-based GitHub Actions
workflow files, inside a *parent* directory that will hold a CUE tool, later
on.

The parent directory's name must contain only numbers, letters and underscores,
for CUE package-related reasons.

{{< info >}}
The examples in this guide use a parent directory named `ci`, inside a
top-level directory named `internal`. You may change either of the names
`internal` and `ci`, and nest the `github` directory wherever your repository
requires, but it is important to name the directory `github` and to keep it
inside a parent directory that is a valid
[CUE package name]({{< ref "docs/language-guide/file-organization/packages" >}}).
If you choose to use a different directory hierarchy you will need to adapt
some commands and CUE code as you follow this guide.
{{< /info >}}

For example:

```console
$ mkdir -p internal/ci/github
```

{{step}}
Import the YAML-based workflow files into CUE, placing each workflow inside the
top-level `workflow` struct, inside a struct named after its original file:

```console
$ cue import ./.github/workflows/ --with-context -p github -l 'workflow:' -l 'strings.TrimSuffix(path.Base(filename),".yml")' -f
```

{{step}}
Move the newly-created CUE files into their dedicated directory:

```console
$ mv ./.github/workflows/*.cue internal/ci/github
```

{{step}}
Create a CUE "tool" file named `github_actions_tool.cue` in the directory
*above* the workflows' dedicated directory. For example, if you have kept the
same directory layout as the example, this file must be created as
`internal/ci/github_actions_tool.cue`. This tool will perform an on-demand
export of each CUE-based workflow back into its required YAML file.

The file contains 3 elements that you must adapt to your repository and setup
after creating the file. These elements are indicated with `TODO` comments.

Copy this CUE into place:

```text {title="internal/ci/github_actions_tool.cue", linenos=table}
// TODO: match this package name *precisely* with the name of the single
// directory that directly contains this file.
package ci

import (
	"path"
	"encoding/yaml"
	"tool/file"

	// TODO: modify this import to reflect the name of the CUE module you
	// initialised at the start of this guide, followed by the relative path from
	// the repository root to the `github` directory.
	"github.com/cue-examples/github-actions-example/internal/ci/github"
)

_goos: string @tag(os,var=os)

// Regenerate all workflow files
command: regenerate: {
	workflows: {
		// TODO: update _toolFile to reflect the directory hierarchy containing this file.
		let _toolFile = "internal/ci/github_actions_tool.cue"
		let _workflowDir = path.FromSlash(".github/workflows", path.Unix)
		let _donotedit = "Code generated by \(_toolFile); DO NOT EDIT."

		clean: {
			glob: file.Glob & {
				glob: path.Join([_workflowDir, "*.yml"], _goos)
				files: [...string]
			}
			for _, _filename in glob.files {
				"Delete \(_filename)": file.RemoveAll & {path: _filename}
			}
		}

		create: {
			for _workflowName, _workflow in github.workflow
			let _filename = _workflowName + ".yml" {
				"Generate \(_filename)": file.Create & {
					$after: [ for v in clean {v}]
					filename: path.Join([_workflowDir, _filename], _goos)
					contents: "# \(_donotedit)\n\n\(yaml.Marshal(_workflow))"
				}
			}
		}
	}
}
```

Make the modifications indicated by `TODO` comments, and delete the comment
lines.

{{step}}
With the modified `github_actions_tool.cue` file in place, check that the
`regenerate` command is available. For example, if you have placed the
`github_actions_tool.cue` file in the example's directory of `internal/ci`, run
the following *from the root of the repository*:

```console
$ cue help cmd regenerate ./internal/ci   # the "./" prefix is required
Regenerate all workflow files

Usage:
  cue cmd regenerate [flags]

[...]
```

{{< warning >}}
If you *don't* see the `regenerate` command listed, or receive an error
message, double check the contents of the `github_actions_tool.cue` file and
the modifications you made to it, as well as its location in the repository.
Make sure you've followed all the steps in this guide carefully, and that you
invoked the above `cue help` command from the root of the repository.
{{< /warning >}}

{{step}}
Now that the `regenerate` command has been confirmed as being available, invoke
it to regenerate all YAML-based workflow files from their CUE sources. For
example:

```console
$ cue cmd regenerate ./internal/ci   # the "./" prefix is required
```

{{step}}
Use `git` to check that there is only a single change to each YAML-based
workflow file from their original, imported form. This change is the addition
of a header, warning the reader not to edit the YAML file directly. For
example:

```diff
$ git diff .github/workflows/
diff --git a/.github/workflows/workflow1.yml b/.github/workflows/workflow1.yml
index 28e7051..416bad0 100644
--- a/.github/workflows/workflow1.yml
+++ b/.github/workflows/workflow1.yml
@@ -1,3 +1,5 @@
+# Code generated by internal/ci/github_actions_tool.cue; DO NOT EDIT.
+
 jobs:
   workflow1_job1:
     strategy:
diff --git a/.github/workflows/workflow2.yml b/.github/workflows/workflow2.yml
index 813ebf6..622f998 100644
--- a/.github/workflows/workflow2.yml
+++ b/.github/workflows/workflow2.yml
@@ -1,3 +1,5 @@
+# Code generated by internal/ci/github_actions_tool.cue; DO NOT EDIT.
+
 jobs:
   workflow2_job1:
     runs-on: ubuntu-latest
```

{{step}}
Add and commit the following files and directories to git:

- `.github/workflows/*.yml`
- your CUE tool file (e.g. `internal/ci/github_actions_tool.cue`)
- the directory containing your CUE GitHub workflow files (e.g.
  `internal/ci/github`)

For example:

```console
$ git add -p .github/workflows internal/ci/
$ git commit -m "ci: added FooBar to GHA workflow Baz"
```

{{step}}
**Well done - your GitHub Actions workflow files have been imported into CUE!**

They can now be managed using CUE's expressive and powerful features, leading
to safer, more reliable and more predictable changes.

From now on, each time you make a change to a CUE workflow file, immediately
regenerate the YAML files that GitHub Actions requires, and commit your changes
to both the CUE and YAML files. For example:

```console
$ cue cmd regenerate ./internal/ci   # the "./" prefix is required
$ git add -p .github/workflows internal/ci/
$ git commit -m "ci: placed a Frobnitz inside the Quux workflow"
```

#### Further reading/See Also

- Debugging CUE tool commands
- Using the regenerate-on-dev-laptop-but-check-in-CI pattern with CUE
- [cmd/cue command line documentation](https://cue.googlesource.com/cue/+/refs/tags/v0.2.0/doc/cmd/cue.md)
