[
    ,
    
            {
        "objectID": "c36442589885b6461a2169fd3ddca8e8_1",
        "title": "Contribution Guide",
        "link": "/docs/reference/contribution-guidelines/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "24f8af96ad9af5402a24ec24ba30682f_1",
        "title": "Inputs",
        "link": "/docs/concept/using-the-cue-export-command/inputs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003c!-- SENSE CHECK\nA note to the content author/reviewer/updater:\nThis guide contains several upload\u0026script blocks inside HTML comments.\nThey are present to act as invisible build-time sense checks on the truth of\nthe statements presented above them, where explicitly presenting a rendered\nblock validating each statement would make the page too long and verbose for\nthe reader.\n\nBecause we don't have a formal spec for `cue export` (modulo the actual code),\nthese scripts will check that the significant points exposed in prose remain\ntrue across CUE releases. Exact output is *not* tested, as these blocks aren't\nmeant to be byte-for-byte output checks. Content checks (e.g. grep) /can/\nfollow a command invocation, but only insofar as they're needed to assert the\napplicability of the command's success or failure, or to avoid the situation\nwhere a \"cmp\" check might be semi-silently neutered by a preprocessor execution\nwith the \"--update\" flag specified during the preparation for a CUE upgrade.\n\nThese blocks are *not* \"hidden\" blocks, but they're invisible because they're\ninside an HTML comment (which Hugo strips out when processing). They're encoded\nlike this so that they *can* be rendered, in order to assist with debugging if\nthey start failing in the future. Enable their rendering by removing the\nopening HTML comment element.\n\nWhen upgrading the site to a new CUE version, if something *does* change and\nbreak an assertion, then new wording for this page doesn't need to be written\nmid-upgrade. Just comment out (\"#\") or negate (\"!\") the failing command (and\nits optional trailing content checks) as needed to get the page to build, and\nopen a cue-lang/docs-and-content issue tracking the breakage, labelled as\n\"bug\". --\u003e\n\u003cp\u003eThe \u003ccode\u003ecue export\u003c/code\u003e command can be given any number of inputs to evaluate via file\nor package arguments. This page explains how the command interprets, assembles,\nand combines these inputs when handed different kinds and quantities of input.\u003c/p\u003e",
        "content": "The cue export command can be given any number of inputs to evaluate via file or package arguments. This page explains how the command interprets, assembles, and combines these inputs when handed different kinds and quantities of input. No input arguments When cue export is invoked with zero arguments its input is the single package in the current directory: Copied! default-input.cue Copy code Copied! package example A: 1 B: 2.2 + A C: 3.33 * B TERMINAL Copy code Copied! $ cue export { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 3.2, \u0026#34;C\u0026#34;: 10.656 } The package is loaded as a package instance. The command fails if more than one package exists in the current directory and the input isn\u0026rsquo;t explicitly specified: Copied! 1.cue Copied! 2.cue Copy code Copied! package one message: \u0026#34;this is package one\u0026#34; Copy code Copied! package two message: \u0026#34;this is package two\u0026#34; TERMINAL Copy code Copied! $ cue export found packages \u0026#34;one\u0026#34; (1.cue) and \u0026#34;two\u0026#34; (2.cue) in \u0026#34;.\u0026#34; One input argument The argument \u0026ldquo;.\u0026rdquo; refers to the single package in the current directory: Copied! 1.cue Copy code Copied! package one message: \u0026#34;this is package one\u0026#34; TERMINAL Copy code Copied! $ cue export . { \u0026#34;message\u0026#34;: \u0026#34;this is package one\u0026#34; } If you want to export the contents of a CUE package, but there is more than one package in the current directory, tell cue export which package to process by providing its import path as an argument: Copied! 1.cue Copied! 2.cue Copy code Copied! package one message: \u0026#34;this is package one\u0026#34; Copy code Copied! package two message: \u0026#34;this is package two\u0026#34; TERMINAL Copy code Copied! $ cue export .:two { \u0026#34;message\u0026#34;: \u0026#34;this is package two\u0026#34; } The previous example shows a rooted import path (.:two), as explained in cue help inputs. If the only argument is the path to a data file then the file\u0026rsquo;s contents are interpreted in the encoding implied by its filename suffix, and the input processed by cue export is the resulting data: Copied! path/to/some/data.yaml Copy code Copied! message: this is a YAML data file TERMINAL Copy code Copied! $ cue export path/to/some/data.yaml { \u0026#34;message\u0026#34;: \u0026#34;this is a YAML data file\u0026#34; } Individual CUE files can also be referred to directly, by filename, instead of being used through their import path at the package level. However import paths, rather than CUE files, are the suggested way to refer to CUE as they automatically include new and renamed files in the package. Referring directly to CUE files requires you to keep cue export invocations up to date, manually, if you change the names of the files being used or add files to the package \u0026ndash; potentially leading to errors due to missing configuration, if care is not taken to include every file that\u0026rsquo;s part of the package. Input file encodings The filename suffixes that cue export understands are described in cue help filetypes. These include .json, .yml, .yaml, .toml, and .cue. If a filename suffix is recognised, then cue export automatically interprets the file as the encoding implied by the suffix. If the encoding of a file doesn\u0026rsquo;t match its filename suffix, use a qualifier to specify the encoding: Copied! some-yaml.data Copy code Copied! message: this YAML file has a .data suffix TERMINAL Copy code Copied! $ cue export yaml: some-yaml.data { \u0026#34;message\u0026#34;: \u0026#34;this YAML file has a .data suffix\u0026#34; } A qualifier dictates the encoding of every file that follows it, up to the next qualifier. In each separate cue export invocation (considering its parameters in order) after a qualifier has been used, all files are interpreted through that qualifier\u0026rsquo;s encoding until it\u0026rsquo;s overridden by a subsequent qualifier. There is no way for the invocation to re-engage the interpretation of filename suffixes. Qualifiers include json:, yaml:, and cue:, and are described in cue help filetypes. Multiple input arguments When you specify more than one argument then the input that cue export evaluates varies, based on what types of input you provide. Informally, you can think about all potential inputs being subdivided into these five types: Complete CUE packages (a \u0026ldquo;CUE package\u0026rdquo;) Individual CUE files that have a package clause near the top of the file (a \u0026ldquo;CUE package file\u0026rdquo;) CUE files that do not have a package clause near the top (a \u0026ldquo;package-less CUE file\u0026rdquo;) Non-CUE data files (a \u0026ldquo;data file\u0026rdquo;) Non-CUE schema or constraint files, such as JSON Schema, OpenAPI, or Protobuf (a \u0026ldquo;constraint file\u0026rdquo;) These types and names aren\u0026rsquo;t formally defined or specified - they\u0026rsquo;re just informal classifications that you can keep in mind as you read this guide. CUE package inputs A CUE package input can either be combined with other CUE package inputs, or it can be combined with any other input types. A CUE package input cannot be combined with other CUE package inputs and other input types at the same time. Combining multiple CUE package inputs When multiple CUE package inputs are specified then the resulting CUE evaluation is executed once for each package: Copied! 1.cue Copied! 2.cue Copied! 3.cue Copy code Copied! package one A: 1 Copy code Copied! package two B: 2 Copy code Copied! package three C: 3 TERMINAL Copy code Copied! $ cue export .:one :two .:three { \u0026#34;A\u0026#34;: 1 } { \u0026#34;B\u0026#34;: 2 } { \u0026#34;C\u0026#34;: 3 } Multiple CUE package inputs cannot be combined with any other input types - only other CUE package inputs. Combining one CUE package input with other input types When a single CUE package input is specified alongside other input types then cue export unifies all the inputs and evaluates the result of this unification. Any number of inputs belonging to other input types may be combined with a single CUE package input. The CUE package input must be the first input specified in the list of arguments. Issue #3341 tracks a problem when combining a CUE package input with a constraint file and some other input types. Each input contributes the kind of information to the unification that you would expect: data file inputs contribute data; constraint file",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "24f8af96ad9af5402a24ec24ba30682f_2",
        "title": "Inputs",
        "link": "/docs/concept/using-the-cue-export-command/inputs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003c!-- SENSE CHECK\nA note to the content author/reviewer/updater:\nThis guide contains several upload\u0026script blocks inside HTML comments.\nThey are present to act as invisible build-time sense checks on the truth of\nthe statements presented above them, where explicitly presenting a rendered\nblock validating each statement would make the page too long and verbose for\nthe reader.\n\nBecause we don't have a formal spec for `cue export` (modulo the actual code),\nthese scripts will check that the significant points exposed in prose remain\ntrue across CUE releases. Exact output is *not* tested, as these blocks aren't\nmeant to be byte-for-byte output checks. Content checks (e.g. grep) /can/\nfollow a command invocation, but only insofar as they're needed to assert the\napplicability of the command's success or failure, or to avoid the situation\nwhere a \"cmp\" check might be semi-silently neutered by a preprocessor execution\nwith the \"--update\" flag specified during the preparation for a CUE upgrade.\n\nThese blocks are *not* \"hidden\" blocks, but they're invisible because they're\ninside an HTML comment (which Hugo strips out when processing). They're encoded\nlike this so that they *can* be rendered, in order to assist with debugging if\nthey start failing in the future. Enable their rendering by removing the\nopening HTML comment element.\n\nWhen upgrading the site to a new CUE version, if something *does* change and\nbreak an assertion, then new wording for this page doesn't need to be written\nmid-upgrade. Just comment out (\"#\") or negate (\"!\") the failing command (and\nits optional trailing content checks) as needed to get the page to build, and\nopen a cue-lang/docs-and-content issue tracking the breakage, labelled as\n\"bug\". --\u003e\n\u003cp\u003eThe \u003ccode\u003ecue export\u003c/code\u003e command can be given any number of inputs to evaluate via file\nor package arguments. This page explains how the command interprets, assembles,\nand combines these inputs when handed different kinds and quantities of input.\u003c/p\u003e",
        "content": "inputs contribute constraints; CUE package file and package-less CUE file inputs contribute data and constraints, depending on the CUE they contain. Here\u0026rsquo;s an example demonstrating multiple input types being specified alongside a single CUE package: Copied! 1.cue Copied! min.cue Copied! max.cue Copied! data.yml Copy code Copied! package one // Field x must be present. x!: _ Copy code Copied! package min x: \u0026gt;10 Copy code Copied! x: \u0026lt;=99 Copy code Copied! x: 50 TERMINAL Copy code Copied! $ cue export .:one min.cue data.yml max.cue { \u0026#34;x\u0026#34;: 50 } If CUE package file inputs are present then their package clauses need to be the same as each other, but don\u0026rsquo;t need to match the name of any CUE package input that\u0026rsquo;s present. By definition, package-less CUE file inputs don\u0026rsquo;t contain a package clause, so this requirement doesn\u0026rsquo;t affect them. CUE package file inputs As a reminder, CUE package file inputs are CUE files that contain a package clause near the top, and are distinguished from CUE package inputs as they\u0026rsquo;re referenced individually during an invocation, and not by a package import path. In other words, CUE package file inputs are any CUE files containing a package clause that you explicitly tell cue export to process. When you mention a CUE package file input alongside a data file input, the inputs are unified, with any resulting concrete data being validated against any constraints that are present in the CUE: Copied! 1.cue Copied! data.yml Copy code Copied! package one A: 1 // A is the concrete value 1. B?: \u0026gt;100 // B must be greater than 100. Copy code Copied! A: \u0026#34;some string\u0026#34; B: 99 TERMINAL Copy code Copied! $ cue export 1.cue data.yml A: conflicting values \u0026#34;some string\u0026#34; and 1 (mismatched types string and int): ./1.cue:3:5 ./data.yml:1:4 B: invalid value 99 (out of bound \u0026gt;100): ./1.cue:4:5 ./data.yml:2:4 When you tell cue export to process a CUE package file input alongside a CUE package input, their package names don\u0026rsquo;t need to match. However, if you mention multiple CUE package file inputs, then the package names of all the CUE package file inputs must be the same as each other - but they still don\u0026rsquo;t need to match any CUE package input that\u0026rsquo;s also present. A package-less CUE file input (a CUE file that doesn\u0026rsquo;t contain a package clause) can be included alongside CUE package file and CUE package inputs. In all these situations the inputs are unified, with any data being validated against any constraints that are present: Copied! package.cue Copied! min.cue Copied! max.cue Copied! calc.cue Copied! data.yml Copy code Copied! package one // Field x must be present. x!: _ Copy code Copied! package two x: \u0026gt;10 Copy code Copied! package two x: \u0026lt;=99 Copy code Copied! z: x * 2 Copy code Copied! x: 50 TERMINAL Copy code Copied! $ cue export .:one min.cue max.cue data.yml calc.cue { \u0026#34;x\u0026#34;: 50, \u0026#34;z\u0026#34;: 100 } Package-less CUE file inputs cue export handles package-less CUE file inputs identically to data file inputs - they\u0026rsquo;re treated equivalently, and are interchangeable as cue export arguments. However, where data file inputs can only introduce concrete data, package-less CUE file inputs can also include constraints, calculated fields, and all other CUE language features alongside their concrete data. Their contributions to the evaluation are unified as you might expect - their constraints add to the set of constraints that validate the concrete data, and their concrete data is validated against the set of constraints derived from all constraint-related input types. Data file inputs Data file inputs contain concrete data, encoded as JSON, YAML or TOML. If they are specified alongside other input types then they are treated as described in the sections above. If they are processed without other input types being present, then cue export simply unifies the data they contain. As always, unification is recursive, processing nested data structures to an arbitrary depth: Copied! data.json Copied! data.yml Copy code Copied! { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: { \u0026#34;C\u0026#34;: 2 }, \u0026#34;E\u0026#34;: [ 4, { \u0026#34;F\u0026#34;: 5 }, 7 ] } Copy code Copied! A: 1 B: D: 3 E: - 4 - G: 6 - 7 TERMINAL Copy code Copied! $ cue export data.yml data.json { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: { \u0026#34;C\u0026#34;: 2, \u0026#34;D\u0026#34;: 3 }, \u0026#34;E\u0026#34;: [ 4, { \u0026#34;F\u0026#34;: 5, \u0026#34;G\u0026#34;: 6 }, 7 ] } If any values don\u0026rsquo;t unify successfully, at any depth, an error message is printed: Copied! data.yml Copied! data.json Copy code Copied! A: - 1 - B: 2 - 4 Copy code Copied! { \u0026#34;A\u0026#34;: [ 1, { \u0026#34;B\u0026#34;: 3 } ] } TERMINAL Copy code Copied! $ cue export data.yml data.json A.1.B: conflicting values 2 and 3: ./data.json:5:18 ./data.yml:3:8 A: incompatible list lengths (2 and 3): ./data.yml:2:3 Constraint file inputs A constraint file input contains one or more data constraints expressed in a non-CUE encoding such as JSON Schema, OpenAPI or Protocol Buffers. They can be combined with all other input types, with their constraints being unified with constraints from any other inputs, which are then used to validate any data inputs. A constraint file input can be used without any CUE-based inputs. cue export can validate data directly against a constraint file input: Copied! schema.json Copied! data.yml Copy code Copied! { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema#\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;A\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;minimum\u0026#34;: 100 }, \u0026#34;B\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;maximum\u0026#34;: 99 } } } Copy code Copied! A: 50 B: 1000 TERMINAL Copy code Copied! $ cue export data.yml schema.json A: invalid value 50 (out of bound \u0026gt;=100): ./schema.json:7:13 ./data.yml:1:4 B: invalid value 1000 (out of bound \u0026lt;=99): ./schema.json:11:13 ./data.yml:2:4 Issue #3341 tracks a problem when combining a CUE package input with a constraint file and some other input types. cue export recognizes JSON Schema and OpenAPI constraint file inputs through their signature fields. This behaviour can be changed by using a qualifier to instruct the command to treat the constraint file input as pure data: Copied! schema.json Copy code Copied! { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema#\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;A\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;,",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "24f8af96ad9af5402a24ec24ba30682f_3",
        "title": "Inputs",
        "link": "/docs/concept/using-the-cue-export-command/inputs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003c!-- SENSE CHECK\nA note to the content author/reviewer/updater:\nThis guide contains several upload\u0026script blocks inside HTML comments.\nThey are present to act as invisible build-time sense checks on the truth of\nthe statements presented above them, where explicitly presenting a rendered\nblock validating each statement would make the page too long and verbose for\nthe reader.\n\nBecause we don't have a formal spec for `cue export` (modulo the actual code),\nthese scripts will check that the significant points exposed in prose remain\ntrue across CUE releases. Exact output is *not* tested, as these blocks aren't\nmeant to be byte-for-byte output checks. Content checks (e.g. grep) /can/\nfollow a command invocation, but only insofar as they're needed to assert the\napplicability of the command's success or failure, or to avoid the situation\nwhere a \"cmp\" check might be semi-silently neutered by a preprocessor execution\nwith the \"--update\" flag specified during the preparation for a CUE upgrade.\n\nThese blocks are *not* \"hidden\" blocks, but they're invisible because they're\ninside an HTML comment (which Hugo strips out when processing). They're encoded\nlike this so that they *can* be rendered, in order to assist with debugging if\nthey start failing in the future. Enable their rendering by removing the\nopening HTML comment element.\n\nWhen upgrading the site to a new CUE version, if something *does* change and\nbreak an assertion, then new wording for this page doesn't need to be written\nmid-upgrade. Just comment out (\"#\") or negate (\"!\") the failing command (and\nits optional trailing content checks) as needed to get the page to build, and\nopen a cue-lang/docs-and-content issue tracking the breakage, labelled as\n\"bug\". --\u003e\n\u003cp\u003eThe \u003ccode\u003ecue export\u003c/code\u003e command can be given any number of inputs to evaluate via file\nor package arguments. This page explains how the command interprets, assembles,\nand combines these inputs when handed different kinds and quantities of input.\u003c/p\u003e",
        "content": "\u0026#34;minimum\u0026#34;: 100 }, \u0026#34;B\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;maximum\u0026#34;: 99 } } } TERMINAL Copy code Copied! $ cue export json: schema.json { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema#\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;A\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;minimum\u0026#34;: 100 }, \u0026#34;B\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;maximum\u0026#34;: 99 } } } Standard input stream The standard input stream of the cue export command is available for processing as any file-based input type, through its pseudo-filename of \u0026ldquo;-\u0026rdquo;. By default, standard input is processed as CUE \u0026ndash; either as a CUE package file or package-less CUE file input, depending if the stream contains a package clause or not. To indicate that cue export should interpret the stream through a different encoding, use a qualifier: Copied! data.yml Copy code Copied! A: - b - c TERMINAL Copy code Copied! $ cat data.yml | cue export yaml: - { \u0026#34;A\u0026#34;: [ \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; ] } Non-CUE data location During evaluation, cue export unifies all its inputs and, by default, places the contents of any data file inputs at the top-level of the evaluation space. You can change this behaviour by specifying a static or dynamic location for all data file inputs using the --path (-l) flag. This flag is described in cue help flags and is demonstrated below. Static locations To specify a static location for the data file inputs during evaluation, provide the --path (-l) flag with a CUE expression that ends with a colon (:): Copied! data.yml Copy code Copied! data: true TERMINAL Copy code Copied! $ cue export data.yml --path foo: { \u0026#34;foo\u0026#34;: { \u0026#34;data\u0026#34;: true } } Increase the depth and nesting of the location by adding more components to the expression: Copied! data.yml Copy code Copied! data: true TERMINAL Copy code Copied! $ cue export data.yml -l foo:bar:baz: { \u0026#34;foo\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;baz\u0026#34;: { \u0026#34;data\u0026#34;: true } } } } You can also provide multiple path components through repeated instances of the flag. For example, the previous example is equivalent to -l foo: -l bar: -l baz:. The combined values of all --path (-l) flags that are present in a cue export invocation apply to all the data file inputs. The flags' positions in the invocation are irrelevant, no matter where they sit relative to any arguments defining the inputs to be processed. When specifying a static location, this means that the data in all data file inputs is unified at the location provided. If there are multiple data file inputs, all their contents must unify without errors: Copied! data.json Copy code Copied! { \u0026#34;data\u0026#34;: false } Copied! data.yml Copy code Copied! data: true TERMINAL Copy code Copied! $ cue export -l foo: data.yml -l bar: data.json -l baz: foo.bar.baz.data: conflicting values true and false: ./data.json:2:13 ./data.yml:1:7 Dynamic locations As you saw in the previous section, a trailing colon (:) tells cue export that a value in the location expression should be interpreted statically. If the colon is omitted, then the value is resolved dynamically - in the context of the data that\u0026rsquo;s present: Copied! data.yml Copy code Copied! foo: \u0026#34;a\u0026#34; data: true TERMINAL Copy code Copied! $ cue export data.yml -l foo { \u0026#34;a\u0026#34;: { \u0026#34;foo\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;data\u0026#34;: true } } Functions from the CUE standard library may be included in the specification of a dynamic expression, without their containing packages being imported: Copied! data.yml Copy code Copied! foo: \u0026#34;a\u0026#34; data: true TERMINAL Copy code Copied! $ cue export data.yml -l \u0026#39;strings.ToUpper(foo)\u0026#39; { \u0026#34;A\u0026#34;: { \u0026#34;foo\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;data\u0026#34;: true } } Adding the --with-context flag changes the context in which the dynamic expression is evaluated, allowing it to refer to information about a data file input (such as the file\u0026rsquo;s name) as described in cue help flags: Copied! data.yml Copy code Copied! data: true TERMINAL Copy code Copied! $ cue export data.yml -l \u0026#39;path.Base(filename)\u0026#39; --with-context { \u0026#34;data.yml\u0026#34;: { \u0026#34;data\u0026#34;: true } } Data files with multiple documents Some encodings, such as YAML, permit multiple documents to be contained in a single file. When processing such data file inputs, cue export offers a choice of how to combine these documents. The default behaviour is to merge the documents normally, as is done via unification. Because they are merged, their contents must be values that unify successfully. Copied! data.yml Copy code Copied! --- A: 1 --- B: 2 --- C: 3 TERMINAL Copy code Copied! $ cue export data.yml --merge { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3 } Merging is the command\u0026rsquo;s default behaviour, so the --merge flag is optional. Alternatively, you can opt for multiple documents to be placed in a list by providing the --list flag. This behaviour permits the contents of each document to be addressed individually, rather than as the unified value that would be present when using the --merge flag. This can be useful when each document needs to be processed separately, or when documents contain values which cannot unify: Copied! data.yml Copy code Copied! --- A: 1 --- A: 2 --- A: 3 TERMINAL Copy code Copied! $ cue export data.yml --list [ { \u0026#34;A\u0026#34;: 1 }, { \u0026#34;A\u0026#34;: 2 }, { \u0026#34;A\u0026#34;: 3 } ] Information injection System information and arbitrary values can be made available to an evaluation by using tag variables and tag attributes. They are described in cue help injection, and are demonstrated in the how-to guides Injecting system information into an evaluation using a tag variable and Injecting a value into an evaluation using a tag attribute. Related content Reference: The cue export command Language Tour: Unification Reference: cue help filetypes Reference: cue help flags Reference: cue help injection Reference: cue help inputs Concept Guide: Modules, Packages, and Instances Language Tour: Standard Library How-to Guide: Injecting system information into an evaluation using a tag variable How-to Guide: Injecting a value into an evaluation using a tag attribute",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "d1742b0a409facb9dc9b2828826c6df3_1",
        "title": "Introduction",
        "link": "/docs/introduction/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"welcome\"\u003e\n    \u003ca href=\"#welcome\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eCUE is an open-source data validation language and inference engine\nwith its roots in logic programming.\nAlthough the language is not a general-purpose programming language,\nit has many applications, such as\ndata validation, data templating, configuration, querying,\ncode generation and even scripting.\nThe inference engine can be used to validate\ndata in code or to include it as part of a code generation pipeline.\u003c/p\u003e\n\u003cp\u003eA key thing that sets CUE apart from its peer languages\nis that it merges types and values into a single concept.\u003c/p\u003e",
        "content": "Welcome! CUE is an open-source data validation language and inference engine with its roots in logic programming. Although the language is not a general-purpose programming language, it has many applications, such as data validation, data templating, configuration, querying, code generation and even scripting. The inference engine can be used to validate data in code or to include it as part of a code generation pipeline. A key thing that sets CUE apart from its peer languages is that it merges types and values into a single concept. Whereas in most languages types and values are strictly distinct, CUE orders them in a single hierarchy (a lattice, to be precise). This is a very powerful concept that allows CUE to do many fancy things. It also simplifies matters. For instance, there is no need for generics, and enums, sum types and null coalescing are all the same thing. Applications CUE\u0026rsquo;s design ensures that combining CUE values in any order always gives the same result (it is associative, commutative and idempotent). This makes CUE particularly well-suited for cases where CUE constraints are combined from different sources: Data validation: different departments or groups can each define their own constraints to apply to the same set of data. Code extraction and generation: extract CUE definitions from multiple sources (Go code, Protobuf), combine them into a single definition, and use that to generate definitions in another format (e.g. OpenAPI). Configuration: values can be combined from different sources without one having to import the other. The ordering of values also allows set containment analysis of entire configurations. Where most validation systems are limited to checking whether a concrete value matches a schema, CUE can validate whether any instance of one schema is also an instance of another (is it backwards compatible?), or compute a new schema that represents all instances that match two other schema. History Although it is a very different language, the roots of CUE lie in GCL, the dominant configuration language in use at Google as of this writing. It was originally designed to configure Borg, the predecessor of Kubernetes. In fact, the original idea was to use graph unification as used in CUE for GCL. One of the authors of GCL had extensive experience with such systems and experienced the benefit of being able to compute and reason with types for the creation of powerful tooling. The graph unification model CUE is based on was in common use in computational linguistics at that time and was successfully used to manage grammars and lexicons of over 100k lines of declarative definitions. These were effectively very large configurations of something as irregular and complex as a human language. A property of these systems were that the types, or constraints, one defines validate the data while simultaneously reducing boilerplate. Overall, this approach seemed to be extremely well-suited for cloud configuration. However, the early design of GCL went for something simpler that coincidentally was also incompatible with the notion of graph unification. This simpler approach proved insufficient, but it was already too late to move to the earlier foreseen approach. Instead, an inheritance-based override model was adopted. Its complexity made the earlier foreseen tooling intractable and they never materialized. The same holds for the GCL offsprings that copied its model. CUE goes back to the original idea of using a constraint-based approach and also makes an effort to incorporate lessons learned from 15 years of GCL usage. This also includes lessons learned from offsprings and different approaches to configuration altogether. Philosophy and principles Types are Values CUE does not distinguish between values and types. This is a powerful notion that allows CUE to define ultra-detailed constraints, but it also simplifies things considerably: there is no separate schema or data definition language to learn and related language constructs such as sum types, enums, and even null coalescing collapse onto a single construct. Below is a demonstration of this concept. On the left one can see a JSON object (in CUE syntax) with some properties about the city of Moscow. The middle column shows a possible schema for any municipality. On the right one sees a mix between data and schema as is exemplary of CUE. Data Copy code Copied! moscow: { name: \u0026#34;Moscow\u0026#34; pop: 11.92M capital: true } Schema Copy code Copied! municipality: { name: string pop: int capital: bool } CUE Copy code Copied! largeCapital: { name: string pop: \u0026gt;5M capital: true } In general, in CUE one starts with a broad definition of a type, describing all possible instances. One then narrows down these definitions, possibly by combining constraints from different sources (departments, users), until a concrete data instance remains. Push, not pull, constraints CUE\u0026rsquo;s constraints act as data validators, but also double as a mechanism to reduce boilerplate. This is a powerful approach, but requires some different thinking. With traditional inheritance approaches one specifies the templates that are to be inherited from at each point they should be used. In CUE, instead, one selects a set of nodes in the configuration to which to apply a template. This selection can be at a different point in the configuration altogether. Another way to view this, a JSON configuration, say, can be defined as a sequence of path-leaf values. For instance, Copy code Copied! { \u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;foo\u0026#34; } } could be represented as Copy code Copied! \u0026#34;a\u0026#34;: 3 \u0026#34;b\u0026#34;: \u0026#34;c\u0026#34;: \u0026#34;foo\u0026#34; All the information of the original JSON file is retained in this representation. CUE generalizes this notion to the following pattern: Copy code Copied! \u0026lt;set of nodes\u0026gt;: \u0026lt;constraints\u0026gt; Each field declaration in CUE defines a set of nodes to which to apply a specific constraint. Because order doesn\u0026rsquo;t matter, multiple constraints can be applied to the same nodes, all of which need to apply simultaneously. Such constraints may even be in different files. But they may never contradict each other: if one declaration says a field is 5, another may not override it to be 6. Declaring a field to be",
        "breadcrumb": ["Documentation"],
        "contentType": "Introduction",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "d1742b0a409facb9dc9b2828826c6df3_2",
        "title": "Introduction",
        "link": "/docs/introduction/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"welcome\"\u003e\n    \u003ca href=\"#welcome\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eCUE is an open-source data validation language and inference engine\nwith its roots in logic programming.\nAlthough the language is not a general-purpose programming language,\nit has many applications, such as\ndata validation, data templating, configuration, querying,\ncode generation and even scripting.\nThe inference engine can be used to validate\ndata in code or to include it as part of a code generation pipeline.\u003c/p\u003e\n\u003cp\u003eA key thing that sets CUE apart from its peer languages\nis that it merges types and values into a single concept.\u003c/p\u003e",
        "content": "both \u0026gt;5 and \u0026lt;10 is valid, though. This approach is more restricted than full-blown inheritance; it may not be possible to reuse existing configurations. On the other hand, it is also a more powerful boilerplate remover. For instance, suppose each job in a set needs to use a specific template. Instead of having to spell this out at each point, one can declare this separately in a one blanket statement. So instead of Copy code Copied! jobs: { foo: acmeMonitoring \u0026amp; {...} bar: acmeMonitoring \u0026amp; {...} baz: acmeMonitoring \u0026amp; {...} } one can write Copy code Copied! jobs: [string]: acmeMonitoring jobs: { foo: {...} bar: {...} baz: {...} } There is no need to repeat the reference to the monitoring template for each job, as the first already states that all jobs must use acmeMonitoring. Such requirements can be specified across files. This approach not only reduces the boilerplate contained in acmeMonitoring but also removes the repetitiveness of having to specify this template for each job in jobs. At the same time, this statement acts as a type enforcement. This dual function is a key aspect of CUE and typed feature structure languages in general. This approach breaks down, of course, if the restrictions in acmeMonitoring are too stringent and jobs need to override them. To this extent, CUE provides mechanisms to allow defaults, opt-out, and soft constraints. Separate configuration from computation There comes a time that one (seemingly) will need do complex computations to generate some configuration data. But simplicity of a configuration language can be paramount when one quickly needs to make changes. These are obviously conflicting interests. CUE takes the stance that computation and configuration should be separated. And CUE actually makes this easy. The data that needs to be computed can be generated outside of CUE and put in a file that is to be mixed in. The data can even be generated in CUE\u0026rsquo;s scripting layer and automatically injected in a configuration pipeline. Both approaches rely on CUE\u0026rsquo;s property that the order in which this data gets added is irrelevant. Be useful at all scales The usefulness of a language may depend on the scale of the project. Having too many different languages can put a cognitive strain on developers, though, and migrating from one language to another as scaling requirements change can be very costly. CUE aims to minimize these costs by covering a myriad of data- and configuration-related tasks at all scales. Small scale At small scales, reducing boilerplate in configurations is not necessarily the best thing to do. Even at a small scale, however, repetition can be error prone. For such cases, CUE can define schema to validate otherwise typeless data files. Medium scale As soon the desire arises to reduce boilerplate, the cue tool can help to automatically rewrite configurations. See the Quick and Dirty section of the Kubernetes tutorial for an example using the import and trim tool. Thousands of lines can be obliterated automatically using this approach. Large scale CUE\u0026rsquo;s underlying formalism was developed for large-scale configuration. Its import model incorporates best practices for large-scale engineering and it is optimized for automation. A key to this is advanced tooling. The mathematical model underlying CUE\u0026rsquo;s operations allows for automation that is intractable for most other approaches. CUE\u0026rsquo;s trim command is an example of this. Tooling Automation is key. Nowadays, a good chunk of code gets generated, analyzed, reformatted, and so on by machines. The CUE language, APIs, and tooling have been designed to allow for machine manipulation. Aspects of this are: make the language easy to scan and parse, restrictions on imports, allow any piece of data to be split across files and generated from different sources, define packages at the directory level, and of course its value and type model. The order independence also plays a key role in this. It allows combining constraints from various sources without having to define any order in which they are to be applied to get predictable results.",
        "breadcrumb": ["Documentation"],
        "contentType": "Introduction",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "943a5f61b6e6e500d58efd4f9756a544_1",
        "title": "JSON",
        "link": "/docs/integration/json/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Integrations"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "db6a738f6ac81971fc78beb436622e73_1",
        "title": "Operators",
        "link": "/docs/tour/expressions/operators/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE supports common arithmetic and boolean operators, which apply to its\nnumerical types \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, and \u003ccode\u003enumber\u003c/code\u003e.\nSome of these operators also apply to the \u003ccode\u003estring\u003c/code\u003e and \u003ccode\u003ebytes\u003c/code\u003e types.\u003c/p\u003e\n\u003cp\u003eCUE provides three different \u003cem\u003edivision\u003c/em\u003e operations.\nTo produce a \u003ccode\u003efloat\u003c/code\u003e, CUE supports the infix \u003ccode\u003e/\u003c/code\u003e operator with the standard\nmathematical meaning.\nArguments can be \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, or a mixture of the two.\nCUE also provides\n\u003ca href=\"/docs/howto/use-the-built-in-functions-div-mod-quo-rem/\"\u003ebuilt-in functions\u003c/a\u003e\nthat produce an \u003ccode\u003eint\u003c/code\u003e by calculating \u003cem\u003einteger division and remainder\u003c/em\u003e.\nThey support Euclidean division (\u003ccode\u003ediv\u003c/code\u003e / \u003ccode\u003emod\u003c/code\u003e) and truncated division (\u003ccode\u003equo\u003c/code\u003e / \u003ccode\u003erem\u003c/code\u003e).\u003c/p\u003e",
        "content": "CUE supports common arithmetic and boolean operators, which apply to its numerical types int, float, and number. Some of these operators also apply to the string and bytes types. CUE provides three different division operations. To produce a float, CUE supports the infix / operator with the standard mathematical meaning. Arguments can be float, int, or a mixture of the two. CUE also provides built-in functions that produce an int by calculating integer division and remainder. They support Euclidean division (div / mod) and truncated division (quo / rem). Copied! operators.cue Copy code Copied! a: 1 + 1 // type int b: \u0026#34;XXX\u0026#34; + \u0026#34;OOO\u0026#34; // type string c: 2 * 2 // type int d: 2 * 2.0 // type float e: 3.14159 - 0.14159 // type float f: 6 / 2 // type: float g: 6.0 / 2.0 // type: float h: 1 \u0026lt;= 2.0 // type bool i: 3.0 \u0026gt; 3 // type bool // String types are compared lexically byte-wise j: \u0026#34;aaa\u0026#34; \u0026gt;= \u0026#34;ZZZ\u0026#34; // type bool k: div(10, 3) // type int l: mod(10, 3) // type int TERMINAL Copy code Copied! $ cue eval operators.cue a: 2 b: \u0026#34;XXXOOO\u0026#34; c: 4 d: 4.0 e: 3.00000 f: 3.0 g: 3.0 h: true i: false j: true k: 3 l: 1 The CUE languge specification details the operator precedence levels.",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a58175fbf2e50d5d2b56fbe066a7524e_1",
        "title": "Packages",
        "link": "/docs/tour/packages/packages/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBy default, each CUE file is a standalone file.\u003c/p\u003e\n\u003cp\u003eA configuration can be split across multiple files by adding a \u003ccode\u003epackage\u003c/code\u003e clause\nto each file.\u003c/p\u003e\n\u003cp\u003eThe configuration for each package is defined by the concatenation of all its files,\nafter stripping their package clauses and merging their import statements.\nMultiple definitions of the same field across files and within the same file\nare treated similarly, because\n\u003ca href=\"/docs/tour/basics/order-irrelevance/\"\u003eorder does not matter\u003c/a\u003e.\u003c/p\u003e",
        "content": "By default, each CUE file is a standalone file. A configuration can be split across multiple files by adding a package clause to each file. The configuration for each package is defined by the concatenation of all its files, after stripping their package clauses and merging their import statements. Multiple definitions of the same field across files and within the same file are treated similarly, because order does not matter. Copied! policy.cue Copy code Copied! package config foo: bar/2 - 1 bar!: int Copied! data.cue Copy code Copied! package config bar: 200 TERMINAL Copy code Copied! $ cue export # No filenames mentioned { \u0026#34;foo\u0026#34;: 99, \u0026#34;bar\u0026#34;: 200 } The cue tool processes lists of CUE files and package paths. Because working with a single package split across multiple files in the current directory is such a common situation, cue processes that single package if it isn\u0026rsquo;t told to look at anything else.",
        "breadcrumb": ["Documentation","Tour","Packages and Imports"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "eb58b8512902e327f0bd4d19eeeab3df_1",
        "title": "Popular guides",
        "link": "/docs/concept/popular-guides/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " The Logic of CUE CUE Modules Using the \u0026#34;cue export\u0026#34; command Common use cases How CUE enables configuration How CUE enables data validation Schema Definition Code Generation and Extraction Querying ",
        "content": "The Logic of CUE CUE Modules Using the \u0026#34;cue export\u0026#34; command Common use cases How CUE enables configuration How CUE enables data validation Schema Definition Code Generation and Extraction Querying",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "d4f6509ae3126638303e672ff69745a1_1",
        "title": "Popular guides",
        "link": "/docs/howto/popular-guides/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " How to validate JSON using CUE How to validate YAML using CUE How to mark a field as required Transforming JSON with CUE Transforming YAML with CUE How to mark a field as optional How to specify a default value for a field ",
        "content": "How to validate JSON using CUE How to validate YAML using CUE How to mark a field as required Transforming JSON with CUE Transforming YAML with CUE How to mark a field as optional How to specify a default value for a field",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "b392bdf56af23ad4590698d75538aeb8_1",
        "title": "References and Scopes",
        "link": "/docs/tour/references/scopes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA \u003cstrong\u003ereference\u003c/strong\u003e refers to the value of the field defined within the nearest\nenclosing \u003cstrong\u003escope\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIf a reference doesn\u0026rsquo;t match a field within the same file,\nthen it may match a top-level field defined in any other file making up the\nsame CUE package.\u003c/p\u003e\n\u003cp\u003eIf there is still no match then it may match a predefined value, such as a\n\u003ca href=\"/docs/tour/types/bounddef/\"\u003epredefined bound\u003c/a\u003e.\u003c/p\u003e",
        "content": "A reference refers to the value of the field defined within the nearest enclosing scope. If a reference doesn\u0026rsquo;t match a field within the same file, then it may match a top-level field defined in any other file making up the same CUE package. If there is still no match then it may match a predefined value, such as a predefined bound. Copied! file.cue Copy code Copied! val: 1 A: { val: 2 B: val // Matches the inner val } A: { C: val // Matches the top-level val } B: val // Matches the top-level val TERMINAL Copy code Copied! $ cue eval file.cue val: 1 A: { val: 2 B: 2 C: 1 } B: 1",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_1",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "Note to implementors Notes on the formalism underlying this specification can be found here. Introduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE. CUE was designed with cloud configuration and related systems in mind, but is not limited to this domain. It derives its formalism from relational programming languages. This formalism allows for managing and reasoning over large amounts of data in a straightforward manner. The grammar is compact and regular, allowing for easy analysis by automatic tools such as integrated development environments. This document is maintained by mpvl@golang.org. CUE has a lot of similarities with the Go language. This document draws heavily from the Go specification as a result. CUE draws its influence from many languages. Its main influences were BCL/GCL (internal to Google), LKB (LinGO), Go, and JSON. Others are Swift, Typescript, Javascript, Prolog, NCL (internal to Google), Jsonnet, HCL, Flabbergast, Nix, JSONPath, Haskell, Objective-C, and Python. Notation The syntax is specified using Extended Backus-Naur Form (EBNF): Copy code Copied! Production = production_name \u0026#34;=\u0026#34; [ Expression ] \u0026#34;.\u0026#34; . Expression = Alternative { \u0026#34;|\u0026#34; Alternative } . Alternative = Term { Term } . Term = production_name | token [ \u0026#34;\u0026#34; token ] | Group | Option | Repetition . Group = \u0026#34;(\u0026#34; Expression \u0026#34;)\u0026#34; . Option = \u0026#34;[\u0026#34; Expression \u0026#34;]\u0026#34; . Repetition = \u0026#34;{\u0026#34; Expression \u0026#34;}\u0026#34; . Productions are expressions constructed from terms and the following operators, in increasing precedence: Copy code Copied! | alternation () grouping [] option (0 or 1 times) {} repetition (0 to n times) Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes \u0026quot;\u0026quot; or back quotes ``. The form a  b represents the set of characters from a through b as alternatives. The horizontal ellipsis  is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character  (as opposed to the three characters ...) is not a token of the CUE language. Source code representation Source code is Unicode text encoded in UTF-8. Unless otherwise noted, the text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text. Each code point is distinct; for instance, upper and lower case letters are different characters. Implementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text. Implementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source. Characters The following terms are used to denote specific Unicode character classes: Copy code Copied! newline = /* the Unicode code point U+000A */ . unicode_char = /* an arbitrary Unicode code point except newline */ . unicode_letter = /* a Unicode code point classified as \u0026#34;Letter\u0026#34; */ . unicode_digit = /* a Unicode code point classified as \u0026#34;Number, decimal digit\u0026#34; */ . In The Unicode Standard 8.0, Section 4.5 \u0026ldquo;General Category\u0026rdquo; defines a set of character categories. CUE treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits. Letters and digits The underscore character _ (U+005F) is considered a letter. Copy code Copied! letter = unicode_letter | \u0026#34;_\u0026#34; | \u0026#34;$\u0026#34; . decimal_digit = \u0026#34;0\u0026#34;  \u0026#34;9\u0026#34; . binary_digit = \u0026#34;0\u0026#34;  \u0026#34;1\u0026#34; . octal_digit = \u0026#34;0\u0026#34;  \u0026#34;7\u0026#34; . hex_digit = \u0026#34;0\u0026#34;  \u0026#34;9\u0026#34; | \u0026#34;A\u0026#34;  \u0026#34;F\u0026#34; | \u0026#34;a\u0026#34;  \u0026#34;f\u0026#34; . Lexical elements Comments Comments serve as program documentation. CUE supports line comments that start with the character sequence // and stop at the end of the line. A comment cannot start inside a string literal or inside a comment. A comment acts like a newline. Tokens Tokens form the vocabulary of the CUE language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a comma. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token. Commas The formal grammar uses commas , as terminators in a number of productions. CUE programs may omit most of these commas using the following rules: When the input is broken into tokens, a comma is automatically inserted into the token stream immediately after a line\u0026rsquo;s final token if that token is an identifier, keyword, or bottom a number or string literal, including an interpolation one of the characters ), ], }, or ? an ellipsis ... Although commas are automatically inserted, the parser will require explicit commas between two list elements. To reflect idiomatic use, examples in this document elide commas using these rules. Identifiers Identifiers name entities such as fields and aliases. An identifier is a sequence of one or more letters (which includes _ and $) and digits, optionally preceded by # or _#. It may not be _ or $. The first character in an identifier, or after an # if it contains one, must be a letter. Identifiers starting with a # or _ are reserved",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_2",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "for definitions and hidden fields. Copy code Copied! identifier = [ \u0026#34;#\u0026#34; | \u0026#34;_#\u0026#34; ] letter { letter | unicode_digit } . Copy code Copied! a _x9 fieldName  Some identifiers are predeclared. Keywords CUE has a limited set of keywords. In addition, CUE reserves all identifiers starting with __ (double underscores) as keywords. These are typically targets of pre-declared identifiers. All keywords may be used as labels (field names). Unless noted otherwise, they can also be used as identifiers to refer to the same name. Values The following keywords are values. Copy code Copied! null true false These can never be used to refer to a field of the same name. This restriction is to ensure compatibility with JSON configuration files. Preamble The following keywords are used at the preamble of a CUE file. After the preamble, they may be used as identifiers to refer to namesake fields. Copy code Copied! package import Comprehension clauses The following keywords are used in comprehensions. Copy code Copied! for in if let Operators and punctuation The following character sequences represent operators and punctuation: Copy code Copied! + \u0026amp;\u0026amp; == \u0026lt; = ( ) - || != \u0026gt; : { } * \u0026amp; =~ \u0026lt;= ? [ ] , / | !~ \u0026gt;= ! _|_ ... . Numeric literals There are several kinds of numeric literals. Copy code Copied! int_lit = decimal_lit | si_lit | octal_lit | binary_lit | hex_lit . decimal_lit = \u0026#34;0\u0026#34; | ( \u0026#34;1\u0026#34;  \u0026#34;9\u0026#34; ) { [ \u0026#34;_\u0026#34; ] decimal_digit } . decimals = decimal_digit { [ \u0026#34;_\u0026#34; ] decimal_digit } . si_it = decimals [ \u0026#34;.\u0026#34; decimals ] multiplier | \u0026#34;.\u0026#34; decimals multiplier . binary_lit = \u0026#34;0b\u0026#34; binary_digit { [ \u0026#34;_\u0026#34; ] binary_digit } . hex_lit = \u0026#34;0\u0026#34; ( \u0026#34;x\u0026#34; | \u0026#34;X\u0026#34; ) hex_digit { [ \u0026#34;_\u0026#34; ] hex_digit } . octal_lit = \u0026#34;0o\u0026#34; octal_digit { [ \u0026#34;_\u0026#34; ] octal_digit } . multiplier = ( \u0026#34;K\u0026#34; | \u0026#34;M\u0026#34; | \u0026#34;G\u0026#34; | \u0026#34;T\u0026#34; | \u0026#34;P\u0026#34; ) [ \u0026#34;i\u0026#34; ] float_lit = decimals \u0026#34;.\u0026#34; [ decimals ] [ exponent ] | decimals exponent | \u0026#34;.\u0026#34; decimals [ exponent ]. exponent = ( \u0026#34;e\u0026#34; | \u0026#34;E\u0026#34; ) [ \u0026#34;+\u0026#34; | \u0026#34;-\u0026#34; ] decimals . An integer literal is a sequence of digits representing an integer value. An optional prefix sets a non-decimal base: 0o for octal, 0x or 0X for hexadecimal, and 0b for binary. In hexadecimal literals, letters a  f and A  F represent values 10 through 15. All integers allow interstitial underscores _; these have no meaning and are solely for readability. Integer literals may have an SI or IEC multiplier. Multipliers can be used with fractional numbers. When multiplying a fraction by a multiplier, the result is truncated towards zero if it is not an integer. Copy code Copied! 42 1.5G // 1_500_000_000 1.3Ki // 1.3 * 1024 = trunc(1331.2) = 1331 170_141_183_460_469_231_731_687_303_715_884_105_727 0xBad_Face 0o755 0b0101_0001 A decimal floating-point literal is a representation of a decimal floating-point value (a float). It has an integer part, a decimal point, a fractional part, and an exponent part. The integer and fractional part comprise decimal digits; the exponent part is an e or E followed by an optionally signed decimal exponent. One of the integer part or the fractional part may be elided; one of the decimal point or the exponent may be elided. Copy code Copied! 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 Neither a float_lit nor an si_lit may appear after a token that is: an identifier, keyword, or bottom a number or string literal, including an interpolation one of the characters ), ], }, ?, or .. String and byte sequence literals A string literal represents a string constant obtained from concatenating a sequence of characters. Byte sequences are a sequence of bytes. String and byte sequence literals are character sequences between, respectively, double and single quotes, as in \u0026quot;bar\u0026quot; and 'bar'. Within the quotes, any character may appear except newline and, respectively, unescaped double or single quote. String literals may only be valid UTF-8. Byte sequences may contain any sequence of bytes. Several escape sequences allow arbitrary values to be encoded as ASCII text. An escape sequence starts with an escape delimiter, which is \\ by default. The escape delimiter may be altered to be \\ plus a fixed number of hash symbols # by padding the start and end of a string or byte sequence literal with this number of hash symbols. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base. Hexadecimal and octal escapes are only allowed within byte sequences (single quotes). Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF. Surrogate halves are allowed, but are translated into their non-surrogate equivalent internally. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while , \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. Copy code Copied! \\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000b vertical tab \\/ U+002f slash (solidus) \\\\ U+005c backslash \\\u0026#39; U+0027 single quote (valid escape only within single quoted literals) \\\u0026#34; U+0022 double",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_3",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "quote (valid escape only within double quoted literals) The escape \\( is used as an escape for string interpolation. A \\( must be followed by a valid CUE Expression, followed by a ). A backslash at the end of a line elides the line terminator that follows it. This may not escape the final newline inside a multiline string: that newline is already implicitly elided. All other sequences starting with a backslash are illegal inside literals. Copy code Copied! escaped_char = `\\` { `#` } ( \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;f\u0026#34; | \u0026#34;n\u0026#34; | \u0026#34;r\u0026#34; | \u0026#34;t\u0026#34; | \u0026#34;v\u0026#34; | \u0026#34;/\u0026#34; | `\\` | \u0026#34;\u0026#39;\u0026#34; | `\u0026#34;` ) . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` { `#` } octal_digit octal_digit octal_digit . hex_byte_value = `\\` { `#` } \u0026#34;x\u0026#34; hex_digit hex_digit . little_u_value = `\\` { `#` } \u0026#34;u\u0026#34; hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` { `#` } \u0026#34;U\u0026#34; hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . interpolation = \u0026#34;\\\u0026#34; { `#` } \u0026#34;(\u0026#34; Expression \u0026#34;)\u0026#34; . string_lit = simple_string_lit | multiline_string_lit | simple_bytes_lit | multiline_bytes_lit | `#` string_lit `#` . simple_string_lit = `\u0026#34;` { unicode_value | interpolation } `\u0026#34;` . simple_bytes_lit = `\u0026#39;` { unicode_value | interpolation | byte_value } `\u0026#39;` . multiline_string_lit = `\u0026#34;\u0026#34;\u0026#34;` newline { unicode_value | interpolation | newline } newline `\u0026#34;\u0026#34;\u0026#34;` . multiline_bytes_lit = \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34; newline { unicode_value | interpolation | byte_value | newline } newline \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34; . Carriage return characters (\\r) inside string literals are discarded from the string value. Copy code Copied! \u0026#39;a\\000\\xab\u0026#39; \u0026#39;\\007\u0026#39; \u0026#39;\\377\u0026#39; \u0026#39;\\xa\u0026#39; // illegal: too few hexadecimal digits \u0026#34;\\n\u0026#34; \u0026#34;\\\u0026#34;\u0026#34; \u0026#39;Hello, world!\\n\u0026#39; \u0026#34;Hello, \\( name )!\u0026#34; \u0026#34;\u0026#34; \u0026#34;\\u65e5\\U00008a9e\u0026#34; \u0026#39;\\xff\\u00FF\u0026#39; \u0026#34;\\uD800\u0026#34; // illegal: surrogate half (TODO: probably should allow) \u0026#34;\\U00110000\u0026#34; // illegal: invalid Unicode code point #\u0026#34;This is not an \\(interpolation)\u0026#34;# #\u0026#34;This is an \\#(interpolation)\u0026#34;# #\u0026#34;The sequence \u0026#34;\\U0001F604\u0026#34; renders as \\#U0001F604.\u0026#34;# These examples all represent the same string: Copy code Copied! \u0026#34;\u0026#34; // UTF-8 input text \u0026#39;\u0026#39; // UTF-8 input text as byte sequence \u0026#34;\\u65e5\\u672c\\u8a9e\u0026#34; // the explicit Unicode code points \u0026#34;\\U000065e5\\U0000672c\\U00008a9e\u0026#34; // the explicit Unicode code points \u0026#39;\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\u0026#39; // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will appear as two code points if placed in a string literal. Strings and byte sequences have a multiline equivalent. Multiline strings are like their single-line equivalent, but allow newline characters. Multiline strings and byte sequences respectively start with a triple double quote (\u0026quot;\u0026quot;\u0026quot;) or triple single quote ('''), immediately followed by a newline, which is discarded from the string contents. The string is closed by a matching triple quote, which must be by itself on a new line, preceded by optional whitespace. The newline preceding the closing quote is discarded from the string contents. The whitespace before a closing triple quote must appear before any non-empty line after the opening quote and will be removed from each of these lines in the string literal. A closing triple quote may not appear in the string. To include it is suffices to escape one of the quotes. Copy code Copied! \u0026#34;\u0026#34;\u0026#34; lily: out of the water out of itself bass picking \\ bugs off the moon  Nick Virgilio, Selected Haiku, 1988 \u0026#34;\u0026#34;\u0026#34; This represents the same string as: Copy code Copied! \u0026#34;lily:\\nout of the water\\nout of itself\\n\\n\u0026#34; + \u0026#34;bass\\npicking bugs\\noff the moon\\n\u0026#34; + \u0026#34;  Nick Virgilio, Selected Haiku, 1988\u0026#34; Values In addition to simple values like \u0026quot;hello\u0026quot; and 42.0, CUE has structs. A struct is a map from labels to values, like {a: 42.0, b: \u0026quot;hello\u0026quot;}. Structs are CUE\u0026rsquo;s only way of building up complex values; lists, which we will see later, are defined in terms of structs. All possible values are ordered in a lattice, a partial order where every two elements have a single greatest lower bound. A value a is an instance of a value b, denoted a  b, if b == a or b is more general than a, that is if a orders before b in the partial order ( is not a CUE operator). We also say that b subsumes a in this case. In graphical terms, b is \u0026ldquo;above\u0026rdquo; a in the lattice. At the top of the lattice is the single ancestor of all values, called top, denoted _ in CUE. Every value is an instance of top. At the bottom of the lattice is the value called bottom, denoted _|_. A bottom value usually indicates an error. Bottom is an instance of every value. An atom is any value whose only instances are itself and bottom. Examples of atoms are 42.0, \u0026quot;hello\u0026quot;, true, and null. A value is concrete if it is either an atom, or a struct whose field values are all concrete, recursively. CUE\u0026rsquo;s values also include what we normally think of as types, like string and float. It does not distinguish between types and values: only the relationship of values in the lattice is important. Each CUE \u0026ldquo;type\u0026rdquo; subsumes the concrete values that one would normally think of as part of that type. For example, \u0026quot;hello\u0026quot; is an instance of string, and 42.0 is an instance of float. In addition to string and float, CUE has null, int, bool, and bytes. We informally call these CUE\u0026rsquo;s \u0026ldquo;basic types\u0026rdquo;. Copy code Copied! false  bool true  bool true  true 5.0  float bool  _ _|_  _ _|_  _|_ _  _|_ _  bool int  bool bool  int false  true true  false float  5.0 5  6 Unification The unification of values a and b is defined as the greatest lower bound of a and b. (That is, the value u such that u  a and u  b, and for any other value v for which v  a and v  b it holds that v  u.) Since CUE",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_4",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "values form a lattice, the unification of two CUE values is always unique. These all follow from the definition of unification: The unification of a with itself is always a. The unification of values a and b where a  b is always a. The unification of a value with bottom is always bottom. Unification in CUE is a binary expression, written a \u0026amp; b. It is commutative, associative, and idempotent. As a consequence, order of evaluation is irrelevant, a property that is key to many of the constructs in the CUE language as well as the tooling layered on top of it. Disjunction The disjunction of values a and b is defined as the least upper bound of a and b. (That is, the value d such that a  d and b  d, and for any other value e for which a  e and b  e, it holds that d  e.) This style of disjunctions is sometimes also referred to as sum types. Since CUE values form a lattice, the disjunction of two CUE values is always unique. These all follow from the definition of disjunction: The disjunction of a with itself is always a. The disjunction of a value a and b where a  b is always b. The disjunction of a value a with bottom is always a. The disjunction of two bottom values is bottom. Disjunction in CUE is a binary expression, written a | b. It is commutative, associative, and idempotent. The unification of a disjunction with another value is equal to the disjunction composed of the unification of this value with all of the original elements of the disjunction. In other words, unification distributes over disjunction. Copy code Copied! (a_0 | ... |a_n) \u0026amp; b ==\u0026gt; a_0\u0026amp;b | ... | a_n\u0026amp;b. Copy code Copied! Expression Result ({a:1} | {b:2}) \u0026amp; {c:3} {a:1, c:3} | {b:2, c:3} (int | string) \u0026amp; \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; (\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;) \u0026amp; \u0026#34;c\u0026#34; _|_ A disjunction is normalized if there is no element a for which there is an element b such that a  b. Default values Any value v may be associated with a default value d, where d must be in instance of v (d  v). Default values are introduced by means of disjunctions. Any element of a disjunction can be marked as a default by prefixing it with an asterisk * (a unary expression). Syntactically consecutive disjunctions are considered to be part of a single disjunction, whereby multiple disjuncts can be marked as default. A marked disjunction is one where any of its terms are marked. So a | b | *c | d is a single marked disjunction of four terms, whereas a | (b | *c | d) is an unmarked disjunction of two terms, one of which is a marked disjunction of three terms. During unification, if all the marked disjuncts of a marked disjunction are eliminated, then the remaining unmarked disjuncts are considered as if they originated from an unmarked disjunction As explained below, distinguishing the nesting of disjunctions like this is only relevant when both an outer and nested disjunction are marked. Intuitively, when an expression needs to be resolved for an operation other than unification or disjunction, non-starred elements are dropped in favor of starred ones if the starred ones do not resolve to bottom. To define the unification and disjunction operation we use the notation v to denote a CUE value v that is not associated with a default and the notation v, d to denote a value v associated with a default value d. The rewrite rules for unifying such values are as follows: Copy code Copied! U0: v1 \u0026amp; v2 =\u0026gt; v1\u0026amp;v2 U1: v1, d1 \u0026amp; v2 =\u0026gt; v1\u0026amp;v2, d1\u0026amp;v2 U2: v1, d1 \u0026amp; v2, d2 =\u0026gt; v1\u0026amp;v2, d1\u0026amp;d2 The rewrite rules for disjoining terms of unmarked disjunctions are Copy code Copied! D0: v1 | v2 =\u0026gt; v1|v2 D1: v1, d1 | v2 =\u0026gt; v1|v2, d1 D2: v1, d1 | v2, d2 =\u0026gt; v1|v2, d1|d2 Terms of marked disjunctions are first rewritten according to the following rules: Copy code Copied! M0: v =\u0026gt; v don\u0026#39;t introduce defaults for unmarked term M1: *v =\u0026gt; v, v introduce identical default for marked term M2: *v, d =\u0026gt; v, d keep existing defaults for marked term M3: v, d =\u0026gt; v strip existing defaults from unmarked term Note that for any marked disjunction a, the expressions a|a, *a|a and *a|*a all resolve to a. Copy code Copied! Expression Value-default pair Rules applied *\u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; \u0026#34;tcp\u0026#34;|\u0026#34;udp\u0026#34;, \u0026#34;tcp\u0026#34; M1, D1 string | *\u0026#34;foo\u0026#34; string, \u0026#34;foo\u0026#34; M1, D1 *1 | 2 | 3 1|2|3, 1 M1, D1 (*1|2|3) | (1|*2|3) 1|2|3, 1|2 M1, D1, D2 (*1|2|3) | *(1|*2|3) 1|2|3, 2 M1, M2, M3, D1, D2 (*1|2|3) | (1|*2|3)\u0026amp;2 1|2|3, 1|2 M1, D1, U1, D2 (*1|2) \u0026amp; (1|*2) 1|2, _|_ M1, D1, U2 The rules of subsumption for defaults can be derived from the above definitions and are as follows. Copy code Copied! v2, d2  v1, d1 if v2  v1 and d2  d1 v1, d1  v if v1  v v  v1, d1 if v  d1 Copy code Copied! Expression Resolves to \u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; \u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; *\u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; \u0026#34;tcp\u0026#34; float | *1 1 *string | 1.0 string (*1|2) + (2|*3) 4 (*1|2|3) | (1|*2|3) 1|2 (*1|2|3) \u0026amp; (1|*2|3) 1|2|3 // default is _|_ (* \u0026gt;=5 | int) \u0026amp; (* \u0026lt;=5 | int) 5 (*\u0026#34;tcp\u0026#34;|\u0026#34;udp\u0026#34;) \u0026amp; (\u0026#34;udp\u0026#34;|*\u0026#34;tcp\u0026#34;) \u0026#34;tcp\u0026#34; (*\u0026#34;tcp\u0026#34;|\u0026#34;udp\u0026#34;) \u0026amp; (\u0026#34;udp\u0026#34;|\u0026#34;tcp\u0026#34;) \u0026#34;tcp\u0026#34; (*\u0026#34;tcp\u0026#34;|\u0026#34;udp\u0026#34;) \u0026amp; \u0026#34;tcp\u0026#34; \u0026#34;tcp\u0026#34; (*\u0026#34;tcp\u0026#34;|\u0026#34;udp\u0026#34;) \u0026amp; (*\u0026#34;udp\u0026#34;|\u0026#34;tcp\u0026#34;) \u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; // default is _|_ (*true | false) \u0026amp; bool true (*true | false) \u0026amp; (true | false) true {a: 1} | {b: 1} {a: 1} | {b: 1} {a: 1} | *{b: 1} {b:1} *{a: 1} | *{b: 1} {a: 1} | {b: 1} ({a: 1} | {b: 1}) \u0026amp; {a:1} {a:1} | {a: 1, b: 1} ({a:1}|*{b:1}) \u0026amp; ({a:1}|*{b:1}) {b:1} Bottom and errors Any evaluation",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_5",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "error in CUE results in a bottom value, represented by the token _|_. Bottom is an instance of every other value. Any evaluation error is represented as bottom. Implementations may associate error strings with different instances of bottom; logically they all remain the same value. Copy code Copied! bottom_lit = \u0026#34;_|_\u0026#34; . Top Top is represented by the underscore character _, lexically an identifier. Unifying any value v with top results in v itself. Copy code Copied! Expr Result _ \u0026amp; 5 5 _ \u0026amp; _ _ _ \u0026amp; _|_ _|_ _ | _|_ _ Null The null value is represented with the keyword null. It has only one parent, top, and one child, bottom. It is unordered with respect to any other value. Copy code Copied! null_lit = \u0026#34;null\u0026#34; . Copy code Copied! null \u0026amp; 8 _|_ null \u0026amp; _ null null \u0026amp; _|_ _|_ Boolean values A boolean type represents the set of Boolean truth values denoted by the keywords true and false. The predeclared boolean type is bool; it is a defined type and a separate element in the lattice. Copy code Copied! bool_lit = \u0026#34;true\u0026#34; | \u0026#34;false\u0026#34; . Copy code Copied! bool \u0026amp; true true true \u0026amp; true true true \u0026amp; false _|_ bool \u0026amp; (false|true) false | true bool \u0026amp; (true|false) true | false Numeric values The integer type represents the set of all integral numbers. The decimal floating-point type represents the set of all decimal floating-point numbers. They are two distinct types. Both are instances instances of a generic number type. The predeclared number, integer, and decimal floating-point types are number, int and float; they are defined types. A decimal floating-point literal always has type float; it is not an instance of int even if it is an integral number. Integer literals are always of type int and don\u0026rsquo;t match type float. Numeric literals are exact values of arbitrary precision. If the operation permits it, numbers should be kept in arbitrary precision. Implementation restriction: although numeric values have arbitrary precision in the language, implementations may implement them using an internal representation with limited precision. That said, every implementation must: Represent integer values with at least 256 bits. Represent floating-point values with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits. Give an error if unable to represent an integer value precisely. Give an error if unable to represent a floating-point value due to overflow. Round to the nearest representable value if unable to represent a floating-point value due to limits on precision. These requirements apply to the result of any expression except for builtin functions, for which an unusual loss of precision must be explicitly documented. Strings The string type represents the set of UTF-8 strings, not allowing surrogates. The predeclared string type is string; it is a defined type. The length of a string s (its size in bytes) can be discovered using the builtin function len. Bytes The bytes type represents the set of byte sequences. A byte sequence value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the byte sequence and is never negative. The predeclared byte sequence type is bytes; it is a defined type. Bounds A bound, syntactically a unary expression, defines a logically infinite disjunction of concrete values represented as a single comparison. For example, \u0026gt;= 2 represents the infinite disjunction 2|3|4|5|6|7|. For any comparison operator op except ==, op a is the disjunction of every x such that x op a. Copy code Copied! 2 \u0026amp; \u0026gt;=2 \u0026amp; \u0026lt;=5 // 2, where 2 is either an int or float. 2.5 \u0026amp; \u0026gt;=1 \u0026amp; \u0026lt;=5 // 2.5 2 \u0026amp; \u0026gt;=1.0 \u0026amp; \u0026lt;3.0 // 2.0 2 \u0026amp; \u0026gt;1 \u0026amp; \u0026lt;3.0 // 2.0 2.5 \u0026amp; int \u0026amp; \u0026gt;1 \u0026amp; \u0026lt;5 // _|_ 2.5 \u0026amp; float \u0026amp; \u0026gt;1 \u0026amp; \u0026lt;5 // 2.5 int \u0026amp; 2 \u0026amp; \u0026gt;1.0 \u0026amp; \u0026lt;3.0 // _|_ 2.5 \u0026amp; \u0026gt;=(int \u0026amp; 1) \u0026amp; \u0026lt;5 // _|_ \u0026gt;=0 \u0026amp; \u0026lt;=7 \u0026amp; \u0026gt;=3 \u0026amp; \u0026lt;=10 // \u0026gt;=3 \u0026amp; \u0026lt;=7 !=null \u0026amp; 1 // 1 \u0026gt;=5 \u0026amp; \u0026lt;=5 // 5 Structs A struct is a set of elements called fields, each of which has a name, called a label, and value. We say a label is defined for a struct if the struct has a field with the corresponding label. The value for a label f of struct a is denoted a.f. A struct a is an instance of b, or a  b, if for any label f defined for b, label f is also defined for a and a.f  b.f. Note that if a is an instance of b it may have fields with labels that are not defined for b. The (unique) struct with no fields, written {}, has every struct as an instance. It can be considered the type of all structs. Copy code Copied! {a: 1}  {} {a: 1, b: 1}  {a: 1} {a: 1}  {a: int} {a: 1, b: 1.0}  {a: int, b: number} {}  {a: 1} {a: 2}  {a: 1} {a: 1}  {b: 1} The successful unification of structs a and b is a new struct c which has all fields of both a and b, where the value of a field f in c is a.f \u0026amp; b.f if f is defined in both a and b, or just a.f or b.f if f is in just a or b, respectively. Any references to a or b in their respective field values need to be replaced with references to c. The result of a unification is bottom (_|_) if any of its defined fields evaluates to bottom, recursively. A struct literal may contain multiple fields with the same label, the result of which is the unification of all those fields. Copy code Copied! StructLit = \u0026#34;{\u0026#34; { Declaration \u0026#34;,\u0026#34; } \u0026#34;}\u0026#34; . Declaration = Field | Ellipsis | Embedding | LetClause | attribute . Ellipsis = \u0026#34;...\u0026#34; [",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_6",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "Expression ] . Embedding = Comprehension | AliasExpr . Field = Label \u0026#34;:\u0026#34; { Label \u0026#34;:\u0026#34; } AliasExpr { attribute } . Label = [ identifier \u0026#34;=\u0026#34; ] LabelExpr . LabelExpr = LabelName [ \u0026#34;?\u0026#34; | \u0026#34;!\u0026#34; ] | \u0026#34;[\u0026#34; AliasExpr \u0026#34;]\u0026#34; . LabelName = identifier | simple_string_lit | \u0026#34;(\u0026#34; AliasExpr \u0026#34;)\u0026#34; . attribute = \u0026#34;@\u0026#34; identifier \u0026#34;(\u0026#34; attr_tokens \u0026#34;)\u0026#34; . attr_tokens = { attr_token | \u0026#34;(\u0026#34; attr_tokens \u0026#34;)\u0026#34; | \u0026#34;[\u0026#34; attr_tokens \u0026#34;]\u0026#34; | \u0026#34;{\u0026#34; attr_tokens \u0026#34;}\u0026#34; } . attr_token = /* any token except \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;{\u0026#39;, or \u0026#39;}\u0026#39; */ Copy code Copied! Expression Result {a: int, a: 1} {a: 1} {a: int} \u0026amp; {a: 1} {a: 1} {a: \u0026gt;=1 \u0026amp; \u0026lt;=7} \u0026amp; {a: \u0026gt;=5 \u0026amp; \u0026lt;=9} {a: \u0026gt;=5 \u0026amp; \u0026lt;=7} {a: \u0026gt;=1 \u0026amp; \u0026lt;=7, a: \u0026gt;=5 \u0026amp; \u0026lt;=9} {a: \u0026gt;=5 \u0026amp; \u0026lt;=7} {a: 1} \u0026amp; {b: 2} {a: 1, b: 2} {a: 1, b: int} \u0026amp; {b: 2} {a: 1, b: 2} {a: 1} \u0026amp; {a: 2} _|_ Field constraints A struct may declare field constraints which define values that should be unified with a given field once it is defined. The existence of a field constraint declares, but does not define, that field. Syntactically, a field is marked as a constraint by following its label with an optional marker ? or required marker !. These markers are not part of the field name. A struct that has a required field constraint with a bottom value evaluates to bottom. An optional field constraint with a bottom value does not invalidate the struct that contains it as long as it is not unified with a defined field. The subsumption relation for fields with the various markers is defined as Copy code Copied! {a: x}  {a!: x}  {a?: x} for any given x. Implementations may error upon encountering a required field constraint when manifesting CUE as data. Copy code Copied! Expression Result {foo?: 3} \u0026amp; {foo: 3} {foo: 3} {foo!: 3} \u0026amp; {foo: 3} {foo: 3} {foo!: int} \u0026amp; {foo: int} {foo: int} {foo!: int} \u0026amp; {foo?: \u0026lt;1} {foo!: \u0026lt;1} {foo!: int} \u0026amp; {foo: \u0026lt;=3} {foo: \u0026lt;=3} {foo!: int} \u0026amp; {foo: 3} {foo: 3} {foo!: 3} \u0026amp; {foo: int} {foo: 3} {foo!: 3} \u0026amp; {foo: \u0026lt;=4} {foo: 3} {foo?: 1} \u0026amp; {foo?: 2} {foo?: _|_} // No error {foo?: 1} \u0026amp; {foo!: 2} _|_ {foo?: 1} \u0026amp; {foo: 2} _|_ Dynamic fields A dynamic field is a field whose label is determined by an expression wrapped in parentheses. A dynamic field may be marked as optional or required. Copy code Copied! Expression Result a: \u0026#34;foo\u0026#34; a: \u0026#34;foo\u0026#34; b: \u0026#34;bar\u0026#34; b: \u0026#34;bar\u0026#34; (a): \u0026#34;baz\u0026#34; foo: \u0026#34;baz\u0026#34; (a+b): \u0026#34;qux\u0026#34; foobar: \u0026#34;qux\u0026#34; (a)?: string foo?: string (b)!: string bar!: string Pattern and default constraints A struct may define constraints that apply to a collection of fields. A pattern constraint, denoted [pattern]: value, defines a pattern, which is a value of type string, and a value to unify with fields whose label unifies with the pattern. For a given struct a with pattern constraint [p]: v, v is unified with any field with name f in a for which p \u0026amp; f is not bottom. When unifying struct a and b, any pattern constraint declared in a and b are also declared in the result of unification. Additionally, a default constraint, denoted ...value, defines a value to unify with any field for which there is no other declaration in a struct. When unifying structs a and b, a default constraint ...v declared in a defines that the value v should unify with any field in the resulting struct c whose label does not unify with any of the patterns of the pattern constraints defined for a and for which there exists no field declaration in a with that label. The token ... is a shorthand for ..._. Note: default constraints of the form ..._ are not yet implemented. Copy code Copied! a: { foo: string // foo is a string [=~\u0026#34;^i\u0026#34;]: int // all other fields starting with i are integers [=~\u0026#34;^b\u0026#34;]: bool // all other fields starting with b are booleans [\u0026gt;\u0026#34;c\u0026#34;]: string // all other fields lexically after c are strings ...string // all other fields must be a string. Note: default constraints are not yet implemented. } b: a \u0026amp; { i3: 3 bar: true other: \u0026#34;a string\u0026#34; } Concrete field labels may be an identifier or string, the latter of which may be interpolated. Fields with identifier labels can be referred to within the scope they are defined, string labels cannot. References within such interpolated strings are resolved within the scope of the struct in which the label sequence is defined and can reference concrete labels lexically preceding the label within a label sequence. Copy code Copied! intMap: [string]: int intMap: { t1: 43 t2: 2.4 // error: 2.4 is not an integer } nameMap: [string]: { firstName: string nickName: *firstName | string } nameMap: hank: firstName: \u0026#34;Hank\u0026#34; The optional field set defined by nameMap matches every field, in this case just hank, and unifies the associated constraint with the matched field, resulting in: Copy code Copied! nameMap: hank: { firstName: \u0026#34;Hank\u0026#34; nickName: \u0026#34;Hank\u0026#34; } Closed structs By default, structs are open to adding fields. Instances of an open struct p may contain fields not defined in p. This is makes it easy to add fields, but can lead to bugs: Copy code Copied! S: { field1: string } S1: S \u0026amp; { field2: \u0026#34;foo\u0026#34; } // S1 is { field1: string, field2: \u0026#34;foo\u0026#34; } A: { field1: string field2: string } A1: A \u0026amp; { feild1: \u0026#34;foo\u0026#34; // \u0026#34;field1\u0026#34; was accidentally misspelled } // A1 is // { field1: string, field2: string, feild1: \u0026#34;foo\u0026#34; } // not the intended // { field1: \u0026#34;foo\u0026#34;, field2: string } A closed struct c is a struct whose instances may not declare any field with a name that does not match the name of a field or the pattern of a pattern constraint defined in c. Hidden fields are",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_7",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "excluded from this limitation. A struct that is the result of unifying any struct with a ... declaration is defined for all regular fields. Closing a struct is equivalent to adding ..._|_ to it. Syntactically, structs are closed explicitly with the close builtin or implicitly and recursively by definitions. Copy code Copied! A: close({ field1: string field2: string }) A1: A \u0026amp; { feild1: string } // _|_ feild1 not defined for A A2: A \u0026amp; { for k,v in { feild1: string } { k: v } } // _|_ feild1 not defined for A C: close({ [_]: _ }) C2: C \u0026amp; { for k,v in { thisIsFine: string } { \u0026#34;\\(k)\u0026#34;: v } } D: close({ // Values generated by comprehensions are treated as embeddings. for k,v in { x: string } { \u0026#34;\\(k)\u0026#34;: v } }) Embedding A struct may contain an embedded value, an operand used as a declaration. An embedded value of type struct is unified with the struct in which it is embedded, but disregarding the restrictions imposed by closed structs. So if an embedding resolves to a closed struct, the corresponding enclosing struct will also be closed, but may have fields that are not allowed if normal rules for closed structs were observed. If an embedded value is not of type struct, the struct may only have definitions or hidden fields. Regular fields are not allowed in such case. The result of { A } is A for any A (including definitions). Syntactically, embeddings may be any expression. Copy code Copied! S1: { a: 1 b: 2 { c: 3 } } // S1 is { a: 1, b: 2, c: 3 } S2: close({ a: 1 b: 2 { c: 3 } }) // same as close(S1) S3: { a: 1 b: 2 close({ c: 3 }) } // same as S2 Definitions and hidden fields A field is a definition if its identifier starts with # or _#. A field is hidden if its identifier starts with a _. All other fields are regular. Definitions and hidden fields are not emitted when converting a CUE program to data and are never required to be concrete. Referencing a definition will recursively close it. That is, a referenced definition will not unify with a struct that would add a field anywhere within the definition that it does not already define or explicitly allow with a pattern constraint or .... Embedding allows bypassing this check. If referencing a definition would always result in an error, implementations may report this inconsistency at the point of its declaration. Copy code Copied! #MyStruct: { sub: field: string } #MyStruct: { sub: enabled?: bool } myValue: #MyStruct \u0026amp; { sub: feild: 2 // error, feild not defined in #MyStruct sub: enabled: true // okay } #D: { #OneOf c: int // adds this field. } #OneOf: { a: int } | { b: int } D1: #D \u0026amp; { a: 12, c: 22 } // { a: 12, c: 22 } D2: #D \u0026amp; { a: 12, b: 33 } // _|_ // cannot define both `a` and `b` Copy code Copied! #A: {a: int} B: { #A b: c: int } x: B x: d: 3 // not allowed, as closed by embedded #A y: B.b y: d: 3 // allowed as nothing closes b #B: { #A b: c: int } z: #B.b z: d: 3 // not allowed, as referencing #B closes b Attributes Attributes allow associating meta information with values. Their primary purpose is to define mappings between CUE and other representations. Attributes do not influence the evaluation of CUE. An attribute associates an identifier with a value, a balanced token sequence, which is a sequence of CUE tokens with balanced brackets ((), [], and {}). The sequence may not contain interpolations. Fields, structs and packages can be associated with a set of attributes. Attributes accumulate during unification, but implementations may remove duplicates that have the same source string representation. The interpretation of an attribute, including the handling of multiple attributes for a given identifier, is up to the consumer of the attribute. Field attributes define additional information about a field, such as a mapping to a protocol buffer tag or alternative name of the field when mapping to a different language. Copy code Copied! // Package attribute @protobuf(proto3) myStruct1: { // Struct attribute: @jsonschema(id=\u0026#34;https://example.org/mystruct1.json\u0026#34;) // Field attributes field: string @go(Field) attr: int @xml(,attr) @go(Attr) } myStruct2: { field: string @go(Field) attr: int @xml(a1,attr) @go(Attr) } Combined: myStruct1 \u0026amp; myStruct2 // field: string @go(Field) // attr: int @xml(,attr) @xml(a1,attr) @go(Attr) Aliases Aliases name values that can be referred to within the scope in which they are declared. The name of an alias must be unique within its scope. Copy code Copied! AliasExpr = [ identifier \u0026#34;=\u0026#34; ] Expression . Aliases can appear in several positions: In front of a Label (X=label: value): binds the identifier to the same value as label would be bound to if it were a valid identifier. In front of a dynamic field (X=(label): value): binds the identifier to the same value as label if it were a valid static identifier. In front of a dynamic field expression ((X=expr): value): binds the identifier to the concrete label resulting from evaluating expr. In front of a pattern constraint (X=[expr]: value): binds the identifier to the same field as the matched by the pattern within the instance of the field value (value). In front of a pattern constraint expression ([X=expr]: value): binds the identifier to the concrete label that matches expr within the instances of the field value (value). Before a value (foo: X=x) binds the identifier to the value it precedes within the scope of that value. Before a list element ([ X=value, X+1 ]) (Not yet implemented) binds the identifier to the list element it precedes within the scope of the list expression. Copy code Copied! // A field alias foo: X // 4 X=\u0026#34;not an identifier\u0026#34;: 4 //",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_8",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "A value alias foo: X={x: X.a} bar: foo \u0026amp; {a: 1} // {a: 1, x: 1} // A label alias [Y=string]: { name: Y } foo: { value: 1 } // outputs: foo: { name: \u0026#34;foo\u0026#34;, value: 1 } Let declarations Let declarations bind an identifier to an expression. The identifier is only visible within the scope in which it is declared. The identifier must be unique within its scope. Copy code Copied! let x = expr a: x + 1 b: x + 2 Shorthand notation for nested structs A field whose value is a struct with a single field may be written as a colon-separated sequence of the two field names, followed by a colon and the value of that single field. Copy code Copied! job: myTask: replicas: 2 expands to Copy code Copied! job: { myTask: { replicas: 2 } } Lists A list literal defines a new value of type list. A list may be open or closed. An open list is indicated with a ... at the end of an element list, optionally followed by a value for the remaining elements. The length of a closed list is the number of elements it contains. The length of an open list is the number of elements as a lower bound and an unlimited number of elements as its upper bound. Copy code Copied! ListLit = \u0026#34;[\u0026#34; [ ElementList [ \u0026#34;,\u0026#34; ] ] \u0026#34;]\u0026#34; . ElementList = Ellipsis | Embedding { \u0026#34;,\u0026#34; Embedding } [ \u0026#34;,\u0026#34; Ellipsis ] . Lists can be thought of as structs: Copy code Copied! List: *null | { Elem: _ Tail: List } For closed lists, Tail is null for the last element, for open lists it is *null | List, defaulting to the shortest variant. For instance, the open list [ 1, 2, \u0026hellip; ] can be represented as: Copy code Copied! open: List \u0026amp; { Elem: 1, Tail: { Elem: 2 } } and the closed version of this list, [ 1, 2 ], as Copy code Copied! closed: List \u0026amp; { Elem: 1, Tail: { Elem: 2, Tail: null } } Using this representation, the subsumption rule for lists can be derived from those of structs. Implementations are not required to implement lists as structs. The Elem and Tail fields are not special and len will not work as expected in these cases. Declarations and Scopes Blocks A block is a possibly empty sequence of declarations. The braces of a struct literal { ... } form a block, but there are others as well: The universe block encompasses all CUE source text. Each package has a package block containing all CUE source text in that package. Each file has a file block containing all CUE source text in that file. Each for and let clause in a comprehension is considered to be its own implicit block. Blocks nest and influence scoping. Declarations and scope A declaration may bind an identifier to a field, alias, or package. Every identifier in a program must be declared. Other than for fields, no identifier may be declared twice within the same block. For fields, an identifier may be declared more than once within the same block, resulting in a field with a value that is the result of unifying the values of all fields with the same identifier. String labels do not bind an identifier to the respective field. The scope of a declared identifier is the extent of source text in which the identifier denotes the specified field, alias, or package. CUE is lexically scoped using blocks: The scope of a predeclared identifier is the universe block. The scope of an identifier denoting a field declared at top level (outside any struct literal) is the package block. The scope of an identifier denoting an alias declared at top level (outside any struct literal) is the file block. The scope of a let identifier declared at top level (outside any struct literal) is the file block. The scope of the package name of an imported package is the file block of the file containing the import declaration. The scope of a field, alias or let identifier declared inside a struct literal is the innermost containing block. An identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration. The package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default name for import declarations. Predeclared identifiers CUE predefines a set of types and builtin functions. For each of these there is a corresponding keyword which is the name of the predefined identifier, prefixed with __. Copy code Copied! Functions len close and or Types null The null type and value bool All boolean values int All integral numbers float All decimal floating-point numbers string Any valid UTF-8 sequence bytes Any valid byte sequence Derived Value number int | float uint \u0026gt;=0 uint8 \u0026gt;=0 \u0026amp; \u0026lt;=255 int8 \u0026gt;=-128 \u0026amp; \u0026lt;=127 uint16 \u0026gt;=0 \u0026amp; \u0026lt;=65535 int16 \u0026gt;=-32_768 \u0026amp; \u0026lt;=32_767 rune \u0026gt;=0 \u0026amp; \u0026lt;=0x10FFFF uint32 \u0026gt;=0 \u0026amp; \u0026lt;=4_294_967_295 int32 \u0026gt;=-2_147_483_648 \u0026amp; \u0026lt;=2_147_483_647 uint64 \u0026gt;=0 \u0026amp; \u0026lt;=18_446_744_073_709_551_615 int64 \u0026gt;=-9_223_372_036_854_775_808 \u0026amp; \u0026lt;=9_223_372_036_854_775_807 uint128 \u0026gt;=0 \u0026amp; \u0026lt;=340_282_366_920_938_463_463_374_607_431_768_211_455 int128 \u0026gt;=-170_141_183_460_469_231_731_687_303_715_884_105_728 \u0026amp; \u0026lt;=170_141_183_460_469_231_731_687_303_715_884_105_727 float32 \u0026gt;=-3.40282346638528859811704183484516925440e+38 \u0026amp; \u0026lt;=3.40282346638528859811704183484516925440e+38 float64 \u0026gt;=-1.797693134862315708145274237317043567981e+308 \u0026amp; \u0026lt;=1.797693134862315708145274237317043567981e+308 Exported identifiers An identifier of a package may be exported to permit access to it from another package. All identifiers not starting with _ (so all regular fields and definitions starting with #) are exported. Any identifier starting with _ is not visible outside the package and resides in a separate namespace than namesake identifiers of other packages. Copy code Copied! package mypackage foo: string // visible outside mypackage \u0026#34;bar\u0026#34;: string // visible outside mypackage #Foo: { // visible outside mypackage a: 1 // visible outside mypackage _b: 2 // not visible outside mypackage #C: { // visible outside",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_9",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "mypackage d: 4 // visible outside mypackage } _#E: foo // not visible outside mypackage } Uniqueness of identifiers Given a set of identifiers, an identifier is called unique if it is different from every other in the set, after applying normalization following Unicode Annex #31. Two identifiers are different if they are spelled differently or if they appear in different packages and are not exported. Otherwise, they are the same. Field declarations A field associates the value of an expression to a label within a struct. If this label is an identifier, it binds the field to that identifier, so the field\u0026rsquo;s value can be referenced by writing the identifier. String labels are not bound to fields. Copy code Copied! a: { b: 2 \u0026#34;s\u0026#34;: 3 c: b // 2 d: s // _|_ unresolved identifier \u0026#34;s\u0026#34; e: a.s // 3 } If an expression may result in a value associated with a default value as described in default values, the field binds to this value-default pair. Let declarations Within a struct, a let clause binds an identifier to the given expression. Within the scope of the identifier, the identifier refers to the locally declared expression. The expression is evaluated in the scope it was declared. Expressions An expression specifies the computation of a value by applying operators and builtin functions to operands. Expressions that require concrete values are called incomplete if any of their operands are not concrete, but define a value that would be legal for that expression. Incomplete expressions may be left unevaluated until a concrete value is requested at the application level. Operands Operands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) identifier denoting a field, alias, or let declaration, or a parenthesized expression. Copy code Copied! Operand = Literal | OperandName | \u0026#34;(\u0026#34; Expression \u0026#34;)\u0026#34; . Literal = BasicLit | ListLit | StructLit . BasicLit = int_lit | float_lit | string_lit | null_lit | bool_lit | bottom_lit . OperandName = identifier | QualifiedIdent . Qualified identifiers A qualified identifier is an identifier qualified with a package name prefix. Copy code Copied! QualifiedIdent = PackageName \u0026#34;.\u0026#34; identifier . A qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be declared in the package block of that package. Copy code Copied! math.Sin // denotes the Sin function in package math References An identifier operand refers to a field and is called a reference. The value of a reference is a copy of the expression associated with the field that it is bound to, with any references within that expression bound to the respective copies of the fields they were originally bound to. Implementations may use a different mechanism to evaluate as long as these semantics are maintained. Copy code Copied! a: { place: string greeting: \u0026#34;Hello, \\(place)!\u0026#34; } b: a \u0026amp; { place: \u0026#34;world\u0026#34; } c: a \u0026amp; { place: \u0026#34;you\u0026#34; } d: b.greeting // \u0026#34;Hello, world!\u0026#34; e: c.greeting // \u0026#34;Hello, you!\u0026#34; Primary expressions Primary expressions are the operands for unary and binary expressions. Copy code Copied! PrimaryExpr = Operand | PrimaryExpr Selector | PrimaryExpr Index | PrimaryExpr Arguments . Selector = \u0026#34;.\u0026#34; (identifier | simple_string_lit) . Index = \u0026#34;[\u0026#34; Expression \u0026#34;]\u0026#34; . Argument = Expression . Arguments = \u0026#34;(\u0026#34; [ ( Argument { \u0026#34;,\u0026#34; Argument } ) [ \u0026#34;,\u0026#34; ] ] \u0026#34;)\u0026#34; . Copy code Copied! x 2 (s + \u0026#34;.txt\u0026#34;) f(3.1415, true) m[\u0026#34;foo\u0026#34;] obj.color f.p[i].x Selectors For a primary expression x that is not a package name, the selector expression Copy code Copied! x.f denotes the element of a struct x identified by f. f must be an identifier or a string literal identifying any definition or regular non-optional field. The identifier f is called the field selector. If x is a package name, see the section on qualified identifiers. Otherwise, if x is not a struct, or if f does not exist in x, the result of the expression is bottom (an error). In the latter case the expression is incomplete. The operand of a selector may be associated with a default. Copy code Copied! T: { x: int y: 3 \u0026#34;x-y\u0026#34;: 4 } a: T.x // int b: T.y // 3 c: T.z // _|_ // field \u0026#39;z\u0026#39; not found in T d: T.\u0026#34;x-y\u0026#34; // 4 e: {a: 1|*2} | *{a: 3|*4} f: e.a // 4 (default value) Index expressions A primary expression of the form Copy code Copied! a[x] denotes the element of a list or struct a indexed by x. The value x is called the index or field name, respectively. The following rules apply: If a is not a struct: a is a list (which need not be complete) the index x unified with int must be concrete. the index x is in range if 0 \u0026lt;= x \u0026lt; len(a), where only the explicitly defined values of an open-ended list are considered, otherwise it is out of range The result of a[x] is for a of list type: the list element at index x, if x is within range bottom (an error), otherwise for a of struct type: the index x unified with string must be concrete. the value of the regular and non-optional field named x of struct a, if this field exists bottom (an error), otherwise Copy code Copied! a: [ 1, 2 ][1] // 2 b: [ 1, 2 ][2] // _|_ c: [ 1, 2, ...][2] // _|_ // Defaults are selected for both operand and index: x: [1, 2] | *[3, 4] y: int | *1 z: x[y] // 4 Operators Operators combine operands into expressions. Copy code Copied! Expression = UnaryExpr | Expression binary_op Expression . UnaryExpr = PrimaryExpr | unary_op UnaryExpr . binary_op = \u0026#34;|\u0026#34; | \u0026#34;\u0026amp;\u0026#34; | \u0026#34;||\u0026#34; | \u0026#34;\u0026amp;\u0026amp;\u0026#34; | \u0026#34;==\u0026#34; | rel_op | add_op | mul_op . rel_op = \u0026#34;!=\u0026#34; | \u0026#34;\u0026lt;\u0026#34; | \u0026#34;\u0026lt;=\u0026#34; | \u0026#34;\u0026gt;\u0026#34; | \u0026#34;\u0026gt;=\u0026#34; | \u0026#34;=~\u0026#34; | \u0026#34;!~\u0026#34; . add_op = \u0026#34;+\u0026#34; | \u0026#34;-\u0026#34; . mul_op = \u0026#34;*\u0026#34; | \u0026#34;/\u0026#34;",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_10",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": ". unary_op = \u0026#34;+\u0026#34; | \u0026#34;-\u0026#34; | \u0026#34;!\u0026#34; | \u0026#34;*\u0026#34; | rel_op . Comparisons are discussed elsewhere. For any binary operators, the operand types must unify. Operator precedence Unary operators have the highest precedence. There are eight precedence levels for binary operators. Multiplication operators binds strongest, followed by addition operators, comparison operators, \u0026amp;\u0026amp; (logical AND), || (logical OR), \u0026amp; (unification), and finally | (disjunction): Copy code Copied! Precedence Operator 7 * / 6 + - 5 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= =~ !~ 4 \u0026amp;\u0026amp; 3 || 2 \u0026amp; 1 | Binary operators of the same precedence associate from left to right. For instance, x / y * z is the same as (x / y) * z. Copy code Copied! +x 23 + 3*x[i] x \u0026lt;= f() f() || g() x == y+1 \u0026amp;\u0026amp; y == z-1 2 | int { a: 1 } \u0026amp; { b: 2 } Arithmetic operators Arithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators (+, -, *, /) apply to integer and decimal floating-point types; + and * also apply to strings and bytes. Copy code Copied! + sum integers, floats, strings, bytes - difference integers, floats * product integers, floats, strings, bytes / quotient integers, floats For any operator that accepts operands of type float, any operand may be of type int or float, in which case the result will be float if it cannot be represented as an int or if any of the operands are float, or int otherwise. So the result of 1 / 2 is 0.5 and is of type float. The result of division by zero is bottom (an error). Integer division is implemented through the builtin functions quo, rem, div, and mod. The unary operators + and - are defined for numeric values as follows: Copy code Copied! +x is 0 + x -x negation is 0 - x String operators Strings can be concatenated using the + operator: Copy code Copied! s: \u0026#34;hi \u0026#34; + name + \u0026#34; and good bye\u0026#34; String addition creates a new string by concatenating the operands. A string can be repeated by multiplying it: Copy code Copied! s: \u0026#34;etc. \u0026#34;*3 // \u0026#34;etc. etc. etc. \u0026#34; Comparison operators Comparison operators compare two operands and yield an untyped boolean value. Copy code Copied! == equal != not equal \u0026lt; less \u0026lt;= less or equal \u0026gt; greater \u0026gt;= greater or equal =~ matches regular expression !~ does not match regular expression In any comparison, the types of the two operands must unify or one of the operands must be null. The equality operators == and != apply to operands that are comparable. The ordering operators \u0026lt;, \u0026lt;=, \u0026gt;, and \u0026gt;= apply to operands that are ordered. The matching operators =~ and !~ apply to a string and a regular expression operand. These terms and the result of the comparisons are defined as follows: Null is comparable with itself and any other type. Two null values are always equal, null is unequal with anything else. Boolean values are comparable. Two boolean values are equal if they are either both true or both false. Integer values are comparable and ordered, in the usual way. Floating-point values are comparable and ordered, as per the definitions for binary coded decimals in the IEEE-754-2008 standard. Floating point numbers may be compared with integers. String and bytes values are comparable and ordered lexically byte-wise. Struct are not comparable. Lists are not comparable. The regular expression syntax is the one accepted by RE2, described in https://github.com/google/re2/wiki/Syntax, except for \\C. s =~ r is true if s matches the regular expression r. s !~ r is true if s does not match regular expression r. Copy code Copied! 3 \u0026lt; 4 // true 3 \u0026lt; 4.0 // true null == 2 // false null != {} // true {} == {} // _|_: structs are not comparable against structs \u0026#34;Wild cats\u0026#34; =~ \u0026#34;cat\u0026#34; // true \u0026#34;Wild cats\u0026#34; !~ \u0026#34;dog\u0026#34; // true \u0026#34;foo\u0026#34; =~ \u0026#34;^[a-z]{3}$\u0026#34; // true \u0026#34;foo\u0026#34; =~ \u0026#34;^[a-z]{4}$\u0026#34; // false Logical operators Logical operators apply to boolean values and yield a result of the same type as the operands. The right operand is evaluated conditionally. Copy code Copied! \u0026amp;\u0026amp; conditional AND p \u0026amp;\u0026amp; q is \u0026#34;if p then q else false\u0026#34; || conditional OR p || q is \u0026#34;if p then true else q\u0026#34; ! NOT !p is \u0026#34;not p\u0026#34; Calls Calls can be made to core library functions, called builtins. Given an expression f of function type F, Copy code Copied! f(a1, a2,  an) calls f with arguments a1, a2,  an. Arguments must be expressions of which the values are an instance of the parameter types of F and are evaluated before the function is called. Copy code Copied! a: math.Atan2(x, y) In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution. The return parameters of the function are passed by value back to the calling function when the function returns. Comprehensions Lists and fields can be constructed using comprehensions. Comprehensions define a clause sequence that consists of a sequence of for, if, and let clauses, nesting from left to right. The sequence must start with a for or if clause. The for and let clauses each define a new scope in which new values are bound to be available for the next clause. The for clause binds the defined identifiers, on each iteration, to the next value of some iterable value in a new scope. A for clause may bind one or two identifiers. If there is one identifier, it binds it to the value of a list element or struct field value. If there are two identifiers, the first value will be the key or index, if available, and the second will be",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_11",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "the value. For lists, for iterates over all elements in the list after closing it. For structs, for iterates over all non-optional regular fields. An if clause, or guard, specifies an expression that terminates the current iteration if it evaluates to false. The let clause binds the result of an expression to the defined identifier in a new scope. A current iteration is said to complete if the innermost block of the clause sequence is reached. Syntactically, the comprehension value is a struct. A comprehension can generate non-struct values by embedding such values within this struct. Within lists, the values yielded by a comprehension are inserted in the list at the position of the comprehension. Within structs, the values yielded by a comprehension are embedded within the struct. Both structs and lists may contain multiple comprehensions. Copy code Copied! Comprehension = Clauses StructLit . Clauses = StartClause { [ \u0026#34;,\u0026#34; ] Clause } . StartClause = ForClause | GuardClause . Clause = StartClause | LetClause . ForClause = \u0026#34;for\u0026#34; identifier [ \u0026#34;,\u0026#34; identifier ] \u0026#34;in\u0026#34; Expression . GuardClause = \u0026#34;if\u0026#34; Expression . LetClause = \u0026#34;let\u0026#34; identifier \u0026#34;=\u0026#34; Expression . Copy code Copied! a: [1, 2, 3, 4] b: [for x in a if x \u0026gt; 1 { x+1 }] // [3, 4, 5] c: { for x in a if x \u0026lt; 4 let y = 1 { \u0026#34;\\(x)\u0026#34;: x + y } } d: { \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3, \u0026#34;3\u0026#34;: 4 } String interpolation String interpolation allows constructing strings by replacing placeholder expressions with their string representation. String interpolation may be used in single- and double-quoted strings, as well as their multiline equivalent. A placeholder consists of \\( followed by an expression and ). The expression is evaluated in the scope within which the string is defined. The result of the expression is substituted as follows: string: as is bool: the JSON representation of the bool number: a JSON representation of the number that preserves the precision of the underlying binary coded decimal bytes: as if substituted within single quotes or converted to valid UTF-8 replacing the maximal subpart of ill-formed subsequences with a single replacement character (W3C encoding standard) otherwise list: illegal struct: illegal Copy code Copied! a: \u0026#34;World\u0026#34; b: \u0026#34;Hello \\( a )!\u0026#34; // Hello World! Builtin Functions Builtin functions are predeclared. They are called like any other function. len The builtin function len takes arguments of various types and returns a result of type int. Copy code Copied! Argument type Result bytes length of byte sequence list list length, smallest length for an open list struct number of distinct data fields, excluding field constraints Copy code Copied! Expression Result len(\u0026#34;Hell\u0026#34;) 6 len([1, 2, 3]) 3 len([1, 2, ...]) 2 close The builtin function close converts a partially defined, or open, struct to a fully defined, or closed, struct. and The builtin function and takes a list and returns the result of applying the \u0026amp; operator to all elements in the list. It returns top for the empty list. Copy code Copied! Expression: Result and([a, b]) a \u0026amp; b and([a]) a and([]) _ or The builtin function or takes a list and returns the result of applying the | operator to all elements in the list. It returns bottom for the empty list. Copy code Copied! Expression: Result or([a, b]) a | b or([a]) a or([]) _|_ div, mod, quo and rem For two integer values x and y, the integer quotient q = div(x, y) and remainder r = mod(x, y) implement Euclidean division and satisfy the following relationship: Copy code Copied! r = x - y*q with 0 \u0026lt;= r \u0026lt; |y| where |y| denotes the absolute value of y. Copy code Copied! x y div(x, y) mod(x, y) 5 3 1 2 -5 3 -2 1 5 -3 -1 2 -5 -3 2 1 For two integer values x and y, the integer quotient q = quo(x, y) and remainder r = rem(x, y) implement truncated division and satisfy the following relationship: Copy code Copied! x = q*y + r and |r| \u0026lt; |y| with quo(x, y) truncated towards zero. Copy code Copied! x y quo(x, y) rem(x, y) 5 3 1 2 -5 3 -1 -2 5 -3 -1 2 -5 -3 1 -2 A zero divisor in either case results in bottom (an error). Cycles Implementations are required to interpret or reject cycles encountered during evaluation according to the rules in this section. Reference cycles A reference cycle occurs if a field references itself, either directly or indirectly. Copy code Copied! // x references itself x: x // indirect cycles b: c c: d d: b Implementations should treat these as _. Two particular cases are discussed below. Expressions that unify an atom with an expression An expression of the form a \u0026amp; e, where a is an atom and e is an expression, always evaluates to a or bottom. As it does not matter how we fail, we can assume the result to be a and postpone validating a == e until after all references in e have been resolved. Copy code Copied! // Config Evaluates to (requiring concrete values) x: { x: { a: b + 100 a: _|_ // cycle detected b: a - 100 b: _|_ // cycle detected } } y: x \u0026amp; { y: { a: 200 a: 200 // asserted that 200 == b + 100 b: 100 } } Field values A field value of the form r \u0026amp; v, where r evaluates to a reference cycle and v is a concrete value, evaluates to v. Unification is idempotent and unifying a value with itself ad infinitum, which is what the cycle represents, results in this value. Implementations should detect cycles of this kind, ignore r, and take v as the result of unification. Copy code Copied! Configuration Evaluated // c Cycles in nodes of type struct evaluate //   to the fixed point of unifying their // a  b values ad",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_12",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "infinitum. a: b \u0026amp; { x: 1 } // a: { x: 1, y: 2, z: 3 } b: c \u0026amp; { y: 2 } // b: { x: 1, y: 2, z: 3 } c: a \u0026amp; { z: 3 } // c: { x: 1, y: 2, z: 3 } // resolve a b \u0026amp; {x:1} // substitute b c \u0026amp; {y:2} \u0026amp; {x:1} // substitute c a \u0026amp; {z:3} \u0026amp; {y:2} \u0026amp; {x:1} // eliminate a (cycle) {z:3} \u0026amp; {y:2} \u0026amp; {x:1} // simplify {x:1,y:2,z:3} This rule also applies to field values that are disjunctions of unification operations of the above form. Copy code Copied! a: b\u0026amp;{x:1} | {y:1} // {x:1,y:3,z:2} | {y:1} b: {x:2} | c\u0026amp;{z:2} // {x:2} | {x:1,y:3,z:2} c: a\u0026amp;{y:3} | {z:3} // {x:1,y:3,z:2} | {z:3} // resolving a b\u0026amp;{x:1} | {y:1} // substitute b ({x:2} | c\u0026amp;{z:2})\u0026amp;{x:1} | {y:1} // simplify c\u0026amp;{z:2}\u0026amp;{x:1} | {y:1} // substitute c (a\u0026amp;{y:3} | {z:3})\u0026amp;{z:2}\u0026amp;{x:1} | {y:1} // simplify a\u0026amp;{y:3}\u0026amp;{z:2}\u0026amp;{x:1} | {y:1} // eliminate a (cycle) {y:3}\u0026amp;{z:2}\u0026amp;{x:1} | {y:1} // expand {x:1,y:3,z:2} | {y:1} Note that all nodes that form a reference cycle to form a struct will evaluate to the same value. If a field value is a disjunction, any element that is part of a cycle will evaluate to this value. Structural cycles A structural cycle is when a node references one of its ancestor nodes. It is possible to construct a structural cycle by unifying two acyclic values: Copy code Copied! // acyclic y: { f: h: g g: _ } // acyclic x: { f: _ g: f } // introduces structural cycle z: x \u0026amp; y Implementations should be able to detect such structural cycles dynamically. A structural cycle can result in infinite structure or evaluation loops. Copy code Copied! // infinite structure a: b: a // infinite evaluation f: { n: int out: n + (f \u0026amp; {n: 1}).out } CUE must allow or disallow structural cycles under certain circumstances. If a node a references an ancestor node, we call it and any of its field values a.f cyclic. So if a is cyclic, all of its descendants are also regarded as cyclic. A given node x, whose value is composed of the conjuncts c1 \u0026amp; ... \u0026amp; cn, is valid if any of its conjuncts is not cyclic. Copy code Copied! // Disallowed: a list of infinite length with all elements being 1. #List: { head: 1 tail: #List } // Disallowed: another infinite structure (a:{b:{d:{b:{d:{...}}}}}, ...). a: { b: c } c: { d: a } // #List defines a list of arbitrary length. Because the recursive reference // is part of a disjunction, this does not result in a structural cycle. #List: { head: _ tail: null | #List } // Usage of #List. The value of tail in the most deeply nested element will // be `null`: as the value of the disjunct referring to list is the only // conjunct, all conjuncts are cyclic and the value is invalid and so // eliminated from the disjunction. MyList: #List \u0026amp; { head: 1, tail: { head: 2 }} Modules, instances, and packages CUE configurations are constructed combining instances. An instance, in turn, is constructed from one or more source files belonging to the same package that together declare the data representation. Elements of this data representation may be exported and used in other instances. Source file organization Each source file consists of an optional package clause defining collection of files to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations. Like with a struct, a source file may contain embeddings. Unlike with a struct, the embedded expressions may be any value. If the result of the unification of all embedded values is not a struct, it will be output instead of its enclosing file when exporting CUE to a data format Copy code Copied! SourceFile = { attribute \u0026#34;,\u0026#34; } [ PackageClause \u0026#34;,\u0026#34; ] { ImportDecl \u0026#34;,\u0026#34; } { Declaration \u0026#34;,\u0026#34; } . Copy code Copied! \u0026#34;Hello \\(#place)!\u0026#34; #place: \u0026#34;world\u0026#34; // Outputs \u0026#34;Hello world!\u0026#34; Package clause A package clause is an optional clause that defines the package to which a source file the file belongs. Copy code Copied! PackageClause = \u0026#34;package\u0026#34; PackageName . PackageName = identifier . The PackageName must not be a definition identifier. If the PackageName is the blank identifier (_), it is treated the same as if there were no package clause. This can be useful to allow adding package level attributes or doc comments to a CUE file without a package name. Copy code Copied! package math Modules and instances A module defines a tree of directories, rooted at the module root. All source files within a module with the same package name belong to the same package. A module may define multiple packages. An instance of a package is any subset of files belonging to the same package. It is interpreted as the concatenation of these files. An implementation may impose conventions on the layout of package files to determine which files of a package belongs to an instance. For example, an instance may be defined as the subset of package files belonging to a directory and all its ancestors. Import declarations An import declaration states that the source file containing the declaration depends on definitions of the imported package and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported. Copy code Copied! ImportDecl = \u0026#34;import\u0026#34; ( ImportSpec | \u0026#34;(\u0026#34; { ImportSpec \u0026#34;,\u0026#34; } \u0026#34;)\u0026#34; ) . ImportSpec = [ PackageName ] ImportPath . ImportLocation = { unicode_value } . ImportPath = `\u0026#34;` ImportLocation [ \u0026#34;:\u0026#34; identifier ] `\u0026#34;` . The PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "86c5fcc58c0d8acf56f83eaf7bdffb19_13",
        "title": "The CUE Language Specification",
        "link": "/docs/reference/spec/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Note to implementors Notes on the formalism underlying this specification can be found here.\nIntroduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.",
        "content": "the file block. It defaults to the identifier specified in the package clause of the imported package, which must match either the last path component of ImportLocation or the identifier following it. The interpretation of the ImportPath is implementation-dependent but it is typically either the path of a builtin package or a fully qualifying location of a package within a source code repository. An ImportLocation must be a non-empty string using only characters belonging to Unicode\u0026rsquo;s L, M, N, P, and S general categories (the Graphic characters without spaces) and may not include the characters !\u0026quot;#$%\u0026amp;'()*,:;\u0026lt;=\u0026gt;?[\\\\]^`{|} or the Unicode replacement character U+FFFD. Assume we have package containing the package clause package math, which exports function Sin at the path identified by lib/math. This table illustrates how Sin is accessed in files that import the package after the various types of import declaration. Copy code Copied! Import declaration Local name of Sin import \u0026#34;lib/math\u0026#34; math.Sin import \u0026#34;lib/math:math\u0026#34; math.Sin import m \u0026#34;lib/math\u0026#34; m.Sin An import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. An example package TODO",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ["mpvl"]
    },
    
            {
        "objectID": "6ca27d363941661b5593181bf7a561c7_1",
        "title": "Type Hierarchy",
        "link": "/docs/tour/types/types/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE defines the following type hierarchy:\u003c/p\u003e\n\n\u003cfigure class=\"diagram\"\u003e\n    \u003cdiv class=\"diagram__content mermaid\"\u003e\nflowchart TD\n\ntop[\"_\"]\nbottom[\"_|_\"]\nstruct[\"{...}\"]\nlist[\"[...]\"]\n\ntop --\u003e null --\u003e bottom\ntop --\u003e bool --\u003e bottom\ntop --\u003e string --\u003e bottom\ntop --\u003e bytes --\u003e bottom\ntop --\u003e number --\u003e int \u0026 float --\u003e bottom\ntop --\u003e struct --\u003e bottom\ntop --\u003e list --\u003e bottom\n\u003c/div\u003e\u003cfigcaption class=\"diagram__caption\"\u003eCUE\u0026#39;s predefined type hierarchy\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\u003cp\u003eCUE defines the value \u003cstrong\u003etop\u003c/strong\u003e (or any),\nwritten \u0026ldquo;\u003ccode\u003e_\u003c/code\u003e\u0026rdquo;, \u003c!-- ` vim syntax highlighting hack --\u003e\nsuch that all types are an instance of top,\nand the value \u003cstrong\u003ebottom\u003c/strong\u003e (or error),\nwritten \u0026ldquo;\u003ccode\u003e_|_\u003c/code\u003e\u0026rdquo;,\nwhich is an instance of all types.\u003c/p\u003e\n\u003cp\u003eWe can mix the terms types and values interchangeably because\nCUE doesn\u0026rsquo;t distinguish between\n\u003ca href=\"/docs/tour/basics/types-are-values/\"\u003etypes and values\u003c/a\u003e.\u003cbr\u003e\nThe term \u0026ldquo;type\u0026rdquo; merely refers to the \u003cem\u003ekind\u003c/em\u003e of a value,\nwhich may or may not be a concrete instance.\u003c/p\u003e",
        "content": "CUE defines the following type hierarchy: flowchart TD top[\"_\"] bottom[\"_|_\"] struct[\"{...}\"] list[\"[...]\"] top --\u003e null --\u003e bottom top --\u003e bool --\u003e bottom top --\u003e string --\u003e bottom top --\u003e bytes --\u003e bottom top --\u003e number --\u003e int \u0026 float --\u003e bottom top --\u003e struct --\u003e bottom top --\u003e list --\u003e bottom CUE\u0026#39;s predefined type hierarchy CUE defines the value top (or any), written \u0026ldquo;_\u0026rdquo;, such that all types are an instance of top, and the value bottom (or error), written \u0026ldquo;_|_\u0026rdquo;, which is an instance of all types. We can mix the terms types and values interchangeably because CUE doesn\u0026rsquo;t distinguish between types and values. The term \u0026ldquo;type\u0026rdquo; merely refers to the kind of a value, which may or may not be a concrete instance. In the following hypothetical example, point defines an arbitrary point, while xaxis and yaxis define any point on their respective axes. We say that point, xaxis, and yaxis are incomplete, as they don\u0026rsquo;t contain values that specify a specific point. Incomplete values cannot be included when exporting to formats that can\u0026rsquo;t represent them. JSON and YAML, for example, have no way to represent the type number. Copied! file.cue Copy code Copied! point: { x: number y: number } xaxis: point xaxis: y: 0 yaxis: point yaxis: x: 0 origin: xaxis \u0026amp; yaxis TERMINAL Copy code Copied! $ cue eval file.cue point: { x: number y: number } xaxis: { x: number y: 0 } yaxis: { x: 0 y: number } origin: { x: 0 y: 0 } By contrast, origin is not incomplete, as it contains only concrete values. However, notice that we didn\u0026rsquo;t need to specify its values explicitly. CUE is able to infer from the constraints applied, placing origin on both the x-axis and y-axis, that its coordinates must be (x = 0, y = 0). The output in this example is produced by cue eval. This command validates a configuration but, unlike cue export, doesn\u0026rsquo;t require it to be completely concrete. cue eval produces CUE, not JSON or YAML.",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a1a1945e9e1facc5be3f1cef85415109_1",
        "title": "Tour",
        "link": "/docs/tour/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " New to CUE? Begin the tour with an introduction to the most important language features The Basics of CUE The Basics of CUE Types and Values CUE merges the concepts of types and values, enabling clear and concise constraints References \u0026amp; Visibility A CUE value can be derived from other values, using easy-to-understand references Expressions CUE provides a rich set of mechanisms to construct, validate, and process data Packages and Imports Configurations can be separated so they\u0026rsquo;re easier to manage and reason about ",
        "content": "New to CUE? Begin the tour with an introduction to the most important language features The Basics of CUE The Basics of CUE Types and Values CUE merges the concepts of types and values, enabling clear and concise constraints References \u0026amp; Visibility A CUE value can be derived from other values, using easy-to-understand references Expressions CUE provides a rich set of mechanisms to construct, validate, and process data Packages and Imports Configurations can be separated so they\u0026rsquo;re easier to manage and reason about",
        "breadcrumb": ["Documentation"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "b9ba9ab4f568ac1bcbe02e97db24a6c9_1",
        "title": "Accessing Fields",
        "link": "/docs/tour/references/selectors/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eField values within a struct are accessed with \u003cstrong\u003eselectors\u003c/strong\u003e,\nusing dot notation (\u003ccode\u003eX.name\u003c/code\u003e), or \u003cstrong\u003eindex expressions\u003c/strong\u003e (\u003ccode\u003eX[\u0026quot;name\u0026quot;]\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSelectors can be used if a field name is\n\u003ca href=\"/docs/reference/spec/#identifiers\"\u003ea valid CUE identifier\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn other cases, including computed references and non-valid identifiers,\nindex expressions can be used.\u003c/p\u003e",
        "content": "Field values within a struct are accessed with selectors, using dot notation (X.name), or index expressions (X[\u0026quot;name\u0026quot;]). Selectors can be used if a field name is a valid CUE identifier. In other cases, including computed references and non-valid identifiers, index expressions can be used. Copied! file.cue Copy code Copied! one: #n.a \u0026amp; #n[\u0026#34;a\u0026#34;] // Equivalent references two: #n.b // Valid identifer three: #n[\u0026#34;c d\u0026#34;] // Non-valid identifier four: #n[#E+\u0026#34;f\u0026#34;] // Computed reference five: #n.#g // Valid identifier #E: \u0026#34;e\u0026#34; #n: { a: 1 \u0026#34;b\u0026#34;: 2 \u0026#34;c d\u0026#34;: 3 ef: 4 #g: 5 } TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4, \u0026#34;five\u0026#34;: 5 }",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "5863d452919014594d736c302d47f280_1",
        "title": "Bottom / Error",
        "link": "/docs/tour/types/bottom/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eSpecifying a field multiple times with conflicting values results in an error,\nor \u003cstrong\u003ebottom\u003c/strong\u003e, written \u003ccode\u003e_|_\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBottom is a special value in CUE, and is the value that results from any error.\nLogically, all errors are equal,\nalthough CUE may associate them with metadata such as an error message.\u003c/p\u003e\n\u003cp\u003eAn error is \u003cem\u003enot\u003c/em\u003e the same as the value \u003ccode\u003enull\u003c/code\u003e.\n\u003ccode\u003e_|_\u003c/code\u003e isn\u0026rsquo;t a valid value for a field, but \u003ccode\u003enull\u003c/code\u003e is.\u003c/p\u003e",
        "content": "Specifying a field multiple times with conflicting values results in an error, or bottom, written _|_. Bottom is a special value in CUE, and is the value that results from any error. Logically, all errors are equal, although CUE may associate them with metadata such as an error message. An error is not the same as the value null. _|_ isn\u0026rsquo;t a valid value for a field, but null is. Copied! file.cue Copy code Copied! a: 1 a: 2 b: [50, 100] b: [50, 200] c: [0, 1, 2] d: c[5] TERMINAL Copy code Copied! $ cue eval -i file.cue a: _|_ // a: conflicting values 2 and 1 b: [50, _|_, // b.1: conflicting values 200 and 100 ] c: [0, 1, 2] d: _|_ // d: index out of range [5] with length 3 Notice how the -i flag changes how cue eval behaves. It causes errors to be represented as literal error values in the output, with error messages as inline comments. These literal _|_ values invalidate the CUE that\u0026rsquo;s output.",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "bfe2940b615d8c0db973b9e29be45ea7_1",
        "title": "Commented CUE Guides",
        "link": "/docs/howto/about-commented-cue-guides/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eSome how-to guides use CUE\u0026rsquo;s useful style of\n\u0026ldquo;\u003ca href=\"https://en.wikipedia.org/wiki/Literate_programming\"\u003eliterate\u003c/a\u003e configuration\u0026rdquo;.\nWe refer to them as \u003ca href=\"/search?q=tag:%22commented%20cue%22\"\n        class=\"tag tag--inline tag--pink\"\u003e\n            commented cue\n        \u003c/a\u003e guides.\u003c/p\u003e\n\u003cp\u003eCommented CUE guides tend to be short, presenting commented CUE code alongside\nsome input data, with a \u003ccode\u003ecue\u003c/code\u003e command showing the concrete result of the\ntechnique they\u0026rsquo;re demonstrating. Often that result is an error message, showing\nthat \u003ccode\u003ecue\u003c/code\u003e has caught the deliberate mistakes in our example data.\u003c/p\u003e",
        "content": "Some how-to guides use CUE\u0026rsquo;s useful style of \u0026ldquo;literate configuration\u0026rdquo;. We refer to them as commented cue guides. Commented CUE guides tend to be short, presenting commented CUE code alongside some input data, with a cue command showing the concrete result of the technique they\u0026rsquo;re demonstrating. Often that result is an error message, showing that cue has caught the deliberate mistakes in our example data. Here\u0026rsquo;s an example: Copied! example.cue Copy code Copied! package example // CUE comments start with \u0026#34;//\u0026#34; // and run to the end of the line // f1 is a regular field which must be a string f1: string // f2 is a required field which must be an // integer over 10 f2!: int \u0026amp; \u0026gt;10 Copied! data.yml Copy code Copied! # f1 is actually an integer f1: 123 # f2 is actually a string f2: \u0026#34;some string value\u0026#34; TERMINAL Copy code Copied! $ cue vet -c .:example data.yml f1: conflicting values 123 and string (mismatched types int and string): ./data.yml:2:5 ./example.cue:7:5 f2: conflicting values \u0026#34;some string value\u0026#34; and int (mismatched types string and int): ./data.yml:5:5 ./example.cue:11:6 Commented CUE guides require you, the reader, to modify their examples before you use them. Don\u0026rsquo;t use the CUE exactly as it\u0026rsquo;s presented, but first adapt the variable names and data structures to suit your configuration. Unlike some of our longer, step-by-step guides, the features showcased in Commented CUE guides are self-contained and \u0026ndash; we believe! \u0026ndash; easy to adapt to any situation. Each guide has a \u0026ldquo;Related content\u0026rdquo; section containing links to in-depth explanation and discussion of the techniques and language features used. If you find any guides confusing, incomplete, or not detailed enough, then we would really appreciate you telling us about your experience - just use the \u0026ldquo;Report an Issue\u0026rdquo; link at the very bottom of the guide\u0026rsquo;s page!",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "7340c5a152fa0d73685df3ff6b84a476_1",
        "title": "Evaluation",
        "link": "/docs/concept/using-the-cue-export-command/evaluation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eAs described on \u003ca href=\"/docs/concept/using-the-cue-export-command/inputs/\"\u003ethe previous page\u003c/a\u003e, each \u003ccode\u003ecue export\u003c/code\u003e\ninvocation first identifies and reads its inputs.\u003c/p\u003e",
        "content": "As described on the previous page, each cue export invocation first identifies and reads its inputs. Inputs must be readable If any of the inputs can\u0026rsquo;t be read, the command fails with an error message: Copied! 1.cue Copy code Copied! package one data: true TERMINAL Copy code Copied! $ cue export .:two build constraints exclude all CUE files in .: 1.cue: package is one, want two Default expression After the inputs are read successfully the command evaluates a single CUE expression. By default, this expression is the entirety of the configuration that was specified as the command\u0026rsquo;s input: Copied! 1.cue Copy code Copied! package one data: true TERMINAL Copy code Copied! $ cue export .:one { \u0026#34;data\u0026#34;: true } If evaluation is successful then the value of that same CUE expression is emitted in a manner that\u0026rsquo;s controlled through the flags described on the next page. Modified expression If you want to evaluate a different expression from the default, specify it with the --expression (-e) flag: Copied! 1.cue Copy code Copied! package one foo: { A: 1 B: 2 } bar: C: 3 TERMINAL Copy code Copied! $ cue export .:one -e foo { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2 } Constraints that aren\u0026rsquo;t involved in the expression\u0026rsquo;s value are not evaluated. In this example, notice that the struct bar contains two values for the field C that can\u0026rsquo;t unify, and yet the command still succeeds: Copied! 1.cue Copy code Copied! package one foo: { A: 1 B: 2 } bar: { C: 3 C: 4 } TERMINAL Copy code Copied! $ cue export 1.cue -e foo { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2 } To validate an entire configuration before exporting part of it, use cue vet before you run cue export. Issue #3371 tracks a bug where the entirety of a CUE package input must evaluate successfully, no matter what value is provided for the --expression (-e) flag. Flexible expressions The --expression (-e) flag takes an expression, which gives you flexibility when formulating the value to be evaluated and emitted: Copied! 1.cue Copy code Copied! package one foo: { A: 1 B: 2 } bar: { C: 3 D: 4 } TERMINAL Copy code Copied! $ cue export .:one -e \u0026#39;{ onlyFoo: \u0026#34;foo\u0026#34;: foo }\u0026#39; { \u0026#34;onlyFoo\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2 } } } Note the use of double quotes in the expression, around the \u0026quot;foo\u0026quot; label. They allow CUE to distinguish the label from the underlying foo field. They are required in this very specific case, where the emitted label needs to match the field\u0026rsquo;s name, but where the field\u0026rsquo;s value would be shadowed if the quotes weren\u0026rsquo;t present. Non-concrete expressions A cue export invocation fails if the value of the evaluated expression isn\u0026rsquo;t concrete \u0026ndash; in other words, if some part of its value can\u0026rsquo;t be represented in a data-only format such as JSON. Examples of non-concrete values include types such as string and constraints such as \u0026gt;=100: Copied! data.cue Copy code Copied! A: 1 B: number C: \u0026lt;=99 TERMINAL Copy code Copied! $ cue export data.cue B: incomplete value number: ./data.cue:2:4 C: incomplete value \u0026lt;=99: ./data.cue:3:4 Evaluation insight The CUE evaluator can emit statistics about each evaluation it performs. For more details, read Logging statistics from the CUE evaluator. Related content Reference: The cue export command Reference: cue help vet How-to Guide: Logging statistics from the CUE evaluator",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2b03679960950df772fb4fe7d78427b9_1",
        "title": "Glossary of terms",
        "link": "/docs/reference/glossary/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "A and()  Language Spec | Howto Guide\nA built-in function that accepts a list and returns the unification of all elements in the list B bool  Language Spec\nA primitive type representing the set of Boolean truth values denoted by the keywords true and false Built-in functions  Language Spec\nPredeclared functions provided by the CUE runtime that are available without being imported see also: and() | close() | div() | mod() | len() | or() | quo() | rem() bytes  Language Spec | Tour",
        "content": "A and()  Language Spec | Howto Guide A built-in function that accepts a list and returns the unification of all elements in the list B bool  Language Spec A primitive type representing the set of Boolean truth values denoted by the keywords true and false Built-in functions  Language Spec Predeclared functions provided by the CUE runtime that are available without being imported see also: and() | close() | div() | mod() | len() | or() | quo() | rem() bytes  Language Spec | Tour A primitive type representing a possibly empty sequence of arbitrary bytes C close()  Language Spec | Howto Guide A built-in function that converts a partially defined (\u0026ldquo;open\u0026rdquo;) struct to a fully defined (\u0026ldquo;closed\u0026rdquo;) struct D Default value  Tour | Howto Guide The single element of a disjunction that CUE assigns to a field if and only if unification fails to resolve a concrete value for the field An element of a disjunction prefixed with an asterisk (*) Disjunction  Tour #1 | Tour #2 div()  Language Spec | Howto Guide A built-in function that performs Euclidean division with its parameters and returns the integer quotient E F Field  Tour A key-value pair inside a map, associating a value with a given set of keys Field constraint  Language Spec | Tour A field constraint restricts a field\u0026rsquo;s value without actually defining the field, with the field only forming part of the output if it is successfully unified with a concrete value see also: Required field constraint | Optional field constraint float  Language Spec | Tour A primitive type representing the set of all decimal floating-point numbers G H I int  Language Spec | Tour A primitive type representing the set of all integer numbers J JSON  json.org \u0026ldquo;A lightweight data-interchange format \u0026hellip; easy for humans to read and write [and] easy for machines to parse and generate.\u0026rdquo; \u0026ndash; json.org A data format understood by the cue CLI, which can both parse and emit JSON as input and output K L len()  Language Spec | Howto Guide A built-in function that returns the lengths of various types as an integer List  Language Spec | Tour An arbitrary sequence of CUE values, enclosed in square brackets ([ ]) with values separated by commas (,) M mod()  Language Spec | Howto Guide A built-in function that performs Euclidean division with its parameters and returns the integer remainder N null  Language Spec A primitive type whose only value, the null value, is represented with the keyword null. Comparable with itself and any other type, the comparison with a null value always being equal and the comparison with any other type always being unequal number  Language Spec | Tour A generic primitive type representing the set of all members of both int and float types O Optional field constraint  Tour | Howto Guide A field constraint that restricts the field\u0026rsquo;s value if the field is present, whilst also permitting the field\u0026rsquo;s absence or()  Language Spec | Howto Guide A built-in function that accepts a list and produces a disjunction P Q quo()  Language Spec | Howto Guide A built-in function that performs truncated division with its parameters and returns the integer quotient R \u0026ldquo;Raw\u0026rdquo; strings  Language Spec | Tour A string literal enclosed with an equal number of hashes on both sides, allowing escape sequences to appear inside the text verbatim, without their usual escaping taking effect rem()  Language Spec | Howto Guide A built-in function that performs truncated division with its parameters and returns the integer remainder Required field constraint  Tour | Howto Guide A field constraint that restricts the field\u0026rsquo;s value whilst also requiring the field to be present S string  Language Spec | Tour A primitive type representing the set of UTF-8 strings see also: Raw strings Struct  Language Spec | Tour A composite type representing a set of elements (called fields) each of which has a name (called a label) and a value T Type  Tour U Unification  Language Spec V W X Y YAML  yaml.org \u0026ldquo;YAML is a human-friendly data serialization language for all programming languages\u0026rdquo; \u0026ndash; yaml.org A data format understood by the cue CLI, which can both parse and emit YAML as input and output Z #",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a5f35a8812d31fc77fb00ffa51e0d9c8_1",
        "title": "Imports",
        "link": "/docs/tour/packages/imports/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA CUE file may \u003cstrong\u003eimport\u003c/strong\u003e definitions from CUE\u0026rsquo;s built-in packages and\nuser-defined packages.\u003c/p\u003e\n\u003cp\u003eThe packages required by a file are declared in an \u003ccode\u003eimport\u003c/code\u003e statement at the\ntop of the file, after any package clause.\nA file does not need to be part of a package to use imports.\nMultiple import statements are permitted,\nbut it\u0026rsquo;s good style to use\na \u003cem\u003efactored\u003c/em\u003e import statement that combines them using parentheses.\u003c/p\u003e\n\u003cp\u003eAn import statement can optionally define a \u003cstrong\u003enamed import\u003c/strong\u003e,\nwhich specifies the identifer that \u003cem\u003emust\u003c/em\u003e be used when\nreferencing the imported package inside the file.\nNamed imports can help avoid variable shadowing.\u003c/p\u003e",
        "content": "A CUE file may import definitions from CUE\u0026rsquo;s built-in packages and user-defined packages. The packages required by a file are declared in an import statement at the top of the file, after any package clause. A file does not need to be part of a package to use imports. Multiple import statements are permitted, but it\u0026rsquo;s good style to use a factored import statement that combines them using parentheses. An import statement can optionally define a named import, which specifies the identifer that must be used when referencing the imported package inside the file. Named imports can help avoid variable shadowing. Copied! file.cue Copy code Copied! package example import ( \u0026#34;math\u0026#34; L \u0026#34;list\u0026#34; // The identifier L must be used. ) list: L.Sort([3, 2, 1, math.Pi], L.Ascending) TERMINAL Copy code Copied! $ cue export { \u0026#34;list\u0026#34;: [ 1, 2, 3, 3.14159265358979323846264338327950288419716939937510582097494459 ] }",
        "breadcrumb": ["Documentation","Tour","Packages and Imports"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "dea27daa99d5f3e015f069a2de14abeb_1",
        "title": "Installation",
        "link": "/docs/introduction/installation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--warn\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ch3 id=\"try-out-cue-in-your-browser\"\u003e\n    \u003ca href=\"#try-out-cue-in-your-browser\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eTry out CUE in your browser!\u003c/h3\u003e\n\u003cp\u003eYou can use the latest version of CUE without installing anything \u0026ndash; just visit\n\u003ca href=\"https://cuelang.org/play/\"\u003ecuelang.org/play\u003c/a\u003e!\u003c/p\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"installing-the-cue-command\"\u003e\n    \u003ca href=\"#installing-the-cue-command\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eInstalling the \u003ccode\u003ecue\u003c/code\u003e command\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e command is available from various sources, listed on this page.\nIf you don\u0026rsquo;t know which source to choose, download and unpack the\n\u003ca href=\"https://github.com/cue-lang/cue/releases/latest\"\u003elatest version\u003c/a\u003e\nthat\u0026rsquo;s appropriate for your operating system \u0026ndash; it contains the most recent\nfeatures and bug fixes.\nThe latest version of the \u003ccode\u003ecue\u003c/code\u003e command is:\u003c/p\u003e\n\u003cdiv class=\"code-block code-block--heading code-block--terminal\"data-copy\u003e\u003cdiv class=\"code-block__heading\"\u003e\n            \u003cspan class=\"code-block__tab\"\u003eTERMINAL\u003c/span\u003e\n        \u003c/div\u003e\u003cdiv class=\"code-block__highlight\"\u003e\u003cbutton class=\"code-block__copy\" type=\"button\" data-copy-button data-copy-type=\"code\" data-copy-value=\"Y3VlIHZlcnNpb24=\"\u003e\n                \u003cspan\u003eCopy code\u003c/span\u003e\n                \u003cspan class=\"code-block__message is-hidden\" data-copy-message aria-hidden=\"true\"\u003e\n                    Copied!\n                \u003c/span\u003e\n            \u003c/button\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ cue version\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecue version v0.13.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\u003c/div\u003e",
        "content": "Try out CUE in your browser! You can use the latest version of CUE without installing anything \u0026ndash; just visit cuelang.org/play! Installing the cue command The cue command is available from various sources, listed on this page. If you don\u0026rsquo;t know which source to choose, download and unpack the latest version that\u0026rsquo;s appropriate for your operating system \u0026ndash; it contains the most recent features and bug fixes. The latest version of the cue command is: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Download an official CUE binary On Linux, Microsoft Windows, and macOS, the cue command can be downloaded from the official CUE releases. These releases include pre-releases, which are cutting-edge versions of the cue command made available to help expose bugs and flush out unintended behaviours. You should choose to install the latest release if you don\u0026rsquo;t have a specific reason to select a pre-release. Install using Homebrew On macOS and Linux, cue can be installed using Homebrew (brew.sh): TERMINAL Copy code Copied! $ brew install cue-lang/tap/cue Install from Docker Hub The CUE project publishes official container images containing cue on Docker Hub (hub.docker.com/r/cuelang/cue). They can be used on platforms supported by Docker. Various tags are available that let you select container images for different machine architectures and CUE versions. To use the latest version that\u0026rsquo;s appropriate for your machine, use the latest tag: TERMINAL Copy code Copied! $ docker pull cuelang/cue:latest Install from source On platforms supported by Go, cue can be installed from source using any of its release, pre-release, or as-yet-unreleased versions. Installing from source requires that you already have Go installed and available. For example, to fetch the latest version: TERMINAL Copy code Copied! $ go install cuelang.org/go/cmd/cue@latest ... This page lists the installable releases and pre-releases that you can specify instead of latest. Development version You can install the development version of cue from source by specifying master: TERMINAL Copy code Copied! $ go install cuelang.org/go/cmd/cue@master ... The capabilities of the development version change frequently because it contains the most recent, unreleased code. Install on Arch Linux On Arch Linux (archlinux.org), cue can be installed from a package in the official Arch extra repository: TERMINAL Copy code Copied! $ pacman -S extra/cue This package is not published by the CUE project. Using the Go API CUE\u0026rsquo;s Go APIs are defined in the cuelang.org/go module, which can be added as a versioned dependency using Go\u0026rsquo;s dependency management workflows. All available versions are listed at pkg.go.dev/cuelang.org/go. For example, to add a dependency on the latest version: TERMINAL Copy code Copied! $ go get cuelang.org/go@latest ... Related content Concept Guide: How CUE works with Go",
        "breadcrumb": ["Documentation","Introduction"],
        "contentType": "Introduction",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "ec10c2c9786183432bbfa1e10a0167dc_1",
        "title": "Interpolation",
        "link": "/docs/tour/expressions/interpolation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eString and bytes literals support \u003cstrong\u003einterpolation\u003c/strong\u003e,\nin both their single- and multi-line forms.\u003c/p\u003e\n\u003cp\u003eAny valid CUE expression may be used inside escaped parentheses.\u003c/p\u003e",
        "content": "String and bytes literals support interpolation, in both their single- and multi-line forms. Any valid CUE expression may be used inside escaped parentheses. Copied! file.cue Copy code Copied! m: \u0026#34;You are \\(#cost-#budget) dollars over budget!\u0026#34; email: \u0026#34;\u0026#34;\u0026#34; Here is a message from the finance team: \\(m) Regards, Your friends on the 12th floor \u0026#34;\u0026#34;\u0026#34; #cost: 102 #budget: 88 TERMINAL Copy code Copied! $ cue export file.cue --out yaml m: You are 14 dollars over budget! email: |- Here is a message from the finance team: You are 14 dollars over budget! Regards, Your friends on the 12th floor",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4d553c0a2d5c9fb2b66268d1a57301ac_1",
        "title": "The Logic of CUE",
        "link": "/docs/concept/the-logic-of-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis page explains the core concept on which pretty much everything that is CUE\ndepends.\nIt helps to get a top-down understanding and frame of reference,\nbut it is not necessary for learning the language.\u003c/p\u003e",
        "content": "This page explains the core concept on which pretty much everything that is CUE depends. It helps to get a top-down understanding and frame of reference, but it is not necessary for learning the language. Types are values There are two core aspects of CUE that make it different from the usual programming or configuration languages: Types are values Values (and thus types) are ordered into a lattice These properties are relevant almost to everything that makes CUE what it is. They simplify the language, as many concepts that are distinct in other languages fold together. The resulting order independence simplifies reasoning about values for both humans and machines. It also forces formal rigor on the language, such as defining exactly what it means to be optional, a default value, or null. Making sure all values fit in a value lattice leaves no wiggle room. Finally, the combination of all this allows for many unique features, for instance: a single language for specifying data, schema, validation and policy constraints, meta reasoning, such as determining whether a new schema version is backwards compatible, automated rewriting, such as is done by cue trim, creating multi-source constraint pipelines, retaining documentation across normalization, and so on. The Value Lattice Every value in CUE, including what would in most programming languages be considered types, is partially ordered in a single hierarchy (a lattice, to be precise). Even entire configurations and schemas are placed in this hierarchy. What is a lattice? This section is useful to understand what a lattice is, but is not strictly needed to grasp the following sections, nor the specifics of CUE itself. Skip at will. A lattice is a partially ordered set, in which every two elements have a unique least upper bound (join) and greatest lower bound (meet). By definition this means there is always a single root (top) and a single leaf (bottom). Let\u0026rsquo;s consider what this means by looking at an example. This diagrams below show a lattice of all values of respectively a 2- and 3- element set, ordered by the subset relation. graph TD xy(\"{x, y}\") xy --\u003e x(\"{x}\") xy --\u003e y(\"{y}\") x --\u003e B(\"{}\") y --\u003e B graph TD linkStyle default interpolate basis xyz(\"{x, y, z}\") xyz --\u003e xy(\"{x, y}\") xyz --\u003e xz(\"{x, z}\") xyz --\u003e yz(\"{y, z}\") xy --\u003e x xy --\u003e y xz --\u003e x xz --\u003e z yz --\u003e y yz --\u003e z x(\"{x}\") --\u003e B y(\"{y}\") --\u003e B z(\"{z}\") --\u003e B B(\"{}\") Squint harder if you can\u0026#39;t recognize the cube. If an element B is a subset of element A, there is a path from A to B. In more general terms, we then say that A _subsumes_ B, or that B is an _instance of_ A. In our examples, `{x}` is an instance of `{x, y}`, because we defined our lattice to use the subset relation. But we can use any relation we want as long as the properties of a lattice are upheld. An important aspect of a lattice is that for every two elements, there is a unique instance of both elements that subsumes all other elements that are an instance of both elements. This is called the greatest lower bound, or meet. Now let\u0026rsquo;s imagine we could define a lattice for, say, all configurations, schemas and data. In that case, we could always unambiguously merge two such configurations independently of order. This is exactly what CUE does! CUE\u0026rsquo;s hierarchy In this section we will introduce CUE\u0026rsquo;s value hierarchy. The goal here is to get the big picture, and will only present the details when it helps for this purpose. Booleans Let\u0026rsquo;s start simple, with booleans. graph TD B(bool) B --\u003e T(true) B --\u003e F(false) T --\u003e E F --\u003e E E(\" (bottom)\") This diagram shows that CUE interprets both true and false as an instance of bool. No surprises there. What is less ordinary is that, to CUE, bool is just as much a value as true and false. For instance, when we say that a value is both a bool and true, or in lattice terms, if we find the greatest lower bound of these values, the answer is true. Again maybe no surprise, except that in CUE this is actually an operation, denoted bool \u0026amp; true. This also explains the odd fourth element in the graph labeled bottom. Bottom, in this example, is the result of computing true \u0026amp; false. A value cannot be both true and false, so this an error. Bottom is analogous to an error in many other languages. Bottom is an instance of every value and type, in fact. More on errors later. One more detail: besides the meet operator (\u0026amp;), CUE also has a join operator (|), which computes the least upper bound. The result of true | false is indeed bool in CUE. Numbers With numbers things get a bit more interesting. CUE has gone through various iterations of the number type system to find the mix of being practical and strict, while still being simple. CUE recognizes number, and the instances int and float as classes of numbers. For now it suffices to only consider number and int, the latter being an instance of the former. Let\u0026rsquo;s consider a lattice with some example numeric values. We cannot show a complete lattice, of course, as the number of elements is infinite (it actually is, CUE has arbitrary precision arithmetic). graph TD N(number) N --\u003e I(\"int\") N --\u003e GEH(\"\u003e=0.5\") N --\u003e LTC(\"\u003c10\") I --\u003e Z(\"0\") I --\u003e One(\"1\") IFI(\"1.1\") LTC --\u003e Z LTC --\u003e One LTC --\u003e IFI GEH --\u003e One GEH --\u003e IFI GEH --\u003e CCF(\"20.0\") Z --\u003e E One --\u003e E IFI --\u003e E CCF --\u003e E E(\" (bottom)\") Here we see what is traditionally a type class (number and int) and some concrete instances, that is, specific numbers. They are ordered as expected: 0 and 1 are integral numbers, whereas 20.0 (by definition) and 1.1 are numbers, but not integers. But we also see \u0026ldquo;constraints\u0026rdquo;, a category",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4d553c0a2d5c9fb2b66268d1a57301ac_2",
        "title": "The Logic of CUE",
        "link": "/docs/concept/the-logic-of-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis page explains the core concept on which pretty much everything that is CUE\ndepends.\nIt helps to get a top-down understanding and frame of reference,\nbut it is not necessary for learning the language.\u003c/p\u003e",
        "content": "of values that falls between the traditional concepts of value and type. CUE defines the constraints we see here in terms of its binary operators \u0026gt;= and \u0026lt;. It allows all binary operators that result in a boolean, except ==, to be used as a constraint by leaving off the left value, where op B defines the set of all values A for which A op B is true. The constraint \u0026lt;10 means all numbers less than 10. Note that we say all numbers, even though 10 is an integer. This is because CUE allows implicit conversion between number types in comparisons. CUE types Let\u0026rsquo;s look at all types CUE supports. graph TD A(\" (top)\") A --\u003e B(bool) A --\u003e U(null) A --\u003e D(bytes) N --\u003e I(\"int\") A --\u003e N(number) A --\u003e T(struct) A --\u003e L(list) A --\u003e S(string) D --\u003e E S --\u003e E B --\u003e E I --\u003e E U --\u003e E T --\u003e E L --\u003e E E(\" (bottom)\") There are actually values between top and the basic types. The | operator in CUE allows one to define \u0026ldquo;sum types\u0026rdquo; like int | string. The same operator can also be used to describe what are called \u0026ldquo;enums\u0026rdquo; in other languages, for instance, 1 | 2 | 3. To CUE these two thingsdisjunctions of types and disjunctions of valuesare the same thing. You can also mix types and values in a disjunction, as in *1 | intto define defaults (marked by *), and you can use expressions as well, like *pet.species | \u0026quot;cat\u0026quot;. The latter evaluates to the value of pet.species, or \u0026quot;cat\u0026quot; if pet.species is null; this is called null coalescing in some languages. These various uses of | are not the result of operator overloading: they are all the same operation in CUE. Structs Ordering of scalar types, like numbers and strings, is fairly straightforward and will feel familiar to anyone that has worked with a typed programming language. But ordering structs might seem a bit unusual. Below are two examples of an ordering defined on structs. graph TD M[\"municipalityname: stringpopulation: int\"] C[\"big cityname: stringpopulation: \u003e1M\"] L[\"Londonname: 'London'population: 8M\"] M --\u003e C C --\u003e L classDef node text-align:left London is a big city, which is a municipality graph TD T(\"\") T --\u003e ai[\"a: int\"] T --\u003e bi[\"b: int\"] ai --\u003e a1[\"a: 1\"] ai --\u003e aibi aibi[\"a: intb: int\"] bi --\u003e aibi a1b1[\"a: 1b: 1\"] aibi --\u003e a1b1 a1b1 --\u003e E a1 --\u003e E a1 --\u003e a1b1 bi --\u003e b1[\"b: 1\"] b1 --\u003e a1b1 b1 --\u003e E E(\"\") Loosely speaking, a struct is an instance of another if it has at least all the fields defined by the parent and if its constraints on these fields are at least as strict as those defined by its parent. The instance relation for structs has an analogy in software engineering: backwards compatibility. For a newer version of an API to be backwards compatible with the previous version it must subsume it. In other words, the old version must be an instance of the new one. Or yet another way to say it: a new version may not forbid what was allowed in the older version. With optional fields it gets a bit more subtle, but basically, an instance may change an optional field to required, but not remove it. The backwards compatibility metaphor applies here as well. graph TD ao[\"a?: int\"] ao --\u003e ar[\"a: int\"] ao --\u003e aolt[\"a?: int \u0026 \u003c10\"] aolt --\u003e arlt[\"a: int \u0026 \u003c10\"] ar --\u003e arlt Required is more specific than optional graph TD ao0[\"a?: 0\"] ao1[\"a?: 1\"] aob[\"a?: \"] ao0 --\u003e aob ao1 --\u003e aob ar0[\"a: 0\"] ar1[\"a: 1\"] aob --\u003e E ar0 --\u003e E ar1 --\u003e E E(\"\") Conflicting values for optional fields result in disallowing that field, conflicting required fields result in a faulty struct An important thing to note is that, unlike for required fields, conflicting values for an optional field do not cause a struct to be faulty. This definition was a result from fitting the notion of closed structs into the value lattice. But it can also be explained with some logic. A common practice in interpretations of logic is to allow infering $\\neg P$ from $P \\rightarrow \\perp$. If for an optional field we find the value $\\perp$, we can infer \"not that field\", or, drop it. If we derive $\\perp$ for a required field, we have a problem, as a required field cannot be omitted. The answer to life, the universe and everything CUE has its own equivalent of 42, the answer to life, the universe and everything, albeit more than 2 characters. Graph unification of typed feature structures, CUE\u0026rsquo;s theoretical foundation, can be described at many levels of abstraction. CUE\u0026rsquo;s language specification, and most literature, take a less abstract and more comprehensible approach, but in its most abstract form, it can loosely be defined as follows: Subsumption: given a set $\\mathcal{F}$ of all TFSs (graphs, CUE values, basically), and $F$ and $F'$ in $\\mathcal{F}$, $F$ subsumes $F'$, denoted $F \\sqsubseteq F'$, if and only if: $$\\begin{eqnarray} \u0026 \u0026 \\pi \\equiv_\\mathcal{F} \\pi' \\text{ implies } \\pi \\equiv_\\mathcal{F'} \\pi' \\\\ \u0026 \u0026 \\mathcal{P}_\\mathcal{F}(\\pi) = t \\text{ implies } \\mathcal{P}_\\mathcal{F'}(\\pi) = t' \\text{ and } t' \\sqsubseteq t \\\\ \\end{eqnarray}$$ where $\\pi \\equiv_\\mathcal{F} \\pi'$ means that $F\\in\\mathcal{F}$ contains a path equivalence or reentrancy between the paths $\\pi$ and $\\pi'$ (two references starting from the root of a config end up at the same node) and $\\mathcal{P}_\\mathcal{F}(\\pi) = t$ means the type at path $\\pi$ is $t$ (itself a graph in $\\mathcal{F}$). Unification $F \\sqcap F'$ of two TFSs $F$ and $F'$ is then the greatest lower bound of $F$ and $F'$ in $\\mathcal{F}$ ordered by subsumption. This highly abstract definition determines almost everything about CUE. For instance, lazy binding was not a design decision, but a direct consequence of following this definition. It determines the possible evaluation strategies and what cycles mean, if allowed. Optional fields, definitions and default values were added to the language by choice, but what",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4d553c0a2d5c9fb2b66268d1a57301ac_3",
        "title": "The Logic of CUE",
        "link": "/docs/concept/the-logic-of-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis page explains the core concept on which pretty much everything that is CUE\ndepends.\nIt helps to get a top-down understanding and frame of reference,\nbut it is not necessary for learning the language.\u003c/p\u003e",
        "content": "they can mean strictly follows from this definition. Null We conveniently left out the discussion of null before. Not only does it make an uninspiring example to describe a lattice, it is also actually surprisingly complicated to pin down what it means. This is partly due to lack of guidance from the JSON standard regarding its meaning and the different interpretations it gets in practice. TypeScript creates some order in the chaos by introducing the concepts undefined and void in addition to null. It is a necessary evil to give null some meaning that is compatible with common practices, within the context of its type system. CUE got lucky. CUE\u0026rsquo;s interpretation of null, optionality, and related concepts is actually inspired by TypeScript. But because types are values in CUE, TypeScript\u0026rsquo;s concepts of undefined, void and null and optional fields, roughly collapse onto CUE\u0026rsquo;s null, bottom (_|_), and optional fields, resulting in a somewhat simpler model. Default values Default values are CUE\u0026rsquo;s equivalent of inheritance, specifically the kind that allows instances to override any value of its parent. Without it, very little boilerplate removal would be possible. That is fine if CUE is used just for validation, but as it aims to be useful across the entire configuration continuum, it seemed too restrictive to not have such a construct. Relation to inheritance In CUE, if one sees a concrete value for a field, it is guaranteed that this will be the final result. If a value is not concrete (like string), it is clear the search for a concrete value is not over. In other words, an instance may never violate the constraints of its parent. This property makes it very hard to inadvertently make false conclusions in CUE. Default values do not change this property; they syntactically appear as non-concrete values. CUE also bails out and requires explicit values if two conflicting defaults are specified for the same field, again limiting the search space. With approaches that allow overrides, whether it be the complex inheritance used in languages like GCL and Jsonnet or the much simpler file-based approaches as used in HCL and Kustomize, finding a declaration for a concrete field value does not guarantee a final answer, because another concrete value that occurs elsewhere can override it. When one needs to change a value of such a field, it can be time-consuming and, especially when under pressure, very tempting to skip following complicated inheritance chains, double-check a configuration file specifying overlay order, or look for a file that is lexically sorted after the one under consideration. So there is a clear benefit to having fully expanded configurations over such override methods. CUE simulates that benefit by guaranteeing that any observed field value holds for the final result. If the user makes the false assumption that no concrete value is specified to discard the default value, CUE will catch an erroneous change to that value and report the conflicting locations. But there is more. In CUE one can apply a constraint to a group of values at once, even across files. Once set, there is no need to look at the individual values and files to know these constraints apply. Such information is not readily available for fully expanded configurations.1 But also with inheritance-based solutions that allow arbitrary overrides, templates give little information. The ability to enforce constraints top down is crucial for any large-scale configuration setup. GCL and Jsonnet address this with assertions. Assertions, however, are typically decoupled from their fields, making them both hard to discover and hard to reason about. Where CUE simplifies constraints (\u0026gt;=3 \u0026amp; \u0026lt;=10 and \u0026gt;=5 \u0026amp; \u0026lt;=20 become \u0026gt;=5 \u0026amp; \u0026lt;=10, \u0026gt;=1 \u0026amp; \u0026lt;=1 becomes 1), GCL and Jsonnet do not (it would be quite complex), causing an ever-growing pile of assertions. Semantics CUE defaults, which are values marked with a * in disjunctions, preserve the beneficial properties of the lattice. In order to do so, CUE must ensure that the order of picking defaults does not influence the outcome. Suppose we define two fields, each with the same default value. We also define that these fields are equal to each other. Copy code Copied! a: int | *1 b: int | *1 a: b b: a This is fine. The obvious answer is a: 1, b: 1. But now suppose we change one of the default values: Copy code Copied! a: int | *1 b: int | *2 a: b b: a What should the answer be? Picking either 1 or 2 as the default would result in a resolution of the constraints, but would also be highly undesirable, as the result would depend on the mood of the implementation. This also starts to smell like an NP-complete constraint solving problem. (Basic graph unification itself is pseudo linear.) CUE wants no part of these shenanigans. So the answer in this case is that there are no concrete values as the defaults cannot be used. The model for this is actually quite simple. Conceptually, CUE keeps two parallel values, one for all possible values and one for the default, which must be an instance of the former. Roughly speaking, for the example with the conflict, it simultaneously evaluates: Copy code Copied! // All allowed values a: int b: int a: b b: a Copy code Copied! // Default a: 1 b: 2 a: b b: a Equating a and b clearly results in a conflict (1 != 2) and each will result in _|_, leaving the left values as the only viable answer. Now consider the two values corresponding to the original example: Copy code Copied! // All allowed values a: int b: int a: b b: a Copy code Copied! // Default a: 1 b: 1 a: b b: a Here the defaults are not in conflict and can safely be returned. Note that it is not an all-or-nothing game. The parallel values are determined on a field-by-field basis. So defaults can be selected, or not, independently for fields that do not",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4d553c0a2d5c9fb2b66268d1a57301ac_4",
        "title": "The Logic of CUE",
        "link": "/docs/concept/the-logic-of-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis page explains the core concept on which pretty much everything that is CUE\ndepends.\nIt helps to get a top-down understanding and frame of reference,\nbut it is not necessary for learning the language.\u003c/p\u003e",
        "content": "depend on each other. Reasoning and Inference The values lattice brings CUE another advantage: the ability to reason about values, schemas, and constraints. We already discussed how limiting inheritance, whether language-based or file-based, makes it easier for people to reason about values. But it also makes it easier for machines. Boilerplate removal CUE\u0026rsquo;s severe restrictions on inheritance limit its ability to define hierarchies of templates to remove boilerplate. But CUE provides some new mechanisms for removing boilerplate. Suppose a node must inherit from multiple templates, or mixins. Because order is irrelevant in CUE, there is no need to specify these in a particular order or even in one location. One can even say on a single line that a collection of fields must mix in a template. For instance, Copy code Copied! jobs: [string]: acmeMonitoring tells CUE that all jobs in jobs must mix in acmeMonitoring. There is no need to repeat this at every node. In CUE, though, we typically refer to acmeMonitoring as a constraint. After all, applying it will guarantee that a job implements monitoring in a certain way. If such a constraint also contains sensible defaults, however, it simultaneously validates and reduces boilerplate.2 This ability to simultaneously enforce constraints and remove boilerplate was a key factor in the success of the typed feature structure systems that inspired the creation of CUE. This property is also useful in automation. The cue trim tool can automatically remove boilerplate from configurations using the same logic. Cycles An astute reader may have noticed that there were cyclic references between fields in some of the examples, something that is not allowed in your typical programming or configuration language. CUE\u0026rsquo;s underlying model allows reasoning over cycles. Consider a CUE program defining two fields; Copy code Copied! a: b b: a This can only be interpreted to mean that a and b must be equal. If there is no concrete value assigned to a or b, they remain unspecified in the same way as if each had been declared as string. This particular case comes in handy in Kubernetes, for instance, if one wants to equate a set of labels with a set of selectors (regardless of whether that is good practice). But it goes further. Consider Copy code Copied! a: b + 1 b: a - 1 b: 1 When evaluating a, CUE will attempt to resolve b and will find (a-1) \u0026amp; 1 after unifying the two declarations for b. It cannot recursively resolve a, as this would result in an evaluation cycle. However, the expression (a-1) \u0026amp; 1 is an error unless (a-1) is 1. So if this configuration is ever to be a valid, we can safely assume the answer is 1 and verify that a-1 == 1 after resolving a. So CUE happily resolves this to Copy code Copied! a: 2 b: 1 without resorting to any fancy algebraic constraint satisfaction solvers, just plain ol\u0026rsquo; logic. Most cycles that do not result in infinite structures can be handled by CUE. In fact, it could handle most infinite structures in bounded time as well, but it puts limits on such cycles for practical reasons.3 File organization What applies at the language level also applies at the file level. Within a package, or project, there is no need for files to mutually import each other. Files can be split across organizational lines each with a different set of policies, all implemented with the same familiar constraints. The sky is the limit Many other things are possible. Take for instance querying. Whereas validating data is the problem of finding data that is inconsistent with some constraints, querying is the problem of finding data that matches some given constraints. Clearly these two concepts are related. Computing backwards compatibility (instance of), computing the most general schema mutually compatible with a set of others (greatest lower bound), inferring optimal templates from concrete instances (least upper bound): all of these fall in the realm of possibilities of CUE\u0026rsquo;s model. References The title of this section refers to Bob Carpenter\u0026rsquo;s \u0026ldquo;The Logic of Typed Feature Structures\u0026rdquo; (1992, Cambridge University Press, ISBN:0-521-41932-8). Most of the inspiration for the underlying work presented here comes from the Lingo and LKB project. One can read more about this in Ann Copestake\u0026rsquo;s \u0026ldquo;Implementing Typed Feature Structure Grammars.\u0026rdquo; (2002, CSLI Publications, ISBN 1-57586-261-1). Footnotes Although CUE could be used to verify those properties in such data-only configurations.\u0026#160;\u0026#x21a9;\u0026#xfe0e; TFSs typically don\u0026rsquo;t have default values, it is the structure itself that is boilerplate removing, as the structure itself is what is the useful value. But that is a different topic. It doesn\u0026rsquo;t work quite as well if one needs numeric values. This is why CUE adds defaults.\u0026#160;\u0026#x21a9;\u0026#xfe0e; Detection of structural cycles (an occurs check) is not yet implemented, and thus printing infinite structures will still result in a loop.\u0026#160;\u0026#x21a9;\u0026#xfe0e;",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a492d3c4dcfde26a8c22935f671e221b_1",
        "title": "YAML",
        "link": "/docs/integration/yaml/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Integrations"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "52f3e6a6d26d58b3ca63890586812ed7_1",
        "title": "Integrations",
        "link": "/docs/integration/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "CUE has first-class support for a growing range of formats and ecosystems:\nJSON CUE reads, writes, and validates JSON data, regardless of its source: discrete JSON files, I/O streams, or JSON contained in data fields inside other formats. The cue command emits JSON by default. Learn more Learn more YAML CUE\u0026rsquo;s support for YAML mirrors its first class JSON support: it reads, writes and validates YAML data anywhere it can be found: discrete YAML files, I/O streams, or YAML contained in data fields inside other formats.",
        "content": "CUE has first-class support for a growing range of formats and ecosystems: JSON CUE reads, writes, and validates JSON data, regardless of its source: discrete JSON files, I/O streams, or JSON contained in data fields inside other formats. The cue command emits JSON by default. Learn more Learn more YAML CUE\u0026rsquo;s support for YAML mirrors its first class JSON support: it reads, writes and validates YAML data anywhere it can be found: discrete YAML files, I/O streams, or YAML contained in data fields inside other formats. Read more Read more Go The cue command converts Go types to CUE, enabling their first class use as schema and data constraints. CUE\u0026rsquo;s extensive Go API allows code to have fine grained control over CUE\u0026rsquo;s capabilities and operations, including export to any encoding supported by CUE. Learn more Learn more OpenAPI CUE reads and writes OpenAPI data schemas through its Go API and the cue command, enabling schemas to be used to constrain and validate data directly, and to be expressed in other formats - including CUE. Read more Read more Protocol Buffers CUE\u0026rsquo;s Go API and the cue command read Protobuf definitions, enabling them to be used to constrain and validate data directly and to be expressed in other formats. CUE constraints can be extracted from Protobuf options, allowing richer data validation than Protobuf\u0026rsquo;s type-based defaults. Learn more Learn more JSON Schema CUE understands JSON Schema constraints through its Go API and the cue command, enabling schemas to be used to constrain and validate data directly, and to be expressed in other formats - including CUE. Read more Read more Java Technology preview Support for using CUE in Java is available through an experimental Java library. Follow this introductory tutorial to get started with CUE in Java. Learn more Learn more Technologies CUE is independent of the technologies it can be used alongside. Some examples of its use with specific tools, systems, and providers are collected in CUE By Example: Controlling Kubernetes A worked example of converting a set of Kubernetes configuration files for a collection of microservices into smaller, validated CUE configurations by automatically removing boilerplate; automating commands that don\u0026rsquo;t know CUE yet (such as kubectl); and extracting schema definitions from Kubernetes source code. Read on CUE By Example Read on CUE By Example Driving GitHub Actions workflows A guide explaining how to convert GitHub Actions workflow files from YAML to CUE, check those workflows are valid, and then use CUE\u0026rsquo;s tooling layer to regenerate YAML - allowing safer and more predictable changes. Read on CUE By Example Read on CUE By Example Writing Terraform plan policies A pair of guides showing how to validate the JSON output from terraform plan using CUE as a policy language. Read on CUE By Example Read on CUE By Example Managing Mythic Beasts DNS A guide that demonstrates how to use CUE to keep DNS data in a compact format, using CUE templating to DRY out configurations, and use CUE\u0026rsquo;s constraints to enforce policies on the data to guard against mistakes. Read on CUE By Example Read on CUE By Example Driving GitLab CI/CD Pipelines A guide illustrating how to convert a GitLab CI/CD pipeline file from YAML to CUE, check its contents are valid, and then use CUE\u0026rsquo;s tooling layer to regenerate YAML - allowing safer and more predictable changes. Read on CUE By Example Read on CUE By Example Driving Buildkite pipelines A guide demonstrating how to convert static Buildkite pipelines files from YAML to CUE, check the pipelines are valid, and then use CUE\u0026rsquo;s tooling layer to regenerate YAML - allowing safer and more predictable changes by switching to CUE as a source of truth. Read on CUE By Example Read on CUE By Example Supercharging Buildkite pipelines A guide that builds on an official Buildkite blog post, showing how to use CUE to define and validate CI pipelines as they\u0026rsquo;re initiated and as they\u0026rsquo;re executing, so that their steps can vary dynamically, based on the pipeline\u0026rsquo;s execution context. Read on CUE By Example Read on CUE By Example",
        "breadcrumb": ["Documentation"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "9a2ea5b3ba5af96e55eef8de9a3a70fb_1",
        "title": "Top / Any",
        "link": "/docs/tour/types/top/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eTop\u003c/strong\u003e, written \u003ccode\u003e_\u003c/code\u003e, represents any CUE value.\u003cbr\u003e\nIt can be thought of as a placeholder,\nwaiting to be given a more specific value elsewhere.\u003c/p\u003e\n\u003cp\u003eA field with a value of top can\u0026rsquo;t be exported\nbecause data formats such as JSON and YAML\ndon\u0026rsquo;t have any way to represent non-concrete values.\u003c/p\u003e\n\u003cp\u003eConstraining a regular field with top brings that field into existence,\nwhilst allowing its value to be constrained and defined elsewhere.\u003c/p\u003e",
        "content": "Top, written _, represents any CUE value. It can be thought of as a placeholder, waiting to be given a more specific value elsewhere. A field with a value of top can\u0026rsquo;t be exported because data formats such as JSON and YAML don\u0026rsquo;t have any way to represent non-concrete values. Constraining a regular field with top brings that field into existence, whilst allowing its value to be constrained and defined elsewhere. Copied! fields.cue Copy code Copied! a: _ b: _ c: _ d: _ e: _ f: _ Copied! values.cue Copy code Copied! a: 1 b: 2.2 c: \u0026#34;three\u0026#34; d: {four: \u0026#34;five\u0026#34;} e: [6, 7.7, \u0026#34;eight\u0026#34;] f: true TERMINAL Copy code Copied! $ cue export fields.cue values.cue { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2.2, \u0026#34;c\u0026#34;: \u0026#34;three\u0026#34;, \u0026#34;d\u0026#34;: { \u0026#34;four\u0026#34;: \u0026#34;five\u0026#34; }, \u0026#34;e\u0026#34;: [ 6, 7.7, \u0026#34;eight\u0026#34; ], \u0026#34;f\u0026#34;: true }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "f733c44ffde3d4b934f158f8b4caabd0_1",
        "title": "Aliases",
        "link": "/docs/tour/references/aliases/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eAliases\u003c/strong\u003e provide a way to refer to a value by a different identifier.\nThey are declared using an equals sign (\u003ccode\u003e=\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eAn alias is typically used to access a field in an outer scope that has been\nmade inaccessible (or \u003cem\u003eshadowed\u003c/em\u003e) by a field in some inner scope that has the\nsame identifier. Some of their other uses are also demonstrated in the\nexample below.\u003c/p\u003e\n\u003cp\u003eAliases are \u003cem\u003enot\u003c/em\u003e members of a struct,\ndo \u003cem\u003enot\u003c/em\u003e appear in output,\nand can \u003cem\u003eonly\u003c/em\u003e be referenced within the scope in which they are defined.\u003c/p\u003e",
        "content": "Aliases provide a way to refer to a value by a different identifier. They are declared using an equals sign (=). An alias is typically used to access a field in an outer scope that has been made inaccessible (or shadowed) by a field in some inner scope that has the same identifier. Some of their other uses are also demonstrated in the example below. Aliases are not members of a struct, do not appear in output, and can only be referenced within the scope in which they are defined. Copied! file.cue Copy code Copied! // Alias A provides access to a top-level field // with a name that is not a valid identifier. A=\u0026#34;a top level field\u0026#34;: 1 // Alias B provides access to a dynamic field. B=(#b): 2 #b: \u0026#34;some dynamic field\u0026#34; a: A b: B // Alias C refers to the value that\u0026#39;s on the right // hand side of field \u0026#34;c\u0026#34;, and demonstrates one way // that shadowed fields can be accessed. c: C={ d: 3 e: { d: 4 e: d f: C.d } } TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;a top level field\u0026#34;: 1, \u0026#34;some dynamic field\u0026#34;: 2, \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: { \u0026#34;d\u0026#34;: 3, \u0026#34;e\u0026#34;: { \u0026#34;d\u0026#34;: 4, \u0026#34;e\u0026#34;: 4, \u0026#34;f\u0026#34;: 3 } } } The CUE language specification defines the full list of positions where an alias can appear. A longer example exploring a problem that aliases are able to solve can be found in the concept guide Alias and reference scopes.",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "2967cc7efc71277ac1d9e67c1cd3905f_1",
        "title": "Dynamic Fields",
        "link": "/docs/tour/expressions/dynamic-fields/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA \u003cstrong\u003edynamic field\u003c/strong\u003e is a field whose name, or \u003cem\u003elabel\u003c/em\u003e, is determined by\nan expression wrapped in parentheses\nor through string interpolation:\n\u003ccode\u003e(a + b)\u003c/code\u003e or \u003ccode\u003e\u0026quot;\\(a + b)\u0026quot;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA dynamic field\u0026rsquo;s identifier is not available in the scope in which the field is defined.\u003cbr\u003e\nReferencing dynamic fields needs to be done using\n\u003ca href=\"/docs/tour/references/selectors/\"\u003eselectors, index expressions\u003c/a\u003e,\nor \u003ca href=\"/docs/tour/references/aliases/\"\u003ealiases\u003c/a\u003e.\u003c/p\u003e",
        "content": "A dynamic field is a field whose name, or label, is determined by an expression wrapped in parentheses or through string interpolation: (a + b) or \u0026quot;\\(a + b)\u0026quot;. A dynamic field\u0026rsquo;s identifier is not available in the scope in which the field is defined. Referencing dynamic fields needs to be done using selectors, index expressions, or aliases. Copied! file.cue Copy code Copied! a: \u0026#34;foo\u0026#34; b: \u0026#34;bar\u0026#34; (a + b): \u0026#34;foobar\u0026#34; s: X={ \u0026#34;\\(a)_and_\\(b)\u0026#34;: \u0026#34;foobar\u0026#34; // Valid references using a selector and // an index expression. FooAndBar: s.foo_and_bar FooAndBar: X[\u0026#34;foo_and_bar\u0026#34;] // Invalid reference because the // indentifer is not in scope. //FooAndBar: foo_and_bar } // Valid reference using an index expression. FooAndBar: s[\u0026#34;foo_and_bar\u0026#34;] TERMINAL Copy code Copied! $ cue eval file.cue a: \u0026#34;foo\u0026#34; b: \u0026#34;bar\u0026#34; foobar: \u0026#34;foobar\u0026#34; s: { foo_and_bar: \u0026#34;foobar\u0026#34; FooAndBar: \u0026#34;foobar\u0026#34; } FooAndBar: \u0026#34;foobar\u0026#34;",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a523f2284fe389ce7332c1304478aa49_1",
        "title": "Go",
        "link": "/docs/integration/go/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "The content on this page has largely been superseded by \u0026ldquo;How CUE works with Go\u0026rdquo;. CUE is not specific to Go, or to cloud applications, but like many of new cloud technologies, CUE is written in Go. It has a rich set of APIs available to Go developers and interacts with CUE in various ways.\nThe CUE APIs The CUE APIs in the main repo are organized as follows:",
        "content": "The content on this page has largely been superseded by \u0026ldquo;How CUE works with Go\u0026rdquo;. CUE is not specific to Go, or to cloud applications, but like many of new cloud technologies, CUE is written in Go. It has a rich set of APIs available to Go developers and interacts with CUE in various ways. The CUE APIs The CUE APIs in the main repo are organized as follows: cmd: The CUE command line tool. cue: core APIs related to parsing, formatting, loading and running CUE programs. These packages are used by all other packages, including the command line tool. encoding: Packages for converting to and from CUE, including adaptors for YAML, JSON, Go, Protobuf, and OpenAPI. pkg: Builtin packages that are available from within CUE programs. These are typically not used in Go code. Extract CUE from Go Download CUE definitions from Go packages Many of today\u0026rsquo;s cloud-related projects are written in Go. The cue get go fetches Go packages using Go\u0026rsquo;s package manager and makes their definitions available through the CUE module\u0026rsquo;s pkg directory using the same package naming conventions as in Go. For example, to download the CUE definitions for the core Kubernetes types, run Copy code Copied! cue get go k8s.io/api/core/v1 From the root of your CUE module, you will now see ./pkg/k8s.io/api/core populated with the extracted CUE definitions. Projects, like Kubernetes, do not have to support such conversions. CUE derives the interpretation by analyzing how the Go types convert with encoding/json. Mixing manually-created and generated files The files that the cue tool generates all end with _go_gen.cue. The cue tool will never create, remove, or modify files not ending with _gen.go, so it safe to add such files in these directories to further tighten down definitions. Remember that the order in which files get merged is irrelevant for CUE. The generated package can be used in CUE using the same import path. In this CUE file, we import the generated definitions and specify that all services in our configuration are of type v1.Service. Copy code Copied! import \u0026#34;k8s.io/api/core/v1\u0026#34; services: [string]: v1.#Service You can download definitions from any Go project like this. For example, try k8s.io/api/extensions/v1beta1 or github.com/prometheus/prometheus/pkg/rulefmt. Processing CUE in Go Load CUE into Go There are two primary ways to load CUE into Go. To load entire packages, consistent with the cue tool, use the cuelang.org/go/cue/load package. To load CUE parse trees or raw CUE text, use a cuelang.org/go/cue.Runtime. Use a single Runtime For any operation that involves two CUE values these two values must have been created using the same Runtime. The following code loads an embedded CUE configuration, evaluates one of its fields, and prints the result. Copy code Copied! const config = ` msg: \u0026#34;Hello \\(place)!\u0026#34; place: string | *\u0026#34;world\u0026#34; // \u0026#34;world\u0026#34; is the default. ` var r cue.Runtime instance, _ := r.Compile(\u0026#34;test\u0026#34;, config) str, _ := instance.Lookup(\u0026#34;msg\u0026#34;).String() fmt.Println(str) // Output: // Hello world! The names passed to Compile get recorded as references in token positions. Validate Go values The Codec type in package cuelang.org/go/encoding/gocode/gocodec provides the Validate method for validating Go values. Copy code Copied! var codec = gocodec.New(r, nil) var myValueConstraints cue.Value func (x *MyValue) Validate() error { return codec.Validate(myValueConstraints, x) } Package cuelang.org/go/encoding/gocode, discussed below, can generate these kind of stubs to make life a bit easier. Complete Go values A gocodec.Codec also defines a Complete method, which is similar to Validate, but fills in missing values if these can be derived from the CUE definitions. Combine CUE values The cue.Value\u0026rsquo;s Unify method can be used to merge two values. It is the programmatic equivalent of the \u0026amp; operation in the CUE language. With Unify one can combine constraints from multiple sources programmatically. For instance, one could add some context-dependent policy constraints to a set of base constraints. Copy CUE values into Go values The simplest way to set a Go value to the contents of a CUE value is to use the Decode method of the later. Copy code Copied! type ab struct{ A, B int } var r cue.Runtime var x ab i, _ := r.Compile(\u0026#34;test\u0026#34;, `{A: 2, B: 4}`) _ = i.Value().Decode(\u0026amp;x) fmt.Println(x) i, _ = r.Compile(\u0026#34;test\u0026#34;, `{B: \u0026#34;foo\u0026#34;}`) _ = i.Value().Decode(\u0026amp;x) fmt.Println(x) // Output: // {2 4} // json: cannot unmarshal string into Go struct field ab.B of type int Package cuelang.com/go/encoding/gocode/gocodec gives a bit more control over encoding and allows incorporating Go field tags with constraints as well as deriving unspecified values from constraints. Modify CUE values A field in a CUE instance can be set to a Go value that conforms to the constraints of this instance using the Fill method. Building on the example of the \u0026ldquo;Load CUE into Go\u0026rdquo; section, we can write Copy code Copied! inst, _ := instance.Fill(\u0026#34;you\u0026#34;, \u0026#34;place\u0026#34;) str, _ = inst.Lookup(\u0026#34;msg\u0026#34;).String() fmt.Println(str) // Output: // Hello you! To ensure the integrity of references with the CUE instance, modifications are only allowed at the whole-instance level. Generate Go code Programmatically The Generate function in package cuelang.org/go/encoding/gocode generates stubs for validation functions and method from a given CUE instance. It does so by lining up the top-level CUE names with Go definitions. The CUE code can use field tags, similar to those used in Go, to override the naming. Copy code Copied! b, err := gocode.Generate(\u0026#34;path/to/go/pkg\u0026#34;, instance, nil) if err != nil { // handle error } err = os.WriteFile(\u0026#34;cue_gen.go\u0026#34;, b, 0644)",
        "breadcrumb": ["Documentation","Integrations"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "d2cdbdae8c7d16de5aecc3e37e2a8484_1",
        "title": "JSON Superset",
        "link": "/docs/tour/basics/json-superset/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn its simplest form, CUE looks a lot like JSON.\nThis is because CUE is a superset of JSON.\u003cbr\u003e\nOr, put differently: \u003cstrong\u003eall valid JSON is CUE\u003c/strong\u003e (but not vice versa).\u003c/p\u003e\n\u003cp\u003eCUE significantly reduces the pain of dealing with JSON\nby introducing several conveniences, including:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC-style \u003cstrong\u003ecomments\u003c/strong\u003e are allowed\u003c/li\u003e\n\u003cli\u003efield names without special characters don\u0026rsquo;t need to be quoted\u003c/li\u003e\n\u003cli\u003ecommas after a field are optional (and are usually omitted)\u003c/li\u003e\n\u003cli\u003ecommas after the final element of a list are allowed\u003c/li\u003e\n\u003cli\u003ethe outermost curly braces in a CUE file are optional\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJSON \u003cem\u003eobjects\u003c/em\u003e are called \u003cstrong\u003estructs\u003c/strong\u003e or \u003cstrong\u003emaps\u003c/strong\u003e in CUE.\nJSON \u003cem\u003earrays\u003c/em\u003e are called \u003cstrong\u003elists\u003c/strong\u003e\u003cbr\u003e\nObject \u003cem\u003emembers\u003c/em\u003e are called \u003cstrong\u003efields\u003c/strong\u003e, which link their \u003cstrong\u003ename\u003c/strong\u003e, or \u003cstrong\u003elabel\u003c/strong\u003e, to a \u003cstrong\u003evalue\u003c/strong\u003e.\u003c/p\u003e",
        "content": "In its simplest form, CUE looks a lot like JSON. This is because CUE is a superset of JSON. Or, put differently: all valid JSON is CUE (but not vice versa). CUE significantly reduces the pain of dealing with JSON by introducing several conveniences, including: C-style comments are allowed field names without special characters don\u0026rsquo;t need to be quoted commas after a field are optional (and are usually omitted) commas after the final element of a list are allowed the outermost curly braces in a CUE file are optional JSON objects are called structs or maps in CUE. JSON arrays are called lists Object members are called fields, which link their name, or label, to a value. Throughout this tour there are examples that show some CUE, a command that processes it, and then the command\u0026rsquo;s output - with each pane featuring a mouseover button that copies the related text to your clipboard. Here\u0026rsquo;s an example that uses cue export to turn file.cue into JSON. Copied! file.cue Copy code Copied! import \u0026#34;math\u0026#34; // Simple labels don\u0026#39;t need to be quoted. one: 1 two: 2 piPlusOne: math.Pi + 1 // Field names must be quoted if they contain // special characters, such as hyphen and space. \u0026#34;quoted field names\u0026#34;: { \u0026#34;two-and-a-half\u0026#34;: 2.5 \u0026#34;three point three\u0026#34;: 3.3 \u0026#34;four^four\u0026#34;: math.Pow(4, 4) } aList: [ 1, 2, 3, ] TERMINAL Copy code Copied! $ cue export file.cue --out json { \u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;piPlusOne\u0026#34;: 4.141592653589793238462643383279503, \u0026#34;quoted field names\u0026#34;: { \u0026#34;two-and-a-half\u0026#34;: 2.5, \u0026#34;three point three\u0026#34;: 3.3, \u0026#34;four^four\u0026#34;: 256 }, \u0026#34;aList\u0026#34;: [ 1, 2, 3 ] }",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "60e9def31652ab77aff2786a768aeeb8_1",
        "title": "Modules",
        "link": "/docs/concept/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eModules are how CUE manages native dependencies.\nThey can be published to a registry, which allows users to fetch and work with their contents.\u003c/p\u003e\n\u003cp\u003eLearn about modules using these recommended guides, or\nbrowse through all the \u003ca href=\"/search?q=tag:modules\"\n        class=\"tag tag--inline tag--red\"\u003e\n            modules\n        \u003c/a\u003e pages listed below:\u003c/p\u003e",
        "content": "Modules are how CUE manages native dependencies. They can be published to a registry, which allows users to fetch and work with their contents. Learn about modules using these recommended guides, or browse through all the modules pages listed below: Recommended guides Reference manual The CUE modules reference manual and glossary reference/manual reference/manual Concept Guide CUE\u0026rsquo;s \u0026ldquo;new\u0026rdquo; versus \u0026ldquo;old\u0026rdquo; modules \u0026ndash; your questions: answered concept/faq concept/faq The cue command The built-in help text for cue help modules reference/command/cue reference/command/cue Getting started Working with the CUE Central Registry tutorial tutorial Collaborate Publishing modules to the Central Registry tutorial tutorial Private infrastructure Working with a custom module registry tutorial tutorial All pages tagged \u0026ldquo;modules\u0026rdquo; documents found Filters \u0026#9432; Tags Filter by tags Filter tags Loading No tags found Content Type Filter by Content Type Filter Content Type Loading No Content Type\u0026#39;s found",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "695bda962a2d1b111be424c5bea9c9a0_1",
        "title": "New to CUE?",
        "link": "/docs/tutorial/new-to-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"welcome\"\u003e\n    \u003ca href=\"#welcome\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eThese tutorials are good places to start for folks who are newcomers to CUE \u0026hellip;\u003c/p\u003e",
        "content": "Welcome! These tutorials are good places to start for folks who are newcomers to CUE \u0026hellip; Validating simple YAML files with the cue command",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a9d67ae0e96d19fbc560d14813b94315_1",
        "title": "Numbers",
        "link": "/docs/tour/types/numbers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE defines two types of numbers, \u003cstrong\u003eintegers\u003c/strong\u003e and \u003cstrong\u003efloats\u003c/strong\u003e,\nand various syntactic sugar for their literal representations.\u003c/p\u003e\n\u003cp\u003eIntegers, denoted \u003ccode\u003eint\u003c/code\u003e, are whole (or integral) numbers.\nFloats, denoted \u003ccode\u003efloat\u003c/code\u003e, are decimal floating point numbers.\nBoth integers and floats are instances of the generic \u003ccode\u003enumber\u003c/code\u003e type.\nCUE numbers have arbitrary precision.\u003c/p\u003e\n\u003cp\u003eAn integer literal (e.g. \u003ccode\u003e4\u003c/code\u003e) is only compatible with \u003ccode\u003eint\u003c/code\u003e.\u003cbr\u003e\nA floating point literal (e.g. \u003ccode\u003e5.0\u003c/code\u003e) is only compatible with \u003ccode\u003efloat\u003c/code\u003e,\neven if it is a whole number.\u003c/p\u003e",
        "content": "CUE defines two types of numbers, integers and floats, and various syntactic sugar for their literal representations. Integers, denoted int, are whole (or integral) numbers. Floats, denoted float, are decimal floating point numbers. Both integers and floats are instances of the generic number type. CUE numbers have arbitrary precision. An integer literal (e.g. 4) is only compatible with int. A floating point literal (e.g. 5.0) is only compatible with float, even if it is a whole number. Copied! file.cue Copy code Copied! a: 4 \u0026amp; int // int type b: 5.0 \u0026amp; float // float type c: 4 \u0026amp; number // int type d: 5.0 \u0026amp; number // float type e: 4 \u0026amp; float // Type mismatch f: 5.0 \u0026amp; int // Type mismatch // Syntactic sugar for numeric literals. s: [ // ints 1_234, // 1234 5M, // 5_000_000 1.5Gi, // 1_610_612_736 0x1000_0000, // 268_435_456 1e6, // 1_000_000 // floats 000072.40, // 72.40 6.67428e-11, // 0.0000000000667428 ] TERMINAL Copy code Copied! $ cue eval -i file.cue a: 4 b: 5.0 c: 4 d: 5.0 e: _|_ // e: conflicting values 4 and float (mismatched types int and float) f: _|_ // f: conflicting values 5.0 and int (mismatched types float and int) s: [1_234, 5M, 1.5Gi, 0x1000_0000, 1e6, 000072.40, 6.67428e-11]",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "6ee84987bb37dfa516cd8a15bf8df513_1",
        "title": "Output",
        "link": "/docs/concept/using-the-cue-export-command/output/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBy default, a successful \u003ccode\u003ecue export\u003c/code\u003e displays the evaluation result on its\nstandard output stream, encoded in JSON:\u003c/p\u003e",
        "content": "By default, a successful cue export displays the evaluation result on its standard output stream, encoded in JSON: Copied! data.cue Copy code Copied! package one nested: data: true aList: [1, 2.2, \u0026#34;3.33\u0026#34;] TERMINAL Copy code Copied! $ cue export { \u0026#34;nested\u0026#34;: { \u0026#34;data\u0026#34;: true }, \u0026#34;aList\u0026#34;: [ 1, 2.2, \u0026#34;3.33\u0026#34; ] } Output location: --outfile You can place the output from a successful cue export invocation in a file instead of the standard output stream default by using the --outfile (-o) flag. The flag accepts a single value: the name of a file that will receive the result of the command. The file\u0026rsquo;s name is resolved relative to the current working directory, and must be inside a directory that already exists. If the file already exists and the --force (-f) flag is not present then the cue export command will fail. The pseudo-filename of \u0026ldquo;-\u0026rdquo; can also be used to refer to the command\u0026rsquo;s standard output stream explicitly. Copied! 1.cue Copy code Copied! package one data: { value: \u0026#34;A string\u0026#34; list: [1, 2] } TERMINAL Copy code Copied! $ cue export --outfile data.yml $ cat data.yml data: value: A string list: - 1 - 2 By default, the data emitted into the named file is encoded in the format inferred from its filename suffix. For example JSON is emitted if the filename ends in .json, YAML is emitted for .yml or .yaml, text for .txt, and so on. See cue help filetypes for the full list of suffixes that the cue command recognises. The text encoding can only handle data values that are of type string: Copied! 1.cue Copy code Copied! package one data: { value: \u0026#34;A string\u0026#34; list: [1, 2] } TERMINAL Copy code Copied! $ cue export --outfile data.txt -e data.value $ cat data.txt A string Binary data can also be emitted, but because there isn\u0026rsquo;t a standardised filename suffix for this format it must be explicitly requested using the --out flag, as demonstrated later. The binary encoding can only handle string or bytes types. cue export fails with an error if asked to encode other data types as text or binary. Information on the encodings and filetypes supported by the cue command is available in cue help filetypes. That page documents data, graph, and schema encodings, of which the cue export command can only emit data encodings. Outputs using graph and schema encodings are supported by the cue def and cue eval commands. Output encoding: --out As you saw above, the cue export command outputs data encoded as JSON, by default, or encoded in the format inferred from the filename suffix passed to the --outfile (-o) flag. To change this behaviour, use the --out flag to specify the output encoding explicitly. You can specify any data encoding documented in cue help filetypes. When used without the --outfile (-o) flag, the value of the --out flag specifies the encoding of the output that\u0026rsquo;s printed to the command\u0026rsquo;s standard output stream: Copied! data.cue Copy code Copied! package one nested: data: true aList: [1, 2.2, \u0026#34;3.33\u0026#34;] TERMINAL Copy code Copied! $ cue export --out yaml nested: data: true aList: - 1 - 2.2 - \u0026#34;3.33\u0026#34; An output file\u0026rsquo;s encoding can also be specified explicitly using the --out flag. Use this if the required data encoding doesn\u0026rsquo;t match the filename\u0026rsquo;s suffix: Copied! 1.cue Copy code Copied! package one data: { value: \u0026#34;A string\u0026#34; list: [1, 2] } TERMINAL Copy code Copied! $ cue export --outfile datafile --out json $ cat datafile { \u0026#34;data\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;A string\u0026#34;, \u0026#34;list\u0026#34;: [ 1, 2 ] } } Output location and encoding: --outfile Any combination of output location and data encoding can be specified using a qualifier with the --outfile (-o) flag. Qualifiers are described in cue help filetypes, and can be used to prefix a filename with its required encoding, separated by a colon: Copied! 1.cue Copy code Copied! package one data: { value: \u0026#34;A string\u0026#34; list: [1, 2] } TERMINAL Copy code Copied! $ cue export --outfile json:datafile $ cat datafile { \u0026#34;data\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;A string\u0026#34;, \u0026#34;list\u0026#34;: [ 1, 2 ] } } As mentioned above, the pseudo-filename of \u0026ldquo;-\u0026rdquo; can be used to refer to the command\u0026rsquo;s standard output stream. Because this filename doesn\u0026rsquo;t have a suffix its encoding must be specified \u0026ndash; either using --out, or using --outfile with a qualifier: Copied! data.cue Copy code Copied! package one nested: data: true aList: [1, 2.2, \u0026#34;3.33\u0026#34;] TERMINAL Copy code Copied! $ cue export --outfile yaml:- nested: data: true aList: - 1 - 2.2 - \u0026#34;3.33\u0026#34; Emitting CUE The cue export command can emit CUE when the --out flag is passed the value \u0026ldquo;cue\u0026rdquo;, or when the output filename ends .cue, or when a cue: qualifier is used with --outfile: Copied! data.cue Copy code Copied! package one nested: data: true aList: [1 + 1, 2 * 2, 3 / 3] TERMINAL Copy code Copied! $ cue export --out cue nested: data: true aList: [2, 4, 1.0] When emitting data encoded as CUE, as with all cue export invocations, the command succeeds only when the value being emitted is concrete. This means that the CUE emitted by cue export will contain only fields that contain fully-specified values. Additionally, the CUE that cue export emits will contain only regular fields. Any hidden fields, definitions, comprehensions, and other CUE language features will not be present, except insofar as their values affect regular fields: Copied! data.cue Copy code Copied! package one #A: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] _B: [1, 2, 3] C: [ for a in #A for b in _B { \u0026#34;\\(a)-\\(b)\u0026#34; }, ] TERMINAL Copy code Copied! $ cue export --out cue C: [\u0026#34;a-1\u0026#34;, \u0026#34;a-2\u0026#34;, \u0026#34;a-3\u0026#34;, \u0026#34;b-1\u0026#34;, \u0026#34;b-2\u0026#34;, \u0026#34;b-3\u0026#34;, \u0026#34;c-1\u0026#34;, \u0026#34;c-2\u0026#34;, \u0026#34;c-3\u0026#34;] When emitting CUE, cue export defaults to producing CUE that does not belong to any package, regardless of the package(s) being evaluated. This behaviour can be changed using the --package (-p) flag: Copied! data.cue Copy code Copied! package one nested: data: true aList: [1 + 1, 2 * 2, 3 / 3] TERMINAL Copy",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "6ee84987bb37dfa516cd8a15bf8df513_2",
        "title": "Output",
        "link": "/docs/concept/using-the-cue-export-command/output/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBy default, a successful \u003ccode\u003ecue export\u003c/code\u003e displays the evaluation result on its\nstandard output stream, encoded in JSON:\u003c/p\u003e",
        "content": "code Copied! $ cue export --out cue --package foo package foo nested: data: true aList: [2, 4, 1.0] Escaping HTML When you include the --escape flag in a cue export invocation, string values containing the characters \u0026amp;, \u0026lt;, or \u0026gt; are emitted with these characters replaced by their escaped unicode code point equivalents: Copied! data.cue Copy code Copied! package one someHTML: \u0026#34;\u0026#34;\u0026#34; \u0026lt;a href=\u0026#34;https://cue.example?foo=bar\u0026amp;baz=quux\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; \u0026#34;\u0026#34;\u0026#34; TERMINAL Copy code Copied! $ cue export --escape { \u0026#34;someHTML\u0026#34;: \u0026#34;\\u003ca href=\\\u0026#34;https://cue.example?foo=bar\\u0026baz=quux\\\u0026#34;\\u003e...\\u003c/a\\u003e\u0026#34; } This feature can also be useful when emitting structured data that\u0026rsquo;s intended to be placed inside an HTML document. Conclusion This guide showed you how to use cue export, and the ways in which you can customize its inputs, operation, and output. The command is often used to produce configurations for commands that require JSON, YAML, TOML, or other encodings \u0026ndash; you can read more about this common task in How CUE enables configuration. Related content Reference: The cue export command Reference: cue help filetypes Reference: cue help eval Reference: cue help def Concept Guide: How CUE enables configuration.",
        "breadcrumb": ["Documentation","Concept Guides","Using the cue export command"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2941738e8767e4de37ae09552000d202_1",
        "title": "Standard Library",
        "link": "/docs/tour/packages/standard-library/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe CUE \u003cstrong\u003estandard library\u003c/strong\u003e is always available for use through an \u003ccode\u003eimport\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eCUE comes with a fully featured set of built-in packages containing functions\nthat perform a wide array of deterministic tasks.\nThe\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg#pkg-overview\"\u003estandard library package overview\u003c/a\u003e\nlinks to details and examples for each package.\u003c/p\u003e",
        "content": "The CUE standard library is always available for use through an import statement. CUE comes with a fully featured set of built-in packages containing functions that perform a wide array of deterministic tasks. The standard library package overview links to details and examples for each package. Some commonly used packages include: list: functions for manipulating and examining lists strings: functions for manipulating UTF-8 encoded strings regexp: regular expression search math: standard mathematical functions and constants encoding/base64: functions for encoding and decoding data in the RFC4648 Base64 encoding scheme encoding/json \u0026amp; encoding/yaml: functions for encoding, decoding, and validating data stored as JSON and YAML Many of the standard library\u0026rsquo;s functions are also demonstrated in how-to guides, here on cuelang.org.",
        "breadcrumb": ["Documentation","Tour","Packages and Imports"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "2c1938025a1224a6506a8d481ee4a5c6_1",
        "title": "Tutorials",
        "link": "/docs/tutorial/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE tutorials are practical lessons that help you try out language features,\nworkflows, and tools in practice settings on your own computer.\u003c/p\u003e\n\u003cp\u003eIf you\u0026rsquo;re new to CUE then start by reading the\n\u003ca href=\"/docs/tour/\"\u003eCUE Tour\u003c/a\u003e, and \u003c!-- TODO:postLG\n[Language Guide]({{\u003c relref \"docs/language-guide\" \u003e}}), and --\u003e\nthen try out some tutorials specially\n\u003ca href=\"/docs/tutorial/new-to-cue/\"\u003echosen for you\u003c/a\u003e.\u003c/p\u003e",
        "content": "CUE tutorials are practical lessons that help you try out language features, workflows, and tools in practice settings on your own computer. If you\u0026rsquo;re new to CUE then start by reading the CUE Tour, and then try out some tutorials specially chosen for you. Use this interface to browse and search through the contents, titles, examples, and tags of the tutorials, and to narrow down the list of tutorials to a specific topic: documents found Filters \u0026#9432; Tags Filter by tags Filter tags Loading No tags found",
        "breadcrumb": ["Documentation"],
        "contentType": "Tutorials",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "2493dd54a11aeecbdd6bf2d59af3dd6c_1",
        "title": "Conditional Fields",
        "link": "/docs/tour/expressions/conditional/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eField comprehensions can be used to add fields conditionally.\u003c/p\u003e",
        "content": "Field comprehensions can be used to add fields conditionally. Copied! file.cue Copy code Copied! price: number // High prices require a reason and the name of // the authorising person. if price \u0026gt; 100 { reason!: string authorisedBy!: string } Copied! stock.yaml Copy code Copied! price: 200 TERMINAL Copy code Copied! $ cue export file.cue stock.yaml authorisedBy: field is required but not present reason: field is required but not present When cue export processes multiple files it unifies their contents. The value of the price field in stock.yaml is available inside file.cue, and triggers the conditional inclusion of the required fields.",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "eb2a3f68daa6d5618350209794c9e981_1",
        "title": "Emitting Values",
        "link": "/docs/tour/references/emit/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBy default all top-level fields are emitted when evaluating a configuration.\n\u003cstrong\u003eEmbedding\u003c/strong\u003e a value at the top level causes that value to be emitted instead.\u003c/p\u003e\n\u003c!-- TODO review wording as per https://review.gerrithub.io/c/cue-lang/cuelang.org/+/1177811/comment/137a1163_00573a78/ --\u003e\n\u003cp\u003eThis allows CUE configurations to define any type or value at the top level\n(just like JSON), whilst keeping CUE optimised for the most common use case of\ndefining structs.\u003c/p\u003e",
        "content": "By default all top-level fields are emitted when evaluating a configuration. Embedding a value at the top level causes that value to be emitted instead. This allows CUE configurations to define any type or value at the top level (just like JSON), whilst keeping CUE optimised for the most common use case of defining structs. Copied! file.cue Copy code Copied! \u0026#34;Hello, \\(#who)!\u0026#34; #who: \u0026#34;world\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue \u0026#34;Hello, world!\u0026#34;",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "b5d950bec2bd2baa503b4f9c9b35dc23_1",
        "title": "How-to Guides",
        "link": "/docs/howto/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eHow-to guides contain either step-by-step instructions or stand-alone CUE.\nThey demonstrate how to achieve specific outcomes with the CUE language or its\ntooling, and include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/search?q=tag:tooling\"\n        class=\"tag tag--inline tag--orange\"\u003e\n            tooling\n        \u003c/a\u003e \u0026ndash; guides that demonstrate how to use CUE tools\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/search?q=tag:%22commented%20cue%22\"\n        class=\"tag tag--inline tag--pink\"\u003e\n            commented cue\n        \u003c/a\u003e \u0026ndash; guides that illustrate CUE language features\nand techniques through\n\u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003estand-alone examples\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/search?q=tag:encodings\"\n        class=\"tag tag--inline tag--green\"\u003e\n            encodings\n        \u003c/a\u003e \u0026ndash; guides that explain how to encode and decode\ninformation stored in languages other than CUE\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "How-to guides contain either step-by-step instructions or stand-alone CUE. They demonstrate how to achieve specific outcomes with the CUE language or its tooling, and include: tooling \u0026ndash; guides that demonstrate how to use CUE tools commented cue \u0026ndash; guides that illustrate CUE language features and techniques through stand-alone examples encodings \u0026ndash; guides that explain how to encode and decode information stored in languages other than CUE Use this interface to browse and search through the contents, titles, examples, and tags of the guides, and to narrow down the list of guides to a specific topic: documents found Filters \u0026#9432; Tags Filter by tags Filter tags Loading No tags found",
        "breadcrumb": ["Documentation"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "e4e2de2463f9bdd9d8bafb39b3ad4dc4_1",
        "title": "OpenAPI",
        "link": "/docs/integration/openapi/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Integrations"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "d3a08dc11b3e7c4f1922b39ee5e92941_1",
        "title": "Strings",
        "link": "/docs/tour/types/stringlit/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eStrings\u003c/strong\u003e are instances of the \u003ccode\u003estring\u003c/code\u003e type.\nString literals are defined within double quotes.\u003c/p\u003e\n\u003cp\u003eStrings allow a rich set of escape sequences,\nincluding Unicode code points\nand \u003ca href=\"/docs/tour/expressions/interpolation/\"\u003einterpolations\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCUE also supports multi-line strings, enclosed between a pair of triple quotes (\u003ccode\u003e\u0026quot;\u0026quot;\u0026quot;\u003c/code\u003e).\nThe opening quotes of a multi-line string must be immediately followed by a newline,\nand the closing quotes must be on a line by themselves, optionally preceded by whitespace.\u003c/p\u003e",
        "content": "Strings are instances of the string type. String literals are defined within double quotes. Strings allow a rich set of escape sequences, including Unicode code points and interpolations. CUE also supports multi-line strings, enclosed between a pair of triple quotes (\u0026quot;\u0026quot;\u0026quot;). The opening quotes of a multi-line string must be immediately followed by a newline, and the closing quotes must be on a line by themselves, optionally preceded by whitespace. Copied! file.cue Copy code Copied! a: \u0026#34;\\U0001F60E\u0026#34; // A 21-bit Unicode character. b: \u0026#34;\u0026#34;\u0026#34; This is a multi-line string \\(a) \u0026#34;\u0026#34;\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;a\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;This is a\\nmulti-line string \u0026#34; } Any whitespace prefix before the closing quotes of a multi-line string must also be the prefix for all non-empty lines between the quotes. The whitespace prefix is removed from all lines in the string, and it is an error for a non-empty line to start with any other characters.",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4359723c5cadf6897f2dd16881f39231_1",
        "title": "\"Raw\" Strings",
        "link": "/docs/tour/types/stringraw/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE doesn\u0026rsquo;t strictly support raw strings.\nInstead, the default escape delimiter (\u003ccode\u003e\\\u003c/code\u003e) can be modified for a specific string.\u003c/p\u003e\n\u003cp\u003eThe escape delimiter for a string can be modified to add\nan arbitrary number of trailing hash symbols to the default.\u003cbr\u003e\nIt is changed by \u003cem\u003esurrounding\u003c/em\u003e the string with the required number of hash symbols:\n\u003ccode\u003e#\u0026quot;string value\u0026quot;#\u003c/code\u003e.\u003c/p\u003e",
        "content": "CUE doesn\u0026rsquo;t strictly support raw strings. Instead, the default escape delimiter (\\) can be modified for a specific string. The escape delimiter for a string can be modified to add an arbitrary number of trailing hash symbols to the default. It is changed by surrounding the string with the required number of hash symbols: #\u0026quot;string value\u0026quot;#. Copied! file.cue Copy code Copied! // Changing the escape delimiter can simplify strings. // These two lines specify the same string, but the first line // is easier to read because of its modified escape delimiter. A: #\u0026#34;The hazard symbol \\#U00002622 is Unicode code point \u0026#34;\\U00002622\u0026#34;.\u0026#34;# A: \u0026#34;The hazard symbol \\U00002622 is Unicode code point \\\u0026#34;\\\\U00002622\\\u0026#34;.\u0026#34; // Making the escape delimiter longer can simplify // representations of shorter escape delimeters. B: ##\u0026#34;\u0026#34;\u0026#34; A regular expression can conveniently be written as: #\u0026#34;\\d{3}\u0026#34;# This construct works for bytes, strings and their multi-line variants. \u0026#34;\u0026#34;\u0026#34;## TERMINAL Copy code Copied! $ cue export file.cue --out yaml A: The hazard symbol  is Unicode code point \u0026#34;\\U00002622\u0026#34;. B: |- A regular expression can conveniently be written as: #\u0026#34;\\d{3}\u0026#34;# This construct works for bytes, strings and their multi-line variants. Both normal and multi-line strings allow their delimeters to be modified in this way. The change affects all types of escape, including Unicode code points and interpolations. Changing a string\u0026rsquo;s escape delimiter is particularly useful when encoding strings containing quotes or backslashes, as neither character needs to be escaped in such strings.",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "292d5361efce080c4c5f12138885c5d6_1",
        "title": "Concept Guides",
        "link": "/docs/concept/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eConcept guides explain the systems and ideas that drive CUE\u0026rsquo;s design.\nThey explore the foundations and implications of CUE\u0026rsquo;s theoretical basis in\ndepth, and provide background information to help the CUE user discover how\nbest to take advantage of its unique and powerful features.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/docs/concept/popular-guides/\"\u003ePopular guides\u003c/a\u003e page contains a curated\nlist of concept guides.\nYou can also use the following index to browse through the full range of concept guides,\nor to search inside them for specific content, titles, and tags:\u003c/p\u003e",
        "content": "Concept guides explain the systems and ideas that drive CUE\u0026rsquo;s design. They explore the foundations and implications of CUE\u0026rsquo;s theoretical basis in depth, and provide background information to help the CUE user discover how best to take advantage of its unique and powerful features. The Popular guides page contains a curated list of concept guides. You can also use the following index to browse through the full range of concept guides, or to search inside them for specific content, titles, and tags: documents found Filters \u0026#9432; Tags Filter by tags Filter tags Loading No tags found",
        "breadcrumb": ["Documentation"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "3c690f148355cccb4182e72aa14d8d8e_1",
        "title": "List Comprehensions",
        "link": "/docs/tour/expressions/listcomp/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eLists can be specified using \u003cstrong\u003elist comprehensions\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eList comprehensions are constructed from\n\u003ccode\u003efor\u003c/code\u003e loops, \u003ccode\u003eif\u003c/code\u003e guards, and \u003ccode\u003elet\u003c/code\u003e declarations.\u003cbr\u003e\nThey can be combined in any order,\non a single line or split across multiple lines.\u003c/p\u003e",
        "content": "Lists can be specified using list comprehensions. List comprehensions are constructed from for loops, if guards, and let declarations. They can be combined in any order, on a single line or split across multiple lines. Copied! file.cue Copy code Copied! #n: [1, 2, 3, 4, 5, 6, 7, 8, 9] #s: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] // Large square numbers. a: [ for x in #n let s = x * x if s \u0026gt; 50 {s}, ] // Squares of even numbers. b: [for x in #n if rem(x, 2) == 0 {x * x}] // The Cartesian product of two lists. c: [ for letter in #s for number in #n if number \u0026lt; 3 { \u0026#34;\\(letter)-\\(number)\u0026#34; }, ] TERMINAL Copy code Copied! $ cue export file.cue --out cue // Large square numbers. a: [64, 81] // Squares of even numbers. b: [4, 16, 36, 64] // The Cartesian product of two lists. c: [\u0026#34;a-1\u0026#34;, \u0026#34;a-2\u0026#34;, \u0026#34;b-1\u0026#34;, \u0026#34;b-2\u0026#34;, \u0026#34;c-1\u0026#34;, \u0026#34;c-2\u0026#34;]",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "96dad1307b568b46268f637031b11a94_1",
        "title": "Protocol Buffers",
        "link": "/docs/integration/protobuf/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Integrations"],
        "contentType": "Integrations",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "515e63935fa76c446c3071f645309494_1",
        "title": "Reference Cycles",
        "link": "/docs/tour/references/cycle/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE can handle many types of \u003cstrong\u003ecycle\u003c/strong\u003e, resolving and inferring values that\ndepend on each other.\u003c/p\u003e\n\u003cp\u003eBecause all values are final in CUE, a field with a concrete value\n(e.g. \u003ccode\u003e200\u003c/code\u003e) can only be valid if it \u003cem\u003e\u003cstrong\u003eis\u003c/strong\u003e\u003c/em\u003e that value.\nIf CUE sees this concrete value being unified with some other expression then\nthe evaluation of that expression is postponed, which often allows cycles to be\nbroken.\u003c/p\u003e\n\u003cp\u003eThis can prove useful for template authors who know that a user will provide\none out of several fields, but they may not know \u003cem\u003ewhich\u003c/em\u003e one.\u003c/p\u003e",
        "content": "CUE can handle many types of cycle, resolving and inferring values that depend on each other. Because all values are final in CUE, a field with a concrete value (e.g. 200) can only be valid if it is that value. If CUE sees this concrete value being unified with some other expression then the evaluation of that expression is postponed, which often allows cycles to be broken. This can prove useful for template authors who know that a user will provide one out of several fields, but they may not know which one. Copied! file.cue Copy code Copied! x: 200 // This cycle can be resolved because of the // concrete value specified above. x: y + 100 y: x - 100 // This cycle cannot be resolved, so \u0026#34;cue eval\u0026#34; // report the field\u0026#39;s values as their given // expressions. a: b + 100 b: a - 100 TERMINAL Copy code Copied! $ cue eval file.cue x: 200 y: 100 a: b + 100 b: a - 100 This example uses cue eval because the cycle between the a and b fields can\u0026rsquo;t be resolved. Using cue export would fail because the fields\u0026rsquo; values aren\u0026rsquo;t concrete.",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4ae1a413759fb4a646da8daeaf1f883c_1",
        "title": "The cue command",
        "link": "/docs/reference/command/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "The cue command is a versatile interface for working with CUE and its ecosystem. It provides a variety of sub-commands, including tools for validating, importing, and exporting data and constraints; for creating data-driven workflows; and for working with dependencies via CUE modules and module registries.\nOn this page you can find the full list of sub-commands in the latest version of cue, and their built-in help texts. You\u0026rsquo;ll also find an incomplete-but-expanding set of guides dedicated to the most commonly-used sub-commands.",
        "content": "The cue command is a versatile interface for working with CUE and its ecosystem. It provides a variety of sub-commands, including tools for validating, importing, and exporting data and constraints; for creating data-driven workflows; and for working with dependencies via CUE modules and module registries. On this page you can find the full list of sub-commands in the latest version of cue, and their built-in help texts. You\u0026rsquo;ll also find an incomplete-but-expanding set of guides dedicated to the most commonly-used sub-commands. These guides include curated links to related content, including how-to guides, tutorials and other relevant documentation. Guides Dedicated guides for common cue sub-commands: The cue export command Use cue export to produce validated, concrete data for tools that need configurations encoded in formats like JSON or YAML. Help texts The built-in help texts available in the latest version of cue:",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "aef6f0fcae2ee7c18ef600a04c20a9d7_1",
        "title": "Bytes",
        "link": "/docs/tour/types/bytes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE distinguishes the \u003cstrong\u003e\u003ccode\u003ebytes\u003c/code\u003e\u003c/strong\u003e type from the \u003ccode\u003estring\u003c/code\u003e type.\nByte literals are defined with single quotes.\u003c/p\u003e\n\u003cp\u003eIn addition to the escape sequences permitted in string literals,\nbyte literals also allow these escape sequences:\u003c/p\u003e\n\u003cdiv class=\"table\"\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:right\"\u003eSequence\u003c/th\u003e\n\u003cth\u003eResult\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:right\"\u003e\u003cstrong\u003e\u003ccode\u003e\\xnn\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eArbitrary byte value defined as the 2-digit hexadecimal number \u0026ldquo;\u003cstrong\u003e\u003ccode\u003enn\u003c/code\u003e\u003c/strong\u003e\u0026rdquo;\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:right\"\u003e\u003cstrong\u003e\u003ccode\u003e\\nnn\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eArbitrary byte value defined as the 3-digit octal number \u0026ldquo;\u003cstrong\u003e\u003ccode\u003ennn\u003c/code\u003e\u003c/strong\u003e\u0026rdquo;\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cp\u003eBytes are represented as Base64 when exporting concrete data to a format such as JSON or YAML.\u003cbr\u003e\nTo avoid this, interpolate bytes inside a string value.\u003c/p\u003e",
        "content": "CUE distinguishes the bytes type from the string type. Byte literals are defined with single quotes. In addition to the escape sequences permitted in string literals, byte literals also allow these escape sequences: Sequence Result \\xnn Arbitrary byte value defined as the 2-digit hexadecimal number \u0026ldquo;nn\u0026rdquo; \\nnn Arbitrary byte value defined as the 3-digit octal number \u0026ldquo;nnn\u0026rdquo; Bytes are represented as Base64 when exporting concrete data to a format such as JSON or YAML. To avoid this, interpolate bytes inside a string value. Copied! file.cue Copy code Copied! aString: \u0026#34;A string\u0026#34; // Multiple representations of the same underlying // bytes, which therefore unify succesfully. Bytes: \u0026#39;A string\u0026#39; Bytes: \u0026#39;\\(aString)\u0026#39; Bytes: \u0026#39;\\x41\\x20\\x73\\x74\\x72\\x69\\x6e\\x67\u0026#39; Bytes: \u0026#39;\\101\\040\\163\\164\\162\\151\\156\\147\u0026#39; stringBytes: \u0026#34;\\(Bytes)\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;aString\u0026#34;: \u0026#34;A string\u0026#34;, \u0026#34;Bytes\u0026#34;: \u0026#34;QSBzdHJpbmc=\u0026#34;, \u0026#34;stringBytes\u0026#34;: \u0026#34;A string\u0026#34; }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4e814369484b4370979513a70e597333_1",
        "title": "Cycles in Fields",
        "link": "/docs/tour/references/cycleref/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eLogically, we know that unifying any field with itself will result in an\nidentical value. Unifying \u003ccode\u003e\u0026quot;foo\u0026quot;\u003c/code\u003e with \u003ccode\u003e\u0026quot;foo\u0026quot;\u003c/code\u003e \u003cem\u003emust\u003c/em\u003e equal \u003ccode\u003e\u0026quot;foo\u0026quot;\u003c/code\u003e; unifying\nthe non-concrete value \u003ccode\u003eint\u003c/code\u003e with \u003ccode\u003eint\u003c/code\u003e must, similarly, result in \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCUE takes advantage of this property to resolve \u003cstrong\u003ecycles between fields\u003c/strong\u003e by\nsimply ignoring the cycle and then unifying the fields a single time.\nThis achieves the same result as attempting to follow the reference cycle ad\ninfinitum.\u003c/p\u003e",
        "content": "Logically, we know that unifying any field with itself will result in an identical value. Unifying \u0026quot;foo\u0026quot; with \u0026quot;foo\u0026quot; must equal \u0026quot;foo\u0026quot;; unifying the non-concrete value int with int must, similarly, result in int. CUE takes advantage of this property to resolve cycles between fields by simply ignoring the cycle and then unifying the fields a single time. This achieves the same result as attempting to follow the reference cycle ad infinitum. Copied! file.cue Copy code Copied! labels: { app: \u0026#34;foo\u0026#34; } selectors: { name: \u0026#34;bar\u0026#34; } // This cycle can be resolved. labels: selectors selectors: labels TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;labels\u0026#34;: { \u0026#34;app\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;bar\u0026#34; }, \u0026#34;selectors\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;app\u0026#34;: \u0026#34;foo\u0026#34; } }",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "500acde034429f045151f4dbbc3b7386_1",
        "title": "Field Comprehensions",
        "link": "/docs/tour/expressions/fieldcomp/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eFields can be specified using \u003cstrong\u003efield comprehensions\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eJust like\n\u003ca href=\"/docs/tour/expressions/listcomp/\"\u003elist comprehensions\u003c/a\u003e, they use\n\u003ccode\u003efor\u003c/code\u003e loops, \u003ccode\u003eif\u003c/code\u003e guards, and \u003ccode\u003elet\u003c/code\u003e declarations,\ncombined in any order.\u003c/p\u003e\n\u003cp\u003eBecause field comprehensions specify\n\u003ca href=\"/docs/tour/expressions/dynamic-fields/\"\u003edynamic fields\u003c/a\u003e,\nthese fields can\u0026rsquo;t be referenced directly\nand need to be accessed using\n\u003ca href=\"/docs/tour/references/selectors/\"\u003eselectors, index expressions\u003c/a\u003e,\nor \u003ca href=\"/docs/tour/references/aliases/\"\u003ealiases\u003c/a\u003e.\u003c/p\u003e",
        "content": "Fields can be specified using field comprehensions. Just like list comprehensions, they use for loops, if guards, and let declarations, combined in any order. Because field comprehensions specify dynamic fields, these fields can\u0026rsquo;t be referenced directly and need to be accessed using selectors, index expressions, or aliases. Copied! file.cue Copy code Copied! import \u0026#34;strings\u0026#34; #censusData: [ {name: \u0026#34;Kinshasa\u0026#34;, pop: 16_315_534}, {name: \u0026#34;Lagos\u0026#34;, pop: 15_300_000}, {name: \u0026#34;Cairo\u0026#34;, pop: 10_100_166}, {name: \u0026#34;Giza\u0026#34;, pop: 9_250_791}, ] // city maps from a city\u0026#39;s name to its details. city: { for index, value in #censusData let lower = strings.ToLower(value.name) { \u0026#34;\\(lower)\u0026#34;: { population: value.pop name: value.name position: index + 1 } } } // References via selector and index expression. gizaPopulation: city.giza.population cairoPopulation: city[\u0026#34;cairo\u0026#34;].population TERMINAL Copy code Copied! $ cue eval -c file.cue city: { kinshasa: { population: 16315534 name: \u0026#34;Kinshasa\u0026#34; position: 1 } lagos: { population: 15300000 name: \u0026#34;Lagos\u0026#34; position: 2 } cairo: { population: 10100166 name: \u0026#34;Cairo\u0026#34; position: 3 } giza: { population: 9250791 name: \u0026#34;Giza\u0026#34; position: 4 } } gizaPopulation: 9250791 cairoPopulation: 10100166",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "39745036358905423fc5359a9d7d471c_1",
        "title": "Types are Values",
        "link": "/docs/tour/basics/types-are-values/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE merges the concepts of values and types.\nIn CUE, \u003cem\u003etypes \u003cstrong\u003eare\u003c/strong\u003e values\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eA field can be specified with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea concrete value such as \u003ccode\u003e\u0026quot;foo\u0026quot;\u003c/code\u003e, \u003ccode\u003e42\u003c/code\u003e, or \u003ccode\u003etrue\u003c/code\u003e - something that could be\nrepresented in JSON,\u003c/li\u003e\n\u003cli\u003ea type such as \u003ccode\u003eint\u003c/code\u003e or  \u003ccode\u003estring\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003eor something in between the two such as \u003ccode\u003e\u0026gt;=500\u003c/code\u003e, or \u003ccode\u003e!=\u0026quot;foo\u0026quot;\u003c/code\u003e - not concrete,\nbut more specific than a basic type.\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "CUE merges the concepts of values and types. In CUE, types are values. A field can be specified with: a concrete value such as \u0026quot;foo\u0026quot;, 42, or true - something that could be represented in JSON, a type such as int or string, or something in between the two such as \u0026gt;=500, or !=\u0026quot;foo\u0026quot; - not concrete, but more specific than a basic type. The following examples show a CUE schema; a typical CUE constraint that refines the schema; and some concrete values that satisfy both the constraint and, therefore, the schema. CUE schema Copy code Copied! municipality: { name: string pop: int capital: bool } CUE constraint Copy code Copied! largeCapital: { name: string pop: \u0026gt;5M capital: true } Concrete values Copy code Copied! kinshasa: { name: \u0026#34;Kinshasa\u0026#34; pop: 16.32M capital: true } With CUE, we generally start with a broad definition of a schema describing all possible instances and then progressively narrow down these definitions for a particular use case until a concrete data instance remains.",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a28ec13ef81ccd1b96740e330cca7569_1",
        "title": "Queries and Projections",
        "link": "/docs/tour/expressions/query-projection/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eComprehensions allow us to select and process data via queries and projections.\u003c/p\u003e\n\u003cp\u003eQueries select which data items we want to process,\nand projections define the shape of each resulting item.\u003c/p\u003e",
        "content": "Comprehensions allow us to select and process data via queries and projections. Queries select which data items we want to process, and projections define the shape of each resulting item. Copied! file.cue Copy code Copied! _data: { foo: {a: 1, b: \u0026#34;a foo\u0026#34;, c: true} bar: {a: 100, b: \u0026#34;some bar\u0026#34;, c: false} baz: {a: 1000, b: \u0026#34;this is baz\u0026#34;, c: false} quux: {a: 10000, b: \u0026#34;quux?\u0026#34;, c: true} } result: { for k, v in _data if v.a \u0026lt; 10 || v.c || v.b =~ \u0026#34;bar\u0026#34; { (k): { b: v.b a: 1 + v.a*2 } } } TERMINAL Copy code Copied! $ cue eval file.cue result: { foo: { b: \u0026#34;a foo\u0026#34; a: 3 } bar: { b: \u0026#34;some bar\u0026#34; a: 201 } quux: { b: \u0026#34;quux?\u0026#34; a: 20001 } }",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "39a11c3857028277ed1d35d6bd827464_1",
        "title": "Hidden Fields",
        "link": "/docs/tour/references/hidden/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA field name that starts with an underscore (\u003ccode\u003e_\u003c/code\u003e) is referred to as a \u003cstrong\u003ehidden field\u003c/strong\u003e.\nHidden fields are not included in the exported output.\u003c/p\u003e\n\u003cp\u003eIf a field\u0026rsquo;s name is enclosed in quotes then it is \u003cem\u003enot\u003c/em\u003e hidden from exported\noutput - even if it starts with an underscore.\nTo output a field whose name starts with an underscore, enclose its name in\nquotes.\u003c/p\u003e\n\u003cp\u003eQuoted and non-quoted fields share the same namespace \u003cem\u003eunless\u003c/em\u003e they start\nwith an underscore.\u003c/p\u003e",
        "content": "A field name that starts with an underscore (_) is referred to as a hidden field. Hidden fields are not included in the exported output. If a field\u0026rsquo;s name is enclosed in quotes then it is not hidden from exported output - even if it starts with an underscore. To output a field whose name starts with an underscore, enclose its name in quotes. Quoted and non-quoted fields share the same namespace unless they start with an underscore. Copied! file.cue Copy code Copied! foo: int \u0026amp; \u0026lt;100 // This is a regular field. // This is the same regular field as above, so // both their values must unify successfully. \u0026#34;foo\u0026#34;: 1 // These two declarations refer to different // fields, only one of which will be included in // exported output. _foo: 2 \u0026#34;_foo\u0026#34;: 3 // This is a hidden definition, which is not // included in exported output. _#foo: 4 TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;foo\u0026#34;: 1, \u0026#34;_foo\u0026#34;: 3 }",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "22a8d71a4e358731eab46bc21e6a02b0_1",
        "title": "Regular expressions",
        "link": "/docs/tour/expressions/regexp/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe operators \u003ccode\u003e=~\u003c/code\u003e and \u003ccode\u003e!~\u003c/code\u003e check values against \u003cstrong\u003eregular expressions\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe expression \u003ccode\u003ea =~ b\u003c/code\u003e is true if the value of \u003cstrong\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/strong\u003e matches the regular expression \u003cstrong\u003e\u003ccode\u003eb\u003c/code\u003e\u003c/strong\u003e.\u003cbr\u003e\n\u003ccode\u003ea !~ b\u003c/code\u003e is true if the value of \u003cstrong\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/strong\u003e does \u003cem\u003enot\u003c/em\u003e match the regular expression \u003cstrong\u003e\u003ccode\u003eb\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eJust like comparison operators (such as \u003ccode\u003e\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;=\u003c/code\u003e) can be used to define\n\u003ca href=\"/docs/tour/types/bounds/\"\u003ebounds\u003c/a\u003e,\nthe regular expression operators may also be used to define a set of strings\nthrough their unary forms.\u003c/p\u003e",
        "content": "The operators =~ and !~ check values against regular expressions. The expression a =~ b is true if the value of a matches the regular expression b. a !~ b is true if the value of a does not match the regular expression b. Just like comparison operators (such as \u0026lt; and \u0026gt;=) can be used to define bounds, the regular expression operators may also be used to define a set of strings through their unary forms. Copied! file.cue Copy code Copied! fooBar: \u0026#34;foo bar\u0026#34; =~ \u0026#34;^[a-z ]{1,100}$\u0026#34; bazQuux: \u0026#34;baz Quux\u0026#34; !~ \u0026#34;[A-Z]\u0026#34; #lowercaseLength3: =~\u0026#34;^[[:lower:]]{3}$\u0026#34; #noNumbers: !~\u0026#34;[0-9]\u0026#34; foo: \u0026#34;foo\u0026#34; \u0026amp; #lowercaseLength3 BAR: \u0026#34;BAR\u0026#34; \u0026amp; #lowercaseLength3 baaz: \u0026#34;baaz\u0026#34; \u0026amp; #lowercaseLength3 theAnswer: \u0026#34;42\u0026#34; \u0026amp; #noNumbers TERMINAL Copy code Copied! $ cue eval -ic file.cue fooBar: true bazQuux: false foo: \u0026#34;foo\u0026#34; BAR: _|_ // BAR: invalid value \u0026#34;BAR\u0026#34; (out of bound =~\u0026#34;^[[:lower:]]{3}$\u0026#34;) baaz: _|_ // baaz: invalid value \u0026#34;baaz\u0026#34; (out of bound =~\u0026#34;^[[:lower:]]{3}$\u0026#34;) theAnswer: _|_ // theAnswer: invalid value \u0026#34;42\u0026#34; (out of bound !~\u0026#34;[0-9]\u0026#34;) Futher details of how CUE supports regular expressions can be found in the regexp package documentation, and in the CUE language specification (Comparison operators and Pattern constraints). All regular expressions in CUE use Golang\u0026rsquo;s RE2 syntax.",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "86c97d87e6850a1f7800cb0f121ddca7_1",
        "title": "Structs",
        "link": "/docs/tour/types/structs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE\u0026rsquo;s most important composite type is the \u003cstrong\u003estruct\u003c/strong\u003e,\nalso known as a \u003cstrong\u003emap\u003c/strong\u003e.\nIts members are called \u003cstrong\u003efields\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003eregular\u003c/strong\u003e field (\u003ccode\u003efield: value\u003c/code\u003e) \u003cem\u003emust\u003c/em\u003e be made concrete if it is exported\nto a data format such as JSON or YAML.\u003c/p\u003e\n\u003cp\u003eAn \u003cstrong\u003eoptional field constraint\u003c/strong\u003e (\u003ccode\u003efield?: value\u003c/code\u003e) only restricts the field\u0026rsquo;s\nvalue if it is specified elsewhere as a regular field.\nAn optional field with a value of bottom (\u003ccode\u003e_|_\u003c/code\u003e) means the field \u003cem\u003ecannot\u003c/em\u003e be\nspecified.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003erequired field constraint\u003c/strong\u003e (\u003ccode\u003efield!: value\u003c/code\u003e) requires that the field be\nspecified as a regular field if it\u0026rsquo;s exported.\u003c/p\u003e",
        "content": "CUE\u0026rsquo;s most important composite type is the struct, also known as a map. Its members are called fields. A regular field (field: value) must be made concrete if it is exported to a data format such as JSON or YAML. An optional field constraint (field?: value) only restricts the field\u0026rsquo;s value if it is specified elsewhere as a regular field. An optional field with a value of bottom (_|_) means the field cannot be specified. A required field constraint (field!: value) requires that the field be specified as a regular field if it\u0026rsquo;s exported. Copied! file.cue Copy code Copied! A: { foo!: int // required bar?: string // optional baz: float // regular quux?: _|_ // cannot be specified } A: { bar: \u0026#34;42\u0026#34; baz: 42.0 } TERMINAL Copy code Copied! $ cue export file.cue A.foo: field is required but not present: ./file.cue:2:2",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "d650cbdde05f2088a0a88f624f0a8e0a_1",
        "title": "Closed structs",
        "link": "/docs/tour/types/closed/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA struct may be \u003cstrong\u003eopen\u003c/strong\u003e or \u003cstrong\u003eclosed\u003c/strong\u003e, and is open \u003cem\u003eunless\u003c/em\u003e it has been closed.\u003c/p\u003e\n\u003cp\u003eBoth open and closed structs can have any field defined as members.\u003cbr\u003e\nClosed structs can only be\n\u003ca href=\"/docs/tour/basics/unification/\"\u003eunified\u003c/a\u003e\nwith structs that have fields permitted by the closed struct.\u003c/p\u003e\n\u003cp\u003eA closed struct can be created using the \u003ccode\u003eclose()\u003c/code\u003e builtin, but is more\ncommonly created using a \u003cem\u003edefinition\u003c/em\u003e, as demonstrated on the next page.\nA struct created with \u003ccode\u003eclose()\u003c/code\u003e can\u0026rsquo;t have additional fields added elsewhere.\u003c/p\u003e",
        "content": "A struct may be open or closed, and is open unless it has been closed. Both open and closed structs can have any field defined as members. Closed structs can only be unified with structs that have fields permitted by the closed struct. A closed struct can be created using the close() builtin, but is more commonly created using a definition, as demonstrated on the next page. A struct created with close() can\u0026rsquo;t have additional fields added elsewhere. Copied! structs.cue Copy code Copied! A: close({ a: int }) B: A \u0026amp; { b: 42 // validation failure } TERMINAL Copy code Copied! $ cue eval -i structs.cue A: { a: int } B: { a: int b: _|_ // B.b: field not allowed }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "5752631420fe27defeb0c8eb24443f93_1",
        "title": "Null Coalescing",
        "link": "/docs/tour/expressions/coalesce/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eNull coalescing\u003c/strong\u003e is a technique that allows your CUE to evaluate successfully,\ndespite data having invalid, unexpected, or missing values.\nBy \u0026ldquo;null coalescing\u0026rdquo;, we really mean error (or bottom) coalescing.\u003c/p\u003e\n\u003cp\u003eIt uses a disjunction\u0026rsquo;s default marker (\u003ccode\u003e*\u003c/code\u003e) to prefer the value of an\nexpression that \u003cem\u003emight\u003c/em\u003e evaluate to bottom (\u003ccode\u003e_|_\u003c/code\u003e),\nalongside an alternative, fallback value that the disjunction will select if\nthe expression \u003cem\u003edoes\u003c/em\u003e produce bottom.\nThis isn\u0026rsquo;t a separate language feature, but is the expected outcome from CUE\u0026rsquo;s\ndesign that \u003ccode\u003e_|_ | value\u003c/code\u003e evaluates to \u003ccode\u003evalue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis technique can guard against situations such as list indexes being out of\nbounds, and type checks, with a fallback in the case of a type mismatch.\u003c/p\u003e",
        "content": "Null coalescing is a technique that allows your CUE to evaluate successfully, despite data having invalid, unexpected, or missing values. By \u0026ldquo;null coalescing\u0026rdquo;, we really mean error (or bottom) coalescing. It uses a disjunction\u0026rsquo;s default marker (*) to prefer the value of an expression that might evaluate to bottom (_|_), alongside an alternative, fallback value that the disjunction will select if the expression does produce bottom. This isn\u0026rsquo;t a separate language feature, but is the expected outcome from CUE\u0026rsquo;s design that _|_ | value evaluates to value. This technique can guard against situations such as list indexes being out of bounds, and type checks, with a fallback in the case of a type mismatch. Copied! file.cue Copy code Copied! #pets: [\u0026#34;Cat\u0026#34;, \u0026#34;Mouse\u0026#34;, \u0026#34;Dog\u0026#34;] // Guard against out of bounds list indexes. pet0: *#pets[0] | \u0026#34;Pet not found\u0026#34; pet5: *#pets[5] | \u0026#34;Pet not found\u0026#34; #nums: [7, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;] // Perform a type check. num0: *(#nums[0] \u0026amp; int) | \u0026#34;Not an integer\u0026#34; num1: *(#nums[1] \u0026amp; int) | \u0026#34;Not an integer\u0026#34; TERMINAL Copy code Copied! $ cue eval -c file.cue pet0: \u0026#34;Cat\u0026#34; pet5: \u0026#34;Pet not found\u0026#34; num0: 7 num1: \u0026#34;Not an integer\u0026#34;",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "bbbc42e995123c69f3ab6af0d7bbfc54_1",
        "title": "Definitions",
        "link": "/docs/tour/types/definitions/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn CUE, schemas are typically written as \u003cstrong\u003edefinitions\u003c/strong\u003e.\nA definition is a field whose identifier starts with \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e_#\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause CUE knows that definitions are used for validation,\nthey aren\u0026rsquo;t output as data.\u003cbr\u003e\nIt\u0026rsquo;s normal for definitions to specify fields that don\u0026rsquo;t have concrete values,\nsuch as types.\u003c/p\u003e\n\u003cp\u003eA definition also tells CUE the complete set of allowed fields in a struct.\u003cbr\u003e\nReferring to a definition \u003cstrong\u003ecloses\u003c/strong\u003e any structs and lists recursively.\nStructs and lists can be left \u003cstrong\u003eopen\u003c/strong\u003e using \u003ccode\u003e...\u003c/code\u003e.\u003c/p\u003e",
        "content": "In CUE, schemas are typically written as definitions. A definition is a field whose identifier starts with # or _#. Because CUE knows that definitions are used for validation, they aren\u0026rsquo;t output as data. It\u0026rsquo;s normal for definitions to specify fields that don\u0026rsquo;t have concrete values, such as types. A definition also tells CUE the complete set of allowed fields in a struct. Referring to a definition closes any structs and lists recursively. Structs and lists can be left open using .... Copied! file.cue Copy code Copied! message: \u0026#34;Hello, \\(#Name)!\u0026#34; #Name: \u0026#34;world\u0026#34; #A: { n: int // Uncomment this to allow any field. // ... } valid: #A \u0026amp; {n: 3} invalid: #A \u0026amp; {N: 3} TERMINAL Copy code Copied! $ cue eval -ic file.cue message: \u0026#34;Hello, world!\u0026#34; valid: { n: 3 } invalid: { N: _|_ // invalid.N: field not allowed n: int }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "42f716d0a69f3d3bf7985f50ad6e2982_1",
        "title": "Unification",
        "link": "/docs/tour/basics/unification/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE allows fields to be specified multiple times, so long as all the values\ndont conflict.\nIf the values dont conflict we say they \u003cstrong\u003eunify\u003c/strong\u003e successfully.\n\u003cstrong\u003eUnification\u003c/strong\u003e is the process of checking that values don\u0026rsquo;t conflict,\nand it happens implicitly whenever any field is redeclared. It also happens when the \u003ccode\u003e\u0026amp;\u003c/code\u003e\noperator is used, as shown on the next page.\u003c/p\u003e\n\u003cp\u003eFor concrete data, unification of basic types requires that\nall values specified for a field must be equal.\u003cbr\u003e\nWithin structs, fields are unified recursively.\nSimilarly, within lists, elements are unified recursively.\u003c/p\u003e",
        "content": "CUE allows fields to be specified multiple times, so long as all the values dont conflict. If the values dont conflict we say they unify successfully. Unification is the process of checking that values don\u0026rsquo;t conflict, and it happens implicitly whenever any field is redeclared. It also happens when the \u0026amp; operator is used, as shown on the next page. For concrete data, unification of basic types requires that all values specified for a field must be equal. Within structs, fields are unified recursively. Similarly, within lists, elements are unified recursively. Copied! file.cue Copy code Copied! A: 1 A: 1 B: {a: 2} B: {b: 3} C: [4, 5, {c: 6}] C: [4, 5, {d: 7}] TERMINAL Copy code Copied! $ cue export file.cue --out yaml A: 1 B: a: 2 b: 3 C: - 4 - 5 - c: 6 d: 7",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "05c19d5162bfe4e6d45d37d54a38c9dd_1",
        "title": "Code of Conduct",
        "link": "/docs/reference/code-of-conduct/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"about\"\u003e\n    \u003ca href=\"#about\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eAbout\u003c/h2\u003e\n\u003cp\u003eOnline communities include people from many different backgrounds.\nThe CUE contributors are committed to providing a friendly, safe and welcoming\nenvironment for all, regardless of gender identity and expression, sexual orientation,\ndisabilities, neurodiversity, physical appearance, body size, ethnicity, nationality,\nrace, age, religion, or similar personal characteristics.\u003c/p\u003e\n\u003cp\u003eThe first goal of the Code of Conduct is to specify a baseline standard\nof behavior so that people with different social values and communication\nstyles can talk about CUE effectively, productively, and respectfully.\u003c/p\u003e\n\u003cp\u003eThe second goal is to provide a mechanism for resolving conflicts in the\ncommunity when they arise.\u003c/p\u003e\n\u003cp\u003eThe third goal of the Code of Conduct is to make our community welcoming to\npeople from different backgrounds.\nDiversity is critical to the project; for CUE to be successful, it needs\ncontributors and users from all backgrounds.\n(We take inspiration here from\n\u003ca href=\"https://blog.golang.org/open-source\"\u003eGo, Open Source, Community\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eWe believe that healthy debate and disagreement are essential to a healthy project and community.\nHowever, it is never ok to be disrespectful.\nWe value diverse opinions, but we value respectful behavior more.\u003c/p\u003e",
        "content": "About Online communities include people from many different backgrounds. The CUE contributors are committed to providing a friendly, safe and welcoming environment for all, regardless of gender identity and expression, sexual orientation, disabilities, neurodiversity, physical appearance, body size, ethnicity, nationality, race, age, religion, or similar personal characteristics. The first goal of the Code of Conduct is to specify a baseline standard of behavior so that people with different social values and communication styles can talk about CUE effectively, productively, and respectfully. The second goal is to provide a mechanism for resolving conflicts in the community when they arise. The third goal of the Code of Conduct is to make our community welcoming to people from different backgrounds. Diversity is critical to the project; for CUE to be successful, it needs contributors and users from all backgrounds. (We take inspiration here from Go, Open Source, Community.) We believe that healthy debate and disagreement are essential to a healthy project and community. However, it is never ok to be disrespectful. We value diverse opinions, but we value respectful behavior more. CUE Values These are the values to which people in the CUE community should aspire. Be friendly and welcoming Be patient Remember that people have varying communication styles and that not everyone is using their native language. (Meaning and tone can be lost in translation.) Be thoughtful Productive communication requires effort. Think about how your words will be interpreted. Remember that sometimes it is best to refrain entirely from commenting. Be respectful In particular, respect differences of opinion. Be charitable Interpret the arguments of others in good faith, do not seek to disagree. When we do disagree, try to understand why. Avoid destructive behavior: Derailing: stay on topic; if you want to talk about something else, start a new conversation. Unconstructive criticism: don\u0026rsquo;t merely decry the current state of affairs; offeror at least solicitsuggestions as to how things may be improved. Snarking (pithy, unproductive, sniping comments) Discussing potentially offensive or sensitive issues; this all too often leads to unnecessary conflict. Microaggressions: brief and commonplace verbal, behavioral and environmental indignities that communicate hostile, derogatory or negative slights and insults to a person or group. People are complicated. You should expect to be misunderstood and to misunderstand others; when this inevitably occurs, resist the urge to be defensive or assign blame. Try not to take offense where no offense was intended. Give people the benefit of the doubt. Even if the intent was to provoke, do not rise to it. It is the responsibility of all parties to de-escalate conflict when it arises. Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u0026rsquo; private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. This Code of Conduct also applies outside the project spaces when the Project Stewards have a reasonable belief that an individual\u0026rsquo;s behavior may have a negative impact on the project or its community. Conflict Resolution We do not believe that all conflict is bad; healthy debate and disagreement often yield positive results. However, it is never okay to be disrespectful or to engage in behavior that violates the projects code of conduct. If you see someone violating the code of conduct, you are encouraged to address the behavior directly with those involved. Many issues can be resolved quickly and easily, and this gives people more control over the outcome of their dispute. If you are unable to resolve the matter for any reason, or if the behavior is threatening or harassing, report it. We are dedicated to providing an environment where participants feel welcome and safe. Reports should be directed to Marcel van Lohuizen and Paul Jolly, the CUE Project Stewards, at conduct@cuelang.org. We will investigate every complaint, but you may not receive a direct response. We will use our discretion in determining when and how to follow up on reported incidents, which may range from not taking action to permanent expulsion from the project and project-sponsored spaces. We will notify the accused of the report and provide them an opportunity to discuss it before any action is taken. The identity of the reporter will be omitted from the details of the report supplied to the accused. In potentially harmful situations, such as ongoing harassment or threats to",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "05c19d5162bfe4e6d45d37d54a38c9dd_2",
        "title": "Code of Conduct",
        "link": "/docs/reference/code-of-conduct/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"about\"\u003e\n    \u003ca href=\"#about\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eAbout\u003c/h2\u003e\n\u003cp\u003eOnline communities include people from many different backgrounds.\nThe CUE contributors are committed to providing a friendly, safe and welcoming\nenvironment for all, regardless of gender identity and expression, sexual orientation,\ndisabilities, neurodiversity, physical appearance, body size, ethnicity, nationality,\nrace, age, religion, or similar personal characteristics.\u003c/p\u003e\n\u003cp\u003eThe first goal of the Code of Conduct is to specify a baseline standard\nof behavior so that people with different social values and communication\nstyles can talk about CUE effectively, productively, and respectfully.\u003c/p\u003e\n\u003cp\u003eThe second goal is to provide a mechanism for resolving conflicts in the\ncommunity when they arise.\u003c/p\u003e\n\u003cp\u003eThe third goal of the Code of Conduct is to make our community welcoming to\npeople from different backgrounds.\nDiversity is critical to the project; for CUE to be successful, it needs\ncontributors and users from all backgrounds.\n(We take inspiration here from\n\u003ca href=\"https://blog.golang.org/open-source\"\u003eGo, Open Source, Community\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eWe believe that healthy debate and disagreement are essential to a healthy project and community.\nHowever, it is never ok to be disrespectful.\nWe value diverse opinions, but we value respectful behavior more.\u003c/p\u003e",
        "content": "anyone\u0026rsquo;s safety, we may take action without notice. Attribution This Code of Conduct is adapted from the Go Community Code of Conduct, which itself is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html. Summary Treat everyone with respect and kindness. Be thoughtful in how you communicate. Dont be destructive or inflammatory. If you encounter an issue, please mail conduct@cuelang.org.",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "1a784ffc1c8c49a1e7ea88a5548af824_1",
        "title": "Disjunctions",
        "link": "/docs/tour/types/disjunctions/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA \u003cstrong\u003edisjunction\u003c/strong\u003e, or sum type,\ndefines a constraint consisting of two or more options that are allowed.\u003c/p\u003e\n\u003cp\u003eThe disjunction\u0026rsquo;s options are values called its \u003cem\u003eelements\u003c/em\u003e.\nThey are written separated by the pipe symbol (\u003ccode\u003e|\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eA disjunction allows values\nthat unify successfully with \u003cem\u003eat least one\u003c/em\u003e of its elements.\nWhen a value constrained by a disjunction is exported\nit must unify successfully with \u003cem\u003eonly one\u003c/em\u003e of the disjunction\u0026rsquo;s elements.\u003c/p\u003e\n\u003c!-- TODO: should we relax or refine this wording,\ngiven that `x: 1 \u0026 ( 1 | int )` exports successfully? --\u003e",
        "content": "A disjunction, or sum type, defines a constraint consisting of two or more options that are allowed. The disjunction\u0026rsquo;s options are values called its elements. They are written separated by the pipe symbol (|). A disjunction allows values that unify successfully with at least one of its elements. When a value constrained by a disjunction is exported it must unify successfully with only one of the disjunction\u0026rsquo;s elements. Copied! file.cue Copy code Copied! #Conn: { address: string port: int protocol: \u0026#34;tcp\u0026#34; | \u0026#34;udp\u0026#34; | \u0026#34;sctp\u0026#34; | \u0026#34;dccp\u0026#34; } lossy: #Conn \u0026amp; { address: \u0026#34;203.0.113.42\u0026#34; port: 8888 protocol: \u0026#34;udp\u0026#34; // acceptable value } error: #Conn \u0026amp; { address: \u0026#34;203.0.113.42\u0026#34; port: 8888 protocol: \u0026#34;IP\u0026#34; // invalid value } TERMINAL Copy code Copied! $ cue eval -ic file.cue lossy: { address: \u0026#34;203.0.113.42\u0026#34; port: 8888 protocol: \u0026#34;udp\u0026#34; } error: { address: \u0026#34;203.0.113.42\u0026#34; port: 8888 protocol: _|_ // error.protocol: 4 errors in empty disjunction: (and 4 more errors) }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "b00a88a07ceb21b1a83e5822e0c86c1d_1",
        "title": "References",
        "link": "/docs/reference/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Language Specification The source of truth for how the CUE language should behave reference/spec reference/spec The cue command Help texts for the cue command and its subcommands reference/command reference/command Modules CUE\u0026rsquo;s dependency management system reference/modules reference/modules Glossary Index and glossary of terms used by CUE reference/glossary reference/glossary Code of Conduct The project\u0026rsquo;s values, standards, responsibilities, and processes reference/code-of- conduct reference/code-of- conduct External references Reference information published on other websites.",
        "content": "Language Specification The source of truth for how the CUE language should behave reference/spec reference/spec The cue command Help texts for the cue command and its subcommands reference/command reference/command Modules CUE\u0026rsquo;s dependency management system reference/modules reference/modules Glossary Index and glossary of terms used by CUE reference/glossary reference/glossary Code of Conduct The project\u0026rsquo;s values, standards, responsibilities, and processes reference/code-of- conduct reference/code-of- conduct External references Reference information published on other websites. Standard library Built-in packages available to CUE code. Also available to Go code, but typically not used there pkg.go.dev pkg.go.dev API: go/cue Core Go APIs related to parsing, formatting, loading and running CUE programs. Used by all other packages, including the cue command pkg.go.dev pkg.go.dev API: go/encoding Go APIs for converting to and from CUE. Includes adaptors for YAML, JSON, Go, Protobuf, and OpenAPI pkg.go.dev pkg.go.dev cue-lang/cue The CUE project issue tracker, and source code for the CUE Go implementation github.com github.com Contributing to CUE Guidance on how to contribute to the CUE project github.com github.com",
        "breadcrumb": ["Documentation"],
        "contentType": "References",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "efd4c77c06104fea6a0b74a03ac50493_1",
        "title": "The cue export command",
        "link": "/docs/reference/command/cue-export/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "The cue export command evaluates an expression in the context of a particular configuration and then emits the value of the expression encoded as concrete data. The command fails with an error message if evaluation is unsuccessful, or if the value of the evaluated expression is not concrete.\nThe default behavior is to evaluate the single CUE package in the current directory, and to emit its top-level configuration to the standard output stream of the command, encoded as JSON:",
        "content": "The cue export command evaluates an expression in the context of a particular configuration and then emits the value of the expression encoded as concrete data. The command fails with an error message if evaluation is unsuccessful, or if the value of the evaluated expression is not concrete. The default behavior is to evaluate the single CUE package in the current directory, and to emit its top-level configuration to the standard output stream of the command, encoded as JSON: Copied! file.cue Copy code Copied! package example import \u0026#34;math\u0026#34; info: \u0026#34;Vector magnitude is \\(vector._m)\u0026#34; vector: #Vector \u0026amp; { x: 1.1 y: 2 * 2 z: x + y _m: math.Sqrt(x*x + y*y + z*z) } #Vector: [\u0026#34;x\u0026#34; | \u0026#34;y\u0026#34; | \u0026#34;z\u0026#34;]: number TERMINAL Copy code Copied! $ cue export { \u0026#34;info\u0026#34;: \u0026#34;Vector magnitude is 6.57419196555744\u0026#34;, \u0026#34;vector\u0026#34;: { \u0026#34;x\u0026#34;: 1.1, \u0026#34;y\u0026#34;: 4, \u0026#34;z\u0026#34;: 5.1 } } The default behaviours of cue export can be overriden using parameters to control its inputs, output, and operation. The command can read and process an arbitrary number of data and data-constraint inputs provided as CUE and other encodings; can format its output in JSON, YAML, CUE, or TOML; and can place that output in a named file. To learn more, refer to: Concept Guide: Using the cue export command \u0026ndash; an in-depth guide to cue export Reference: cue help export \u0026ndash; the built-in help text for the cue export command",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "6b598f5dbc9683e6e468558a4e269ee3_1",
        "title": "Default Values",
        "link": "/docs/tour/types/defaults/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eDefault values\u003c/strong\u003e allow CUE to decide which element of a disjunction should be\nchosen when a configuration doesn\u0026rsquo;t specify a value, leaving more than one of\nthe disjunction\u0026rsquo;s elements as valid options.\u003c/p\u003e\n\u003cp\u003eA default value is an element in a disjunction that has been prefixed with the\npreference marker \u003ccode\u003e*\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCUE will select and use the default when a value is required but none has been\nexplicitly specified.\u003c/p\u003e",
        "content": "Default values allow CUE to decide which element of a disjunction should be chosen when a configuration doesn\u0026rsquo;t specify a value, leaving more than one of the disjunction\u0026rsquo;s elements as valid options. A default value is an element in a disjunction that has been prefixed with the preference marker *. CUE will select and use the default when a value is required but none has been explicitly specified. Copied! file.cue Copy code Copied! #def: string | int | *1 A: #def B: #def \u0026amp; 42 C: #def \u0026amp; \u0026#34;foo\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 42, \u0026#34;C\u0026#34;: \u0026#34;foo\u0026#34; }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "5aebf18ecdb96a7e452141fc69746142_1",
        "title": "Constraints",
        "link": "/docs/tour/basics/constraints/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eConstraints\u003c/strong\u003e specify what values are allowed.\nConstraints are values because\n\u003ca href=\"/docs/tour/basics/types-are-values/\"\u003eall types are values\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eConstraints can \u003cstrong\u003ereduce boilerplate\u003c/strong\u003e and simplify the specification of data.\nIf a constraint specifies a field then the field and its value are present\neverywhere the constraint is unified, and don\u0026rsquo;t need to be repeated.\u003c/p\u003e\n\u003cp\u003eIn this example, the \u003ccode\u003ecue export\u003c/code\u003e output includes the data that Viola is a human.\nThis is because the \u003ccode\u003eviola\u003c/code\u003e field is specified as the unification of a struct\nwhich declares Viola\u0026rsquo;s name and age, and the \u003ccode\u003eperson\u003c/code\u003e constraint which\nadditionally declares the \u003ccode\u003ehuman\u003c/code\u003e field.\nThis specification uses the \u003cstrong\u003eexplicit unification operator:\u003c/strong\u003e \u003ccode\u003e\u0026amp;\u003c/code\u003e.\u003c/p\u003e",
        "content": "Constraints specify what values are allowed. Constraints are values because all types are values. Constraints can reduce boilerplate and simplify the specification of data. If a constraint specifies a field then the field and its value are present everywhere the constraint is unified, and don\u0026rsquo;t need to be repeated. In this example, the cue export output includes the data that Viola is a human. This is because the viola field is specified as the unification of a struct which declares Viola\u0026rsquo;s name and age, and the person constraint which additionally declares the human field. This specification uses the explicit unification operator: \u0026amp;. Copied! file.cue Copy code Copied! person: { name: string age: int \u0026amp; \u0026gt;=0 human: true // People are always humans } viola: person \u0026amp; { name: \u0026#34;Viola\u0026#34; age: 38 } TERMINAL Copy code Copied! $ cue export file.cue -e viola { \u0026#34;name\u0026#34;: \u0026#34;Viola\u0026#34;, \u0026#34;age\u0026#34;: 38, \u0026#34;human\u0026#34;: true } Unification succeeds because person\u0026rsquo;s name field constraint of string doesn\u0026rsquo;t conflict with the concrete value \u0026quot;Viola\u0026quot;, and age\u0026rsquo;s unified constraint of int \u0026amp; \u0026gt;=0 doesn\u0026rsquo;t conflict with the value 38.",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "ba4125e7fc78040f40fd90ea309a0bd7_1",
        "title": "Disjunctions of Structs",
        "link": "/docs/tour/types/sumstruct/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eDisjunctions work for any type, including structs.\u003c/p\u003e\n\u003cp\u003eIn this example each \u003ccode\u003e#Floor\u003c/code\u003e of a building\nmust have a exit if it is on level 0 or 1,\nbut not if it is on any other level.\n(A neater way to encode the \u003ccode\u003elevel\u003c/code\u003e constraints would be to use \u003cem\u003ebounds\u003c/em\u003e, as\nshown on the next page.)\u003c/p\u003e",
        "content": "Disjunctions work for any type, including structs. In this example each #Floor of a building must have a exit if it is on level 0 or 1, but not if it is on any other level. (A neater way to encode the level constraints would be to use bounds, as shown on the next page.) Copied! file.cue Copy code Copied! #Floor: { level?: int // floor\u0026#39;s level hasExit?: bool // floor has an exit? } // Constraints on the possible values of #Floor. #Floor: { level: 0 | 1 hasExit: true } | { level: -3 | -2 | -1 | 2 | 3 | 4 hasExit: false } floors: [...#Floor] floors: [ {level: -2}, {level: -1}, {level: 0}, {level: 1}, {level: 2}, ] TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;floors\u0026#34;: [ { \u0026#34;level\u0026#34;: -2, \u0026#34;hasExit\u0026#34;: false }, { \u0026#34;level\u0026#34;: -1, \u0026#34;hasExit\u0026#34;: false }, { \u0026#34;level\u0026#34;: 0, \u0026#34;hasExit\u0026#34;: true }, { \u0026#34;level\u0026#34;: 1, \u0026#34;hasExit\u0026#34;: true }, { \u0026#34;level\u0026#34;: 2, \u0026#34;hasExit\u0026#34;: false } ] }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "a470e12605623ef3d0128b83beb0ef10_1",
        "title": "Bounds",
        "link": "/docs/tour/types/bounds/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eBounds\u003c/strong\u003e define\na lower bound, an upper bound, or inequality for a certain value,\nall of which can be combined.\nThey work on numbers, strings, bytes, and \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA bound is expressed using comparison operators such as \u003ccode\u003e\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;=\u003c/code\u003e, and \u003ccode\u003e!=\u003c/code\u003e.\nIt permits values where the comparison would return \u003ccode\u003etrue\u003c/code\u003e,\nand we say that \u003cem\u003ethe bound is defined\u003c/em\u003e for these values.\u003c/p\u003e",
        "content": "Bounds define a lower bound, an upper bound, or inequality for a certain value, all of which can be combined. They work on numbers, strings, bytes, and null. A bound is expressed using comparison operators such as \u0026gt;, \u0026lt;=, and !=. It permits values where the comparison would return true, and we say that the bound is defined for these values. Copied! file.cue Copy code Copied! #floatOver5: \u0026gt;5.0 // type: float #negativeNum: \u0026lt;0 // type: int | float #afterL: \u0026gt;\u0026#34;L\u0026#34; // type: string #notNull: !=null // type: any except null zero: 0 \u0026amp; \u0026gt;10 // failure float10: 10.0 \u0026amp; #floatOver5 float5: 5.0 \u0026amp; #floatOver5 // failure \u0026#34;num-6\u0026#34;: -6 \u0026amp; #negativeNum A: \u0026#34;A\u0026#34; \u0026amp; #afterL // failure Z: \u0026#34;Z\u0026#34; \u0026amp; #afterL isNull: null \u0026amp; #notNull // failure isNotNull: \u0026#34;X\u0026#34; \u0026amp; #notNull float425: 42.5 \u0026amp; #notNull \u0026amp; \u0026lt;100 \u0026amp; #floatOver5 TERMINAL Copy code Copied! $ cue eval -ic file.cue zero: _|_ // zero: invalid value 0 (out of bound \u0026gt;10) float10: 10.0 float5: _|_ // float5: invalid value 5.0 (out of bound \u0026gt;5.0) \u0026#34;num-6\u0026#34;: -6 A: _|_ // A: invalid value \u0026#34;A\u0026#34; (out of bound \u0026gt;\u0026#34;L\u0026#34;) Z: \u0026#34;Z\u0026#34; isNull: _|_ // isNull: conflicting values null and !=null (mismatched types null and (bool|string|bytes|func|list|struct|number)) isNotNull: \u0026#34;X\u0026#34; float425: 42.5",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "1c5c8d1b21c79e6e650df976c39ae734_1",
        "title": "Predefined Bounds",
        "link": "/docs/tour/types/bounddef/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE defines the following predefined identifiers to restrict the bounds of\nintegers to common values.\u003cbr\u003e\nThe \u003ccode\u003eu\u003c/code\u003e-prefixed identifiers provide similar capabilities to unsigned integer\ntypes in other languages.\u003c/p\u003e",
        "content": "CUE defines the following predefined identifiers to restrict the bounds of integers to common values. The u-prefixed identifiers provide similar capabilities to unsigned integer types in other languages. Copy code Copied! uint: \u0026gt;=0 uint8: \u0026gt;=0 \u0026amp; \u0026lt;=255 int8: \u0026gt;=-128 \u0026amp; \u0026lt;=127 uint16: \u0026gt;=0 \u0026amp; \u0026lt;=65535 int16: \u0026gt;=-32_768 \u0026amp; \u0026lt;=32_767 rune: \u0026gt;=0 \u0026amp; \u0026lt;=0x10FFFF uint32: \u0026gt;=0 \u0026amp; \u0026lt;=4_294_967_295 int32: \u0026gt;=-2_147_483_648 \u0026amp; \u0026lt;=2_147_483_647 uint64: \u0026gt;=0 \u0026amp; \u0026lt;=18_446_744_073_709_551_615 int64: \u0026gt;=-9_223_372_036_854_775_808 \u0026amp; \u0026lt;=9_223_372_036_854_775_807 int128: \u0026gt;=-170_141_183_460_469_231_731_687_303_715_884_105_728 \u0026amp; \u0026lt;=170_141_183_460_469_231_731_687_303_715_884_105_727 uint128: \u0026gt;=0 \u0026amp; \u0026lt;=340_282_366_920_938_463_463_374_607_431_768_211_455 Copied! file.cue Copy code Copied! import \u0026#34;math\u0026#34; a: uint \u0026amp; -1 b: uint8 \u0026amp; 256 c: int32 \u0026amp; math.Pow(2, 31) // 2^31 TERMINAL Copy code Copied! $ cue vet -c file.cue a: invalid value -1 (out of bound \u0026gt;=0): ./file.cue:3:11 b: invalid value 256 (out of bound \u0026lt;=255): ./file.cue:4:12 c: invalid value 2147483648 (out of bound \u0026lt;=2147483647): ./file.cue:5:12",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "614cbaaa1ef912f04aab4baa46fd3c65_1",
        "title": "Definitions",
        "link": "/docs/tour/basics/definitions/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn CUE, schemas are typically written as \u003cstrong\u003edefinitions\u003c/strong\u003e.\nA definition is a field whose identifier starts with \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e_#\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause CUE knows that definitions are used for validation,\nthey aren\u0026rsquo;t output as data.\nIt\u0026rsquo;s normal for definitions to specify fields that don\u0026rsquo;t have concrete values,\nsuch as types.\u003c/p\u003e\n\u003cp\u003eA definition also tells CUE the complete set of allowed fields,\nmeaning that evaluations \u003c!-- TODO: explain \"evaluation\" here, or before this point? Swap with \"export\"? --\u003e\nwill fail if any additional fields are specified.\nWe say that such a definition defines a  \u003cstrong\u003eclosed\u003c/strong\u003e struct.\nIncluding a \u003ccode\u003e...\u003c/code\u003e in a struct keeps it \u003cstrong\u003eopen\u003c/strong\u003e.\u003c/p\u003e",
        "content": "In CUE, schemas are typically written as definitions. A definition is a field whose identifier starts with # or _#. Because CUE knows that definitions are used for validation, they aren\u0026rsquo;t output as data. It\u0026rsquo;s normal for definitions to specify fields that don\u0026rsquo;t have concrete values, such as types. A definition also tells CUE the complete set of allowed fields, meaning that evaluations will fail if any additional fields are specified. We say that such a definition defines a closed struct. Including a ... in a struct keeps it open. Copied! file.cue Copy code Copied! #Conn: { address: string port: int protocol: string // Uncomment this to allow any field. // ... } lossy: #Conn \u0026amp; { address: \u0026#34;203.0.113.42\u0026#34; port: 8888 protocol: \u0026#34;udp\u0026#34; // The timeout field is not specified in // #Conn, and its presence causes an // evaluation failure. timeout: 30 } TERMINAL Copy code Copied! $ cue export file.cue lossy.timeout: field not allowed: ./file.cue:18:2",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "0f70a00d00a37d8453f5efd958b9f5fc_1",
        "title": "Lists",
        "link": "/docs/tour/types/lists/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eLists\u003c/strong\u003e define arbitrary sequences of CUE values,\nand can be \u003cstrong\u003eclosed\u003c/strong\u003e or \u003cstrong\u003eopen\u003c/strong\u003e.\nList members are called \u003cstrong\u003eelements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA closed list statically defines its length each and every time its elements are specified.\u003c/p\u003e\n\u003cp\u003eOpen lists may contain some predefined elements,\nfollowed by \u003ccode\u003e...\u003c/code\u003e and an optional value that constrains any elements that follow.\nOpen lists permit additional elements to be specified elsewhere, after the predefined elements.\nBoth the predefined and additional elements may be constrained.\u003c/p\u003e",
        "content": "Lists define arbitrary sequences of CUE values, and can be closed or open. List members are called elements. A closed list statically defines its length each and every time its elements are specified. Open lists may contain some predefined elements, followed by ... and an optional value that constrains any elements that follow. Open lists permit additional elements to be specified elsewhere, after the predefined elements. Both the predefined and additional elements may be constrained. Copied! file.cue Copy code Copied! // A is an open list with 3 predefined elements. // Any additional elements must be ints. A: [1, 2, 3, ...int] // B is a closed list with 4 elements which is // compatible with A\u0026#39;s constraints. B: [1, 2, 3, 4] \u0026amp; A // C is a closed list with 3 elements which is // compatible with A\u0026#39;s constraints. C: [1, _, _] \u0026amp; A C: [_, 2, _] // 3 elements must be specified on C: [_, _, 3] // each and every definition. // D is an open list containing at least 2 ints, // and is compatible with A\u0026#39;s constraints. D: [int, int, ...int] \u0026amp; A // Closed lists with different lengths don\u0026#39;t unify. unifyFailBC: B \u0026amp; C // Element type mismatches prevent unification. unifyFailA: A \u0026amp; [1, 2, 3, \u0026#34;4\u0026#34;] // E is built up incrementally as an example. // E has identical constraints to A. E: [...] // No type information; list is open. E: [_, _, _, ...] // There are at least 3 elements. E: [...int] // All elements are ints. E: [1, ...] // Element 1 is made concrete. E: [_, 2, ...] // Element 2 is made concrete. E: [_, _, 3, ...] // Element 3 is made concrete. TERMINAL Copy code Copied! $ cue eval -i file.cue A: [1, 2, 3] B: [1, 2, 3, 4] C: [1, 2, 3] D: [1, 2, 3] unifyFailBC: _|_ // unifyFailBC: incompatible list lengths (3 and 4) (and 2 more errors) unifyFailA: [1, 2, 3, _|_, // unifyFailA.3: conflicting values \u0026#34;4\u0026#34; and int (mismatched types string and int) ] E: [1, 2, 3]",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "cea4d88aa204ad2a126193a935938708_1",
        "title": "Templates",
        "link": "/docs/tour/types/templates/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eTemplating\u003c/strong\u003e is a highly effective way to reduce boilerplate\nby specifying optional fields in bulk.\nIt allows the specification of constraints, or \u003cstrong\u003etemplates\u003c/strong\u003e,\nwhich are unified with every field of a struct that matches a given pattern.\u003c/p\u003e\n\u003cp\u003eA template\u0026rsquo;s pattern is an expression in square brackets that selects which\nfields will be constrained.\nEach combination of the pattern and a constraint that it applies is called a\n\u003ca href=\"/docs/tour/basics/folding-structs/\"\u003e\u003cstrong\u003epattern constraint\u003c/strong\u003e\u003c/a\u003e.\nCurrently, patterns must either be instances of \u003ccode\u003estring\u003c/code\u003e, or must be \u003ccode\u003e_\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIncluding an alias in the pattern\u0026rsquo;s square brackets makes the label of each\nmatched field available inside the template.\u003c/p\u003e",
        "content": "Templating is a highly effective way to reduce boilerplate by specifying optional fields in bulk. It allows the specification of constraints, or templates, which are unified with every field of a struct that matches a given pattern. A template\u0026rsquo;s pattern is an expression in square brackets that selects which fields will be constrained. Each combination of the pattern and a constraint that it applies is called a pattern constraint. Currently, patterns must either be instances of string, or must be _. Including an alias in the pattern\u0026rsquo;s square brackets makes the label of each matched field available inside the template. Copied! file.cue Copy code Copied! job: { nginx: replicas: 2 manager: command: \u0026#34;monit -I\u0026#34; policyd: _ boltdb: replicas: 3 postgres: replicas: 5 } job: [Name=_]: { name: Name // Name is an alias. command: string | *\u0026#34;exec \\(Name)\u0026#34; replicas: uint | *1 } // Databases are important, so increase the // replica minimum. job: [#DB]: replicas: \u0026gt;=3 #DB: \u0026#34;postgres\u0026#34; | \u0026#34;mysql\u0026#34; | =~\u0026#34;db$\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;job\u0026#34;: { \u0026#34;nginx\u0026#34;: { \u0026#34;replicas\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;exec nginx\u0026#34; }, \u0026#34;manager\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;monit -I\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;manager\u0026#34;, \u0026#34;replicas\u0026#34;: 1 }, \u0026#34;policyd\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;policyd\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;exec policyd\u0026#34;, \u0026#34;replicas\u0026#34;: 1 }, \u0026#34;boltdb\u0026#34;: { \u0026#34;replicas\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;boltdb\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;exec boltdb\u0026#34; }, \u0026#34;postgres\u0026#34;: { \u0026#34;replicas\u0026#34;: 5, \u0026#34;name\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;exec postgres\u0026#34; } } }",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "66347417115061793837fe62bf8e57e7_1",
        "title": "Validation",
        "link": "/docs/tour/basics/validation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eConstraints can be used to \u003cstrong\u003evalidate\u003c/strong\u003e values of concrete instances.\nThey can be applied to data from any source,\nwhether held in CUE, YAML, JSON, or elsewhere.\u003c/p\u003e\n\u003cp\u003eHere, a constraint is applied to all the languages stored in \u003ccode\u003edata.yml\u003c/code\u003e,\nand is validated using the\n\u003ca href=\"/docs/reference/command/cue-help-vet/\"\u003e\u003cstrong\u003e\u003ccode\u003ecue vet\u003c/code\u003e\u003c/strong\u003e\u003c/a\u003e command.\u003c/p\u003e",
        "content": "Constraints can be used to validate values of concrete instances. They can be applied to data from any source, whether held in CUE, YAML, JSON, or elsewhere. Here, a constraint is applied to all the languages stored in data.yml, and is validated using the cue vet command. Copied! file.cue Copy code Copied! #Language: { // Name must start with a uppercase // letter, as defined by Unicode. Name: =~\u0026#34;^\\\\p{Lu}\u0026#34; Tag: string } languages: [...#Language] Copied! data.yaml Copy code Copied! languages: - Name: English Tag: en - Name: dutch Tag: nl - Name: Norwegian Tag: \u0026#34;no\u0026#34; TERMINAL Copy code Copied! $ cue vet -c file.cue data.yaml languages.1.Name: invalid value \u0026#34;dutch\u0026#34; (out of bound =~\u0026#34;^\\\\p{Lu}\u0026#34;): ./file.cue:4:8 ./data.yaml:4:11",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "67e3faaf4d629c0d22b95c86954546ae_1",
        "title": "Order is Irrelevant",
        "link": "/docs/tour/basics/order-irrelevance/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE\u0026rsquo;s core operations are defined so that\nthe order in which configurations are combined is unimportant.\u003cbr\u003e\nWe say that \u003cstrong\u003eorder is irrelevant\u003c/strong\u003e in CUE.\u003c/p\u003e\n\u003cp\u003eThis crucial property explains how CUE is able to handle a field being specified\n\u003ca href=\"/docs/tour/basics/unification/\"\u003emultiple times\u003c/a\u003e.\nBecause each occurrence of a field is as important as every other,\n\u003cem\u003eall\u003c/em\u003e occurrences must not conflict with each other.\u003c/p\u003e\n\u003cp\u003eOrder irrelevance makes it easy for humans \u003cem\u003eand\u003c/em\u003e machines to reason about values, and\nmakes advanced tooling and automation possible.\u003c/p\u003e",
        "content": "CUE\u0026rsquo;s core operations are defined so that the order in which configurations are combined is unimportant. We say that order is irrelevant in CUE. This crucial property explains how CUE is able to handle a field being specified multiple times. Because each occurrence of a field is as important as every other, all occurrences must not conflict with each other. Order irrelevance makes it easy for humans and machines to reason about values, and makes advanced tooling and automation possible. Copied! file.cue Copy code Copied! a: {X: 1, O: int} a: {X: int, O: 2} b: {X: int, O: 2} b: {X: 1, O: int} TERMINAL Copy code Copied! $ cue eval file.cue a: { X: 1 O: 2 } b: { X: 1 O: 2 }",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "aa775a39d03d691c79e60226ffb09538_1",
        "title": "Concise Specifications",
        "link": "/docs/tour/basics/folding-structs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE has a convenient \u003cstrong\u003eshorthand form\u003c/strong\u003e for specifying single fields concisely:\n\u003ccode\u003ea: b: c: value\u003c/code\u003e\u003cbr\u003e\nIt can be mixed freely with CUE\u0026rsquo;s other syntaxes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePattern constraints\u003c/strong\u003e apply values to multiple fields.\u003cbr\u003e\nThey affect those fields which match a pattern: \u003ccode\u003e[pattern]: value\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eA pattern constraint doesn\u0026rsquo;t \u003cem\u003especify\u003c/em\u003e those fields which match its pattern.\u003cbr\u003e\nFor instance, the pattern constraint \u0026ldquo;\u003ccode\u003e[string]: 42\u003c/code\u003e\u0026rdquo; doesn\u0026rsquo;t bring \u003cem\u003eevery\u003c/em\u003e possible \u003ccode\u003estring\u003c/code\u003e\nfield into existence!\u003c/p\u003e",
        "content": "CUE has a convenient shorthand form for specifying single fields concisely: a: b: c: value It can be mixed freely with CUE\u0026rsquo;s other syntaxes. Pattern constraints apply values to multiple fields. They affect those fields which match a pattern: [pattern]: value A pattern constraint doesn\u0026rsquo;t specify those fields which match its pattern. For instance, the pattern constraint \u0026ldquo;[string]: 42\u0026rdquo; doesn\u0026rsquo;t bring every possible string field into existence! Copied! file.cue Copy code Copied! // Specify fields concisely ... fruit: apple: weight: 5 fruit: grape: weight: 2 // ... or don\u0026#39;t. Mix and match forms as needed. fruit: { melon: weight: 9 } // Pattern constraints match multiple fields. fruit: [string]: weight: int \u0026amp; \u0026lt;10 // Pattern constraints can specify multiple fields. fruit: [string]: { isFruit: true isVegetable: !isFruit } TERMINAL Copy code Copied! $ cue export file.cue { \u0026#34;fruit\u0026#34;: { \u0026#34;apple\u0026#34;: { \u0026#34;weight\u0026#34;: 5, \u0026#34;isFruit\u0026#34;: true, \u0026#34;isVegetable\u0026#34;: false }, \u0026#34;grape\u0026#34;: { \u0026#34;weight\u0026#34;: 2, \u0026#34;isFruit\u0026#34;: true, \u0026#34;isVegetable\u0026#34;: false }, \u0026#34;melon\u0026#34;: { \u0026#34;weight\u0026#34;: 9, \u0026#34;isFruit\u0026#34;: true, \u0026#34;isVegetable\u0026#34;: false } } }",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "31ab801faf11b36de869d37bde6c2a5c_1",
        "title": "Frequently Asked Questions",
        "link": "/docs/concept/faq/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "CUE\u0026rsquo;s FAQs collect common questions about specific topics together on a single page, along with their answers.\nThe following FAQs are available:",
        "content": "CUE\u0026rsquo;s FAQs collect common questions about specific topics together on a single page, along with their answers. The following FAQs are available:",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "266e86f82fdba7530a10c3da5197db73_1",
        "title": "cue help",
        "link": "/docs/reference/command/cue-help/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help CUE makes it easy to validate data, write schemas, and ensure configurations align with policies. CUE works with a wide range of tools and formats that you\u0026#39;re already using such as Go, JSON, YAML, OpenAPI, and JSON Schema. For more information and documentation, see: https://cuelang.org Available Commands: cmd run a user-defined workflow command completion Generate completion script def print consolidated definitions eval evaluate and print a configuration export output data in a standard format fix rewrite packages to latest standards fmt formats CUE configuration files get add non-CUE dependencies to the current module import convert other formats to CUE files login log into a CUE registry mod module maintenance trim remove superfluous fields version print CUE version vet validate data Use \u0026#34;cue help [command]\u0026#34; for more information about a command.",
        "content": "TERMINAL Copy code Copied! $ cue help CUE makes it easy to validate data, write schemas, and ensure configurations align with policies. CUE works with a wide range of tools and formats that you\u0026#39;re already using such as Go, JSON, YAML, OpenAPI, and JSON Schema. For more information and documentation, see: https://cuelang.org Available Commands: cmd run a user-defined workflow command completion Generate completion script def print consolidated definitions eval evaluate and print a configuration export output data in a standard format fix rewrite packages to latest standards fmt formats CUE configuration files get add non-CUE dependencies to the current module import convert other formats to CUE files login log into a CUE registry mod module maintenance trim remove superfluous fields version print CUE version vet validate data Use \u0026#34;cue help [command]\u0026#34; for more information about a command. Additional help topics: cue help commands user-defined commands cue help embed file embedding cue help environment environment variables cue help filetypes supported file types and qualifiers cue help flags common flags for composing packages cue help injection inject files or values into specific fields for a build cue help inputs package list, patterns, and files cue help modules module support cue help registryconfig module registry configuration",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "a85457cfd81760f6c5501ec907ba0135_1",
        "title": "cue help cmd",
        "link": "/docs/reference/command/cue-help-cmd/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help cmd cmd executes the named command for each of the named instances. Workflow commands define actions on instances. For example, they may specify how to upload a configuration to Kubernetes. Workflow commands are defined directly in tool files, which are regular CUE files within the same package with a filename ending in _tool.cue. These are typically defined at the module root so that they apply to all instances.",
        "content": "TERMINAL Copy code Copied! $ cue help cmd cmd executes the named command for each of the named instances. Workflow commands define actions on instances. For example, they may specify how to upload a configuration to Kubernetes. Workflow commands are defined directly in tool files, which are regular CUE files within the same package with a filename ending in _tool.cue. These are typically defined at the module root so that they apply to all instances. Each command consists of one or more tasks. A task may, for example, load or write a file, consult a user on the command line, fetch a web page, and so on. Each task has inputs and outputs. Outputs are typically filled out by the task implementation as the task completes. Inputs of tasks my refer to outputs of other tasks. The cue tool does a static analysis of the configuration and only starts tasks that are fully specified. Upon completion of each task, cue rewrites the instance, filling in the completed task, and reevaluates which other tasks can now start, and so on until all tasks have completed. Available tasks can be found in the package documentation at https://cuelang.org/go/pkg/tool#section-directories Examples: In this simple example, we define a workflow command called \u0026#34;hello\u0026#34;, which declares a single task called \u0026#34;print\u0026#34; which uses \u0026#34;tool/exec.Run\u0026#34; to execute a shell command that echos output to the terminal: $ cat \u0026lt;\u0026lt;EOF \u0026gt; hello_tool.cue package foo import \u0026#34;tool/exec\u0026#34; city: \u0026#34;Amsterdam\u0026#34; who: *\u0026#34;World\u0026#34; | string @tag(who) // Say hello! command: hello: { print: exec.Run \u0026amp; { cmd: \u0026#34;echo Hello \\(who)! Welcome to \\(city).\u0026#34; } } EOF We run the \u0026#34;hello\u0026#34; workflow command like this: $ cue cmd hello Hello World! Welcome to Amsterdam. $ cue cmd --inject who=Jan hello Hello Jan! Welcome to Amsterdam. In this example we declare the \u0026#34;prompted\u0026#34; workflow command which has four tasks. The first task prompts the user for a string input. The second task depends on the first, and echos the response back to the user with a friendly message. The third task pipes the output from the second to a file. The fourth task pipes the output from the second to standard output (i.e. it echos it again). package foo import ( \u0026#34;tool/cli\u0026#34; \u0026#34;tool/exec\u0026#34; \u0026#34;tool/file\u0026#34; ) city: \u0026#34;Amsterdam\u0026#34; // Say hello! command: prompter: { // save transcript to this file var: file: *\u0026#34;out.txt\u0026#34; | string @tag(file) ask: cli.Ask \u0026amp; { prompt: \u0026#34;What is your name?\u0026#34; response: string } // starts after ask echo: exec.Run \u0026amp; { cmd: [\u0026#34;echo\u0026#34;, \u0026#34;Hello\u0026#34;, ask.response + \u0026#34;!\u0026#34;] stdout: string // capture stdout } // starts after echo append: file.Append \u0026amp; { filename: var.file contents: echo.stdout } // also starts after echo print: cli.Print \u0026amp; { text: echo.stdout } } Run \u0026#34;cue help commands\u0026#34; for more details on tasks and workflow commands. Usage: cue cmd \u0026lt;name\u0026gt; [inputs] [flags] Flags: -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags (default true) Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Related content Reference: cue help commands",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","workflow command"],
        "authors": ""
    },
    
            {
        "objectID": "e81eb0d0240c5533ba0802647a4b0e61_1",
        "title": "cue help commands",
        "link": "/docs/reference/command/cue-help-commands/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help commands Workflow commands define actions on instances. For example, they may specify how to upload a configuration to Kubernetes. Workflow commands are defined directly in tool files, which are regular CUE files within the same package with a filename ending in _tool.cue. These are typically defined at the module root so that they apply to all instances. Each workflow command consists of one or more tasks.",
        "content": "TERMINAL Copy code Copied! $ cue help commands Workflow commands define actions on instances. For example, they may specify how to upload a configuration to Kubernetes. Workflow commands are defined directly in tool files, which are regular CUE files within the same package with a filename ending in _tool.cue. These are typically defined at the module root so that they apply to all instances. Each workflow command consists of one or more tasks. A task may, for example, load or write a file, consult a user on the command line, fetch a web page, and so on. Each task has inputs and outputs. Outputs are typically filled out by the task implementation as the task completes. Tasks are found as regular fields underneath the top-level \u0026#34;command\u0026#34; field, excluding hidden fields and definitions. Note that regular fields may be produced by comprehensions or from the result of other tasks, which can result in discovering more tasks. To avoid this, set the CUE_EXPERIMENT=cmdreferencepkg experiment flag. Inputs of tasks my refer to outputs of other tasks. The cue tool does a static analysis of the configuration and only starts tasks that are fully specified. Upon completion of each task, cue rewrites the instance, filling in the completed task, and reevaluates which other tasks can now start, and so on until all tasks have completed. Available tasks can be found in the package documentation at https://cuelang.org/go/pkg/tool#section-directories Examples: In this simple example, we define a workflow command called \u0026#34;hello\u0026#34;, which declares a single task called \u0026#34;print\u0026#34; which uses \u0026#34;tool/exec.Run\u0026#34; to execute a shell command that echos output to the terminal: $ cat \u0026lt;\u0026lt;EOF \u0026gt; hello_tool.cue package foo import \u0026#34;tool/exec\u0026#34; city: \u0026#34;Amsterdam\u0026#34; who: *\u0026#34;World\u0026#34; | string @tag(who) // Say hello! command: hello: { print: exec.Run \u0026amp; { cmd: \u0026#34;echo Hello \\(who)! Welcome to \\(city).\u0026#34; } } EOF We run the \u0026#34;hello\u0026#34; workflow command like this: $ cue cmd hello Hello World! Welcome to Amsterdam. $ cue cmd --inject who=Jan hello Hello Jan! Welcome to Amsterdam. In this example we declare the \u0026#34;prompted\u0026#34; workflow command which has four tasks. The first task prompts the user for a string input. The second task depends on the first, and echos the response back to the user with a friendly message. The third task pipes the output from the second to a file. The fourth task pipes the output from the second to standard output (i.e. it echos it again). package foo import ( \u0026#34;tool/cli\u0026#34; \u0026#34;tool/exec\u0026#34; \u0026#34;tool/file\u0026#34; ) city: \u0026#34;Amsterdam\u0026#34; // Say hello! command: prompter: { // save transcript to this file var: file: *\u0026#34;out.txt\u0026#34; | string @tag(file) ask: cli.Ask \u0026amp; { prompt: \u0026#34;What is your name?\u0026#34; response: string } // starts after ask echo: exec.Run \u0026amp; { cmd: [\u0026#34;echo\u0026#34;, \u0026#34;Hello\u0026#34;, ask.response + \u0026#34;!\u0026#34;] stdout: string // capture stdout } // starts after echo append: file.Append \u0026amp; { filename: var.file contents: echo.stdout } // also starts after echo print: cli.Print \u0026amp; { text: echo.stdout } } The types of the commands and tasks are defined in CUE itself at cuelang.org/go/pkg/tool/tool.cue. command: [Name]: Command Command: { // Tasks specifies the things to run to complete a command. Tasks are // typically underspecified and completed by the particular internal // handler that is running them. Tasks can be a single task, or a full // hierarchy of tasks. // // Tasks that depend on the output of other tasks are run after such tasks. // Use $after if a task needs to run after another task but does not // otherwise depend on its output. Tasks // $usage summarizes how a command takes arguments. // // Example: // mycmd [-n] names $usage?: string // $short is short description of what the command does. $short?: string // $long is a longer description that spans multiple lines and // likely contain examples of usage of the command. $long?: string } // Tasks defines a hierarchy of tasks. A command completes if all // tasks have run to completion. Tasks: Task | { [name=Name]: Tasks } // Name defines a valid task or command name. Name: =~#\u0026#34;^\\PL([-](\\PL|\\PN))*$\u0026#34;# // A Task defines a step in the execution of a command. Task: { // $id indicates the operation to run. Do not use this field directly; // instead unify with a task imported from one of the tool packages. $id: =~#\u0026#34;\\.\u0026#34;# // $after can be used to specify a task is run after another one, // when it does not otherwise refer to an output of that task. $after?: Task | [...Task] } Related content Reference: cue help cmd",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","workflow command"],
        "authors": ""
    },
    
            {
        "objectID": "5a905419e10eac1873c7379badb341b9_1",
        "title": "cue help completion",
        "link": "/docs/reference/command/cue-help-completion/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help completion Generate completion script Usage: cue completion [bash zsh fish powershell] [flags] Examples: Bash: $ source \u0026lt;(cue completion bash) # To load completions for each session, execute once: Linux: $ cue completion bash \u0026gt; /etc/bash_completion.d/cue MacOS: $ cue completion bash \u0026gt; /usr/local/etc/bash_completion.d/cue Zsh: $ source \u0026lt;(cue completion zsh) # To load completions for each session, execute once: $ cue completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cue\u0026#34; Fish: $ cue completion fish | source # To load completions for each session, execute once: $ cue completion fish \u0026gt; ~/.",
        "content": "TERMINAL Copy code Copied! $ cue help completion Generate completion script Usage: cue completion [bash zsh fish powershell] [flags] Examples: Bash: $ source \u0026lt;(cue completion bash) # To load completions for each session, execute once: Linux: $ cue completion bash \u0026gt; /etc/bash_completion.d/cue MacOS: $ cue completion bash \u0026gt; /usr/local/etc/bash_completion.d/cue Zsh: $ source \u0026lt;(cue completion zsh) # To load completions for each session, execute once: $ cue completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cue\u0026#34; Fish: $ cue completion fish | source # To load completions for each session, execute once: $ cue completion fish \u0026gt; ~/.config/fish/completions/cue.fish Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "ca7f382e230532ec3b57617a6942d776_1",
        "title": "cue help def",
        "link": "/docs/reference/command/cue-help-def/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help def def prints consolidated configuration as a single file. Printing is skipped if validation fails. The --expression flag is used to only print parts of a configuration. Usage: cue def [flags] Flags: -e, --expression stringArray evaluate this expression only -f, --force force overwriting existing files -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --inline-imports expand references to non-core imports --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories --out string output format (run \u0026#39;cue help filetypes\u0026#39; for more info) -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files -A, --show-attributes display field attributes --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help def def prints consolidated configuration as a single file. Printing is skipped if validation fails. The --expression flag is used to only print parts of a configuration. Usage: cue def [flags] Flags: -e, --expression stringArray evaluate this expression only -f, --force force overwriting existing files -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --inline-imports expand references to non-core imports --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories --out string output format (run \u0026#39;cue help filetypes\u0026#39; for more info) -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files -A, --show-attributes display field attributes --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "9e501a320dff727819ca13d365d61ae9_1",
        "title": "cue help embed",
        "link": "/docs/reference/command/cue-help-embed/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help embed The @embed attribute can be used to load files as part of CUE evaluation. Embedding must be enabled by a file-level @extern(embed) attribute. Embed a single file as follows, which must exist when evaluating: @extern(embed) package foo a: _ @embed(file=foo.json) Embed many files of the same type with a glob pattern, which inserts one field per file matched: b: _ @embed(glob=images/*.*, type=binary) b: [string]: bytes Note that \u0026#34;**\u0026#34; glob patterns are not supported at this time.",
        "content": "TERMINAL Copy code Copied! $ cue help embed The @embed attribute can be used to load files as part of CUE evaluation. Embedding must be enabled by a file-level @extern(embed) attribute. Embed a single file as follows, which must exist when evaluating: @extern(embed) package foo a: _ @embed(file=foo.json) Embed many files of the same type with a glob pattern, which inserts one field per file matched: b: _ @embed(glob=images/*.*, type=binary) b: [string]: bytes Note that \u0026#34;**\u0026#34; glob patterns are not supported at this time. If the file extension in \u0026#34;file\u0026#34; or \u0026#34;glob\u0026#34; does not imply a file type, it must be specified with the \u0026#34;type\u0026#34; encoding as shown above. See the \u0026#34;filetypes\u0026#34; help topic for more. Files containing multiple documents cannot be embedded directly. For NDJSON or multi-document YAML files, embed as type=text and use APIs like yaml.Extract to decode as a list. For security reasons, only files contained in the same module can be embedded. Embedding is forbidden when outside a module. Note that embedding CUE files is not supported at this time. For the time being, embedding support can still be disabled via CUE_EXPERIMENT=embed=0. For more details and discussion, see the proposal linked from https://cuelang.org/discussion/3264.",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "7a0e673fd48fd177c6dbfed3fe3050cd_1",
        "title": "cue help environment",
        "link": "/docs/reference/command/cue-help-environment/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help environment The cue command consults environment variables for configuration. If an environment variable is unset or empty, sensible default setting is used. CUE_CACHE_DIR A directory structure to hold files which are reused between operations. It defaults to a directory for user-specific temporary data, such as: - \u0026#34;$XDG_CACHE_HOME/cue\u0026#34; or \u0026#34;$HOME/.cache/cue\u0026#34; on Linux - \u0026#34;$HOME/Library/Caches/cue\u0026#34; on MacOS - \u0026#34;%LocalAppData%/cue\u0026#34; on Windows Its contents are generally read-only and include: - mod/download for modules fetched from registries - mod/extract for extracted module archives CUE_CONFIG_DIR A directory to hold configuration and long-lived state files.",
        "content": "TERMINAL Copy code Copied! $ cue help environment The cue command consults environment variables for configuration. If an environment variable is unset or empty, sensible default setting is used. CUE_CACHE_DIR A directory structure to hold files which are reused between operations. It defaults to a directory for user-specific temporary data, such as: - \u0026#34;$XDG_CACHE_HOME/cue\u0026#34; or \u0026#34;$HOME/.cache/cue\u0026#34; on Linux - \u0026#34;$HOME/Library/Caches/cue\u0026#34; on MacOS - \u0026#34;%LocalAppData%/cue\u0026#34; on Windows Its contents are generally read-only and include: - mod/download for modules fetched from registries - mod/extract for extracted module archives CUE_CONFIG_DIR A directory to hold configuration and long-lived state files. It defaults to a directory for user-specific persistent data, such as: - \u0026#34;$XDG_CONFIG_HOME/cue\u0026#34; or \u0026#34;$HOME/.config/cue\u0026#34; on Linux - \u0026#34;$HOME/Library/Application Support/cue\u0026#34; on MacOS - \u0026#34;%AppData%/cue\u0026#34; on Windows CUE_REGISTRY The configuration to use when downloading and publishing modules. See \u0026#34;cue help registryconfig\u0026#34; for details. CUE_EXPERIMENT Comma-separated list of experiment flags to enable or disable: evalv3 (default true) Enable the new CUE evaluator, addressing performance issues and bringing a better disjunction algorithm. embed (default true) Enable support for embedded data files as described in https://cuelang.org/discussion/3264. toposort (default true) Enable topological sorting of struct fields. Provide feedback via https://cuelang.org/issue/3558 cmdreferencepkg Require referencing imported tool packages to declare \u0026#34;cue cmd\u0026#34; tasks. CUE_DEBUG Comma-separated list of debug flags to enable or disable, such as: http Log a JSON message per HTTP request and response made when interacting with module registries. sortfields Force fields in stucts to be sorted lexicographically. toolsflow Print task dependency mermaid graphs in \u0026#39;cue cmd\u0026#39;. parsertrace Print a trace of parsed CUE productions. CUE_EXPERIMENT and CUE_DEBUG are comma-separated lists of key-value strings, where the value is a boolean \u0026#34;true\u0026#34; or \u0026#34;1\u0026#34; if omitted. For example: CUE_EXPERIMENT=toenable,todisable=0",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "5720af6bfeffcc6a3e771c2162374545_1",
        "title": "cue help eval",
        "link": "/docs/reference/command/cue-help-eval/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help eval eval evaluates, validates, and prints a configuration. Printing is skipped if validation fails. The --expression flag is used to evaluate an expression within the configuration file, instead of the entire configuration file itself. Examples: $ cat \u0026lt;\u0026lt;EOF \u0026gt; foo.cue a: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] EOF $ cue eval foo.cue -e a[0] -e a[2] \u0026#34;a\u0026#34; \u0026#34;c\u0026#34; Usage: cue eval [flags] Flags: -a, --all show optional and hidden fields -c, --concrete require the evaluation to be concrete -e, --expression stringArray evaluate this expression only -f, --force force overwriting existing files -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories --out string output format (run \u0026#39;cue help filetypes\u0026#39; for more info) -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files -A, --show-attributes display field attributes -H, --show-hidden display hidden fields -O, --show-optional display optional fields --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help eval eval evaluates, validates, and prints a configuration. Printing is skipped if validation fails. The --expression flag is used to evaluate an expression within the configuration file, instead of the entire configuration file itself. Examples: $ cat \u0026lt;\u0026lt;EOF \u0026gt; foo.cue a: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] EOF $ cue eval foo.cue -e a[0] -e a[2] \u0026#34;a\u0026#34; \u0026#34;c\u0026#34; Usage: cue eval [flags] Flags: -a, --all show optional and hidden fields -c, --concrete require the evaluation to be concrete -e, --expression stringArray evaluate this expression only -f, --force force overwriting existing files -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories --out string output format (run \u0026#39;cue help filetypes\u0026#39; for more info) -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files -A, --show-attributes display field attributes -H, --show-hidden display hidden fields -O, --show-optional display optional fields --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "601275e37c85438c8bb55be3087b92b6_1",
        "title": "cue help exp",
        "link": "/docs/reference/command/cue-help-exp/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help exp exp groups commands which are still in an experimental stage. Experimental commands may be changed or removed at any time, as the objective is to gain experience and then move the feature elsewhere. Usage: cue exp \u0026lt;cmd\u0026gt; [arguments] [flags] cue exp [command] Available Commands: gengotypes generate Go types from CUE definitions Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Use \u0026#34;cue exp [command] --help\u0026#34; for more information about a command.",
        "content": "TERMINAL Copy code Copied! $ cue help exp exp groups commands which are still in an experimental stage. Experimental commands may be changed or removed at any time, as the objective is to gain experience and then move the feature elsewhere. Usage: cue exp \u0026lt;cmd\u0026gt; [arguments] [flags] cue exp [command] Available Commands: gengotypes generate Go types from CUE definitions Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Use \u0026#34;cue exp [command] --help\u0026#34; for more information about a command.",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "8cb73ec228524c5de3bdd21f58a37fc0_1",
        "title": "cue help exp gengotypes",
        "link": "/docs/reference/command/cue-help-exp-gengotypes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help exp gengotypes ARNING: THIS COMMAND IS EXPERIMENTAL. gengotypes generates Go type definitions from exported CUE definitions. The generated Go types are guaranteed to accept any value accepted by the CUE definitions, but may be more general. For example, \u0026#34;string | int\u0026#34; will translate into the Go type \u0026#34;any\u0026#34; because the Go type system is not able to express disjunctions.",
        "content": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help exp gengotypes ARNING: THIS COMMAND IS EXPERIMENTAL. gengotypes generates Go type definitions from exported CUE definitions. The generated Go types are guaranteed to accept any value accepted by the CUE definitions, but may be more general. For example, \u0026#34;string | int\u0026#34; will translate into the Go type \u0026#34;any\u0026#34; because the Go type system is not able to express disjunctions. To ensure that the resulting Go code works, any imported CUE packages or referenced CUE definitions are transitively generated as well. Generated code is placed in cue_types*_gen.go files in each CUE package directory. Generated Go type and field names may differ from the original CUE names by default. For instance, an exported definition \u0026#34;#foo\u0026#34; becomes \u0026#34;Foo\u0026#34;, and a nested definition like \u0026#34;#foo.#bar\u0026#34; becomes \u0026#34;Foo_Bar\u0026#34;. @go attributes can be used to override which name to be generated: package foo @go(betterpkgname) #Bar: { @go(BetterBarTypeName) renamed: int @go(BetterFieldName) } The attribute \u0026#34;@go(-)\u0026#34; can be used to ignore a definition or field: #ignoredDefinition: { @go(-) } ignoredField: int @go(-) \u0026#34;type=\u0026#34; overrides an entire value to generate as a given Go type expression: retypedLocal: [string]: int @go(,type=map[LocalType]int) retypedImport: [...string] @go(,type=[]\u0026#34;foo.com/bar\u0026#34;.ImportedType) \u0026#34;optional=\u0026#34; controls how CUE optional fields are generated as Go fields. The default is \u0026#34;zero\u0026#34;, representing a missing field as the zero value. \u0026#34;nillable\u0026#34; ensures the generated Go type can represent missing fields as nil. optionalDefault?: int // generates as \u0026#34;int64\u0026#34; optionalNillable?: int @go(,optional=nillable) // generates as \u0026#34;*int64\u0026#34; nested: { @go(,optional=nillable) // set for all fields under this struct } Usage: cue exp gengotypes [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "617f87d71f4456abaf0194e5d68e4bed_1",
        "title": "cue help export",
        "link": "/docs/reference/command/cue-help-export/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help export export evaluates the configuration found in the current directory and prints the emit value to stdout. Examples: Evaluated and emit # a single file cue export config.cue # multiple files: these are combined at the top-level. Order doesn\u0026#39;t matter. cue export file1.cue foo/file2.cue # all files within the \u0026#34;cloud\u0026#34; package, including all files in the # current directory and its ancestor directories that are marked with the # same package, up to the root of the containing module.",
        "content": "TERMINAL Copy code Copied! $ cue help export export evaluates the configuration found in the current directory and prints the emit value to stdout. Examples: Evaluated and emit # a single file cue export config.cue # multiple files: these are combined at the top-level. Order doesn\u0026#39;t matter. cue export file1.cue foo/file2.cue # all files within the \u0026#34;cloud\u0026#34; package, including all files in the # current directory and its ancestor directories that are marked with the # same package, up to the root of the containing module. cue export .:cloud # the package name can be omitted if the directory only contains files for # the \u0026#34;cloud\u0026#34; package. cue export Emit value: For CUE files, the generated configuration is derived from the top-level single expression, the emit value. For example, the file // config.cue arg1: 1 arg2: \u0026#34;my string\u0026#34; { a: arg1 b: arg2 } yields the following JSON: { \u0026#34;arg1\u0026#34;: 1, \u0026#34;a\u0026#34;: 1, \u0026#34;arg2\u0026#34;: \u0026#34;my string\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;my string\u0026#34; } In absence of arguments, the current directory is loaded as a package instance. A package instance for a directory contains all files in the directory and its ancestor directories, up to the module root, belonging to the same package. If a single package is not uniquely defined by the files in the current directory then the package name must be specified as an explicit argument using \u0026#34;.:\u0026lt;package-name\u0026gt;\u0026#34; syntax. Formats The following formats are recognized: cue output as CUE Outputs any CUE value. json output as JSON Outputs any CUE value. yaml output as YAML Outputs any CUE value. text output as raw text The evaluated value must be of type string. binary output as raw binary The evaluated value must be of type string or bytes. Usage: cue export [flags] Flags: --escape use HTML escaping -e, --expression stringArray export this expression only -f, --force force overwriting existing files -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories --out string output format (run \u0026#39;cue help filetypes\u0026#39; for more info) -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "94cbac38d263cccbd2b2f09861d56591_1",
        "title": "cue help filetypes",
        "link": "/docs/reference/command/cue-help-filetypes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help filetypes The cue tool supports the following file types: Tag Extensions Description cue .cue CUE source files. json .json JSON files. yaml .yaml/.yml YAML files. toml .toml TOML files jsonl .jsonl/.ndjson Line-separated JSON values. jsonschema JSON Schema. openapi OpenAPI schema. pb Use Protobuf mappings (e.g. json+pb) textproto .textproto Text-based protocol buffers. proto .proto Protocol Buffer definitions. go .go Go source files. text .",
        "content": "TERMINAL Copy code Copied! $ cue help filetypes The cue tool supports the following file types: Tag Extensions Description cue .cue CUE source files. json .json JSON files. yaml .yaml/.yml YAML files. toml .toml TOML files jsonl .jsonl/.ndjson Line-separated JSON values. jsonschema JSON Schema. openapi OpenAPI schema. pb Use Protobuf mappings (e.g. json+pb) textproto .textproto Text-based protocol buffers. proto .proto Protocol Buffer definitions. go .go Go source files. text .txt Raw text file; the evaluated value must be of type string. binary Raw binary file; the evaluated value must be of type string or bytes. OpenAPI, JSON Schema and Protocol Buffer definitions are always interpreted as schema. YAML and JSON are always interpreted as data. CUE and Go are interpreted as schema by default, but may be selected to operate in data mode. The cue tool will infer a file\u0026#39;s type from its extension by default. The user may override this behavior by using qualifiers. A qualifier takes the form \u0026lt;tag\u0026gt;{\u0026#39;+\u0026#39;\u0026lt;tag\u0026gt;}\u0026#39;:\u0026#39; For instance, cue eval json: foo.data specifies that \u0026#39;foo.data\u0026#39; should be read as a JSON file. File formats that do not have a default extension may be represented in any data format using the same notation: cue def jsonschema: bar.cue foo.yaml openapi+yaml: baz.def interprets the files bar.cue and foo.yaml as data in the respective formats encoding an JSON Schema, while \u0026#39;baz.def\u0026#39; is defined to be a YAML file which contents encode OpenAPI definitions. A qualifier applies to all files following it on the command line until the next qualifier. The cue tool does not allow a \u0026#39;:\u0026#39; in filenames. The following tags can be used in qualifiers to further influence input or output. For input these act as restrictions, validating the input. For output these act as filters, showing only the requested data and picking defaults as requested. Tag Description data Require concrete input and output that does not require any evaluation. graph Like data, but allow references. schema Export data and definitions. The following tags are only valid in combination with other tags, and influence the functioning of the codec. The tag they are valid with is mentioned in parentheses at the end. strictFeatures report errors for lossy mappings. (jsonschema) strictKeywords report errors for unknown keywords (jsonschema) strict report errors for either of the above (jsonschema) Many commands also support the --out and --outfile/-o flags. The --out flag specifies the output type using a qualifier (without the \u0026#39;:\u0026#39;). The -o flag specifies an output file possibly prefixed with a qualifier. Examples: # Interpret bar.cue and foo.yaml as OpenAPI data. $ cue def openapi: bar.cue foo.yaml # Write a CUE package as OpenAPI encoded as YAML, using # an alternate file extension. $ cue def -o openapi+yaml:foo.openapi # Print the data for the current package as YAML. $ cue export --out=yaml # Print the string value of the \u0026#34;name\u0026#34; field as a string. $ cue export -e name --out=text # Write the string value of the \u0026#34;name\u0026#34; field to a text file. $ cue export -e name -o=foo.txt # Write the string value of the \u0026#34;name\u0026#34; field to a file foo. $ cue export -e name -o=text:foo",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "b8dba44a3d1a2799d2b10bead8b46a92_1",
        "title": "cue help fix",
        "link": "/docs/reference/command/cue-help-fix/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help fix Fix finds CUE programs that use old syntax and old APIs and rewrites them to use newer ones. After you update to a new CUE release, fix helps make the necessary changes to your program. Without any packages, fix applies to all files within a module. Usage: cue fix [packages] [flags] Flags: -f, --force rewrite even when there are errors Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help fix Fix finds CUE programs that use old syntax and old APIs and rewrites them to use newer ones. After you update to a new CUE release, fix helps make the necessary changes to your program. Without any packages, fix applies to all files within a module. Usage: cue fix [packages] [flags] Flags: -f, --force rewrite even when there are errors Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "f35b756104c8044c99f544573b310dc9_1",
        "title": "cue help flags",
        "link": "/docs/reference/command/cue-help-flags/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help flags Non-CUE files are merged at their roots by default. The can be combined differently or treated as different files by using a combination of the following flags. Individual files To treat non-cue files as individual files, use --no-merge flag. This is the default for vet. This flag only applies to data files when used in combination with the --schema/-d flag. Assigning values to a CUE path The --path/-l flag can be used to specify a CUE path at which to place a value.",
        "content": "TERMINAL Copy code Copied! $ cue help flags Non-CUE files are merged at their roots by default. The can be combined differently or treated as different files by using a combination of the following flags. Individual files To treat non-cue files as individual files, use --no-merge flag. This is the default for vet. This flag only applies to data files when used in combination with the --schema/-d flag. Assigning values to a CUE path The --path/-l flag can be used to specify a CUE path at which to place a value. Each -l flag specifies either a CUE expression or a CUE field (without the value following the colon), both of which are evaluated within the value. Together, the -l flags specify the path at increasingly deeper nesting. An expression may refer to builtin packages as long as the name can be uniquely identified. The --with-context flag can be used to evaluate the label expression within a struct of contextual data, instead of within the value itself. This struct has the following fields: { // data holds the original source data // (perhaps one of several records in a file). data: _ // filename holds the full path to the file. filename: string // index holds the 0-based index element of the // record within the file. For files containing only // one record, this will be 0. index: uint \u0026amp; \u0026lt;recordCount // recordCount holds the total number of records // within the file. recordCount: int \u0026amp; \u0026gt;=1 } Handling multiple documents or streams To handle multi-document files, such as JSON Lines or YAML files with document separators (---), the user must specify the --path, --list, or --files flag. The --path flag merges each element into a single package as if each element was defined in a separate file. The --list flag concatenates each entry in a file into a list. Using --list flag in combination with the --path flag concatenates entries with the same path into a list, instead of unifying them. Finally, the --files option causes each entry to be written to a different file. The -files flag may only be used in combination with the import command. Examples: # Put a value at a path based on its \u0026#34;kind\u0026#34; and \u0026#34;name\u0026#34; fields. $ cue eval -l \u0026#39;strings.ToLower(kind)\u0026#39; -l name foo.yaml # Include a schema under the \u0026#34;myschema\u0026#34; field using the path notation. $ cue eval -l myschema: schema: foo.json # Base the path values on its kind and file name. $ cue eval --with-context -l \u0026#39;path.Base(filename)\u0026#39; -l data.kind foo.yaml",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "1a5f236dc0dd60d8ed14675eaa8091ac_1",
        "title": "cue help fmt",
        "link": "/docs/reference/command/cue-help-fmt/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help fmt Fmt formats the given files or the files for the given packages in place Arguments are interpreted as import paths (see \u0026#39;cue help inputs\u0026#39;) unless --files is set, in which case the arguments are file paths to descend into and format all CUE files. Directories named \u0026#34;cue.mod\u0026#34; and those beginning with \u0026#34;.\u0026#34; and \u0026#34;_\u0026#34; are skipped unless given as explicit arguments. Usage: cue fmt [-s] [inputs] [flags] Flags: --check exits with non-zero status if any files are not formatted -d, --diff display diffs instead of rewriting files --files treat arguments as file paths to descend into rather than import paths Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help fmt Fmt formats the given files or the files for the given packages in place Arguments are interpreted as import paths (see \u0026#39;cue help inputs\u0026#39;) unless --files is set, in which case the arguments are file paths to descend into and format all CUE files. Directories named \u0026#34;cue.mod\u0026#34; and those beginning with \u0026#34;.\u0026#34; and \u0026#34;_\u0026#34; are skipped unless given as explicit arguments. Usage: cue fmt [-s] [inputs] [flags] Flags: --check exits with non-zero status if any files are not formatted -d, --diff display diffs instead of rewriting files --files treat arguments as file paths to descend into rather than import paths Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "fefcc06a977d9271b27491c00670b570_1",
        "title": "cue help get",
        "link": "/docs/reference/command/cue-help-get/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help get Get downloads packages or modules for non-CUE languages to include them in the module\u0026#39;s pkg directory. Get requires an additional language field to determine for which language definitions should be fetched. Definitions are extracted from the source of the respective language and stored. The specifics on how dependencies are fetched and converted vary per language and are documented in the respective subcommands.",
        "content": "TERMINAL Copy code Copied! $ cue help get Get downloads packages or modules for non-CUE languages to include them in the module\u0026#39;s pkg directory. Get requires an additional language field to determine for which language definitions should be fetched. Definitions are extracted from the source of the respective language and stored. The specifics on how dependencies are fetched and converted vary per language and are documented in the respective subcommands. For information on native CUE modules: cue help modules Usage: cue get \u0026lt;language\u0026gt; [packages] [flags] cue get [command] Available Commands: go add Go dependencies to the current module Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Use \u0026#34;cue get [command] --help\u0026#34; for more information about a command.",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "462af8cff2245582d2930992d787abbb_1",
        "title": "cue help get go",
        "link": "/docs/reference/command/cue-help-get-go/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help get go go converts Go types into CUE definitions The command \u0026#34;cue get go\u0026#34; is like \u0026#34;go get\u0026#34;, but converts the retrieved Go packages to CUE. The retrieved packages are put in the CUE module\u0026#39;s pkg directory at the import path of the corresponding Go package. The converted definitions are available to any CUE file within the CUE module by using this import path.",
        "content": "TERMINAL Copy code Copied! $ cue help get go go converts Go types into CUE definitions The command \u0026#34;cue get go\u0026#34; is like \u0026#34;go get\u0026#34;, but converts the retrieved Go packages to CUE. The retrieved packages are put in the CUE module\u0026#39;s pkg directory at the import path of the corresponding Go package. The converted definitions are available to any CUE file within the CUE module by using this import path. The Go type definitions are converted to CUE based on how they would be interpreted by Go\u0026#39;s encoding/json package. Definitions for a Go file foo.go are written to a CUE file named foo_go_gen.cue. It is safe for users to add additional files to the generated directories, as long as their name does not end with _gen.*. Rules of Converting Go types to CUE Go structs are converted to cue structs adhering to the following conventions: - field names are translated based on the definition of a \u0026#34;json\u0026#34; or \u0026#34;yaml\u0026#34; tag, in that order. - embedded structs marked with a json inline tag unify with struct definition. For instance, the Go struct struct MyStruct { Common json:\u0026#34;,inline\u0026#34; Field string } translates to the CUE struct #MyStruct: Common \u0026amp; { Field: string } - a type that implements MarshalJSON, UnmarshalJSON, MarshalYAML, or UnmarshalYAML is translated to top (_) to indicate it may be any value. For some Go core types for which the implementation of these methods is known, like time.Time, the type may be more specific. - a type implementing MarshalText or UnmarshalText is represented as the CUE type string - slices and arrays convert to CUE lists, except when the element type is byte, in which case it translates to the CUE bytes type. In the case of arrays, the length of the CUE value is constrained accordingly, when possible. - Maps translate to a CUE struct, where all elements are constrained to be of Go map element type. Like for JSON, maps may only have string keys. - Pointers translate to a sum type with the default value of null and the Go type as an alternative value. - Field tags are translated to CUE\u0026#39;s field attributes. In some cases, the contents are rewritten to reflect the corresponding types in CUE. The @go attribute is added if the field name or type definition differs between the generated CUE and the original Go. Native CUE Constraints Native CUE constraints may be defined in separate cue files alongside the generated files either in the original Go directory or in the generated directory. These files can impose additional constraints on types and values that are not otherwise expressible in Go. The package name for these CUE files must be the same as that of the Go package. For instance, for the type package foo type IP4String string defined in the Go package, one could add a cue file foo.cue with the following contents to allow IP4String to assume only valid IP4 addresses: package foo // IP4String defines a valid IP4 address. #IP4String: =~#\u0026#34;^\\#(byte)\\.\\#(byte)\\.\\#(byte)\\.\\#(byte)$\u0026#34;# // byte defines string allowing integer values of 0-255. byte = #\u0026#34;([01]?\\d?\\d|2[0-4]\\d|25[0-5])\u0026#34;# The \u0026#34;cue get go\u0026#34; command copies any cue files in the original Go package directory that has a package clause with the same name as the Go package to the destination directory, replacing its .cue ending with _gen.cue. Alternatively, the additional native constraints can be added to the generated package, as long as the file name does not end with _gen.cue. Running cue get go again to regenerate the package will never overwrite any files not ending with _gen.*. Constants and Enums Go does not have an enum or sum type. Conventionally, a type that is supposed to be an enum is followed by a const block with the allowed values for that type. However, as that is only a guideline and not a hard rule, these cases cannot be translated to CUE disjunctions automatically. Constant values, however, are generated in a way that makes it easy to convert a type to a proper enum using native CUE constraints. For instance, the Go type package foo type Switch int const ( Off Switch = iota On ) translates into the following CUE definitions: package foo #Switch: int // #enumSwitch #enumSwitch: Off | On Off: 0 On: 1 This definition allows any integer value for #Switch, while the #enumSwitch value defines all defined constants for Switch and thus all valid values if #Switch were to be interpreted as an enum type. To turn #Switch into an enum, include the following constraint in, say, enum.cue, in either the original source directory or the generated directory: package foo // limit the valid values for Switch to those existing as constants with // the same type. #Switch: #enumSwitch This tells CUE that only the values enumerated by #enumSwitch are valid values for #Switch. Note that there are now two definitions of #Switch. CUE handles this in the usual way by unifying the two definitions, in which case the more restrictive enum interpretation of #Switch remains. Usage: cue get go [packages] [flags] Flags: -e, --exclude string comma-separated list of regexps of identifiers to omit --local generates files in the main module locally -p, --package string package name for generated CUE files Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "3cec68e34e97750e18f83c3496033770_1",
        "title": "cue help import",
        "link": "/docs/reference/command/cue-help-import/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help import import converts other formats, like JSON and YAML to CUE files Files can either be specified explicitly, or inferred from the specified packages. Within packages, import only looks for JSON and YAML files by default (see the \u0026#34;filetypes\u0026#34; help topic for more info). This behavior can be overridden by specifying one of the following modes: Mode Extensions json Look for JSON files (.",
        "content": "TERMINAL Copy code Copied! $ cue help import import converts other formats, like JSON and YAML to CUE files Files can either be specified explicitly, or inferred from the specified packages. Within packages, import only looks for JSON and YAML files by default (see the \u0026#34;filetypes\u0026#34; help topic for more info). This behavior can be overridden by specifying one of the following modes: Mode Extensions json Look for JSON files (.json .jsonl .ndjson). yaml Look for YAML files (.yaml .yml). toml Look for TOML files (.toml). text Look for text files (.txt). binary Look for files with extensions specified by --ext and interpret them as binary. jsonschema Interpret JSON, YAML or CUE files as JSON Schema. openapi Interpret JSON, YAML or CUE files as OpenAPI. auto Look for JSON or YAML files and interpret them as data, JSON Schema, or OpenAPI, depending on existing fields. data Look for JSON or YAML files and interpret them as data. proto Convert Protocol buffer definition files and transitive dependencies. Using the --ext flag in combination with a mode causes matched files to be interpreted as the format indicated by the mode, overriding any other meaning attributed to that extension. auto mode In auto mode, data files are interpreted based on some marker fields. JSON Schema is identified by a top-level \u0026#34;$schema\u0026#34; field with a URL of the form \u0026#34;https?://json-schema.org/.*schema#?\u0026#34;. OpenAPI is identified by the existence of a top-level field \u0026#34;openapi\u0026#34;, which must have a major semantic version of 3, and the info.title and info.version fields. proto mode Proto mode converts .proto files containing Prototcol Buffer definitions to CUE. The -I defines the path for includes. The module root is added implicitly if it exists. The package name for a converted file is derived from the go_package option. It can be overridden with the -p flag. A module root must be specified if a .proto files includes other files within the module. Files include from outside the module are also imported and stored within the cue.mod directory. The import path is defined by either the go_package option or, in the absence of this option, the googleapis.com/\u0026lt;proto package\u0026gt; convention. The following command imports all .proto files in all subdirectories as well all dependencies. cue import proto -I ../include ./... The module root is implicitly added as an import path. Binary mode Loads matched files as binary. JSON/YAML mode The -f option allows overwriting of existing files. This only applies to files generated for explicitly specified files or files contained in explicitly specified packages. Use the -R option in addition to overwrite files generated for transitive dependencies (files written to cue.mod/gen/...). The -n option is a regexp used to filter file names in the matched package directories. The -I flag is used to specify import paths for proto mode. The module root is implicitly added as an import if it exists. Examples: # Convert individual files: $ cue import foo.json bar.json # create foo.cue and bar.cue # Convert all json files in the indicated directories: $ cue import json ./... The \u0026#34;flags\u0026#34; help topic describes how to assign values to a specific path within a CUE namespace. Some examples of that Examples: $ cat \u0026lt;\u0026lt;EOF \u0026gt; foo.yaml kind: Service name: booster EOF # include the parsed file as an emit value: $ cue import foo.yaml $ cat foo.cue { kind: Service name: booster } # include the parsed file at the root of the CUE file: $ cue import -f foo.yaml $ cat foo.cue kind: Service name: booster # include the import config at the mystuff path $ cue import -f -l \u0026#39;\u0026#34;mystuff\u0026#34;\u0026#39; foo.yaml $ cat foo.cue myStuff: { kind: Service name: booster } # append another object to the input file $ cat \u0026lt;\u0026lt;EOF \u0026gt;\u0026gt; foo.yaml --- kind: Deployment name: booster replicas: 1 EOF # base the path values on the input $ cue import -f -l \u0026#39;strings.ToLower(kind)\u0026#39; -l name foo.yaml $ cat foo.cue service: booster: { kind: \u0026#34;Service\u0026#34; name: \u0026#34;booster\u0026#34; } # base the path values on the input and file name $ cue import -f --with-context -l \u0026#39;path.Base(filename)\u0026#39; -l data.kind foo.yaml $ cat foo.cue \u0026#34;foo.yaml\u0026#34;: Service: { kind: \u0026#34;Service\u0026#34; name: \u0026#34;booster\u0026#34; } \u0026#34;foo.yaml\u0026#34;: Deployment: { kind: \u0026#34;Deployment\u0026#34; name: \u0026#34;booster replicas: 1 } # include all files as list elements $ cue import -f --list foo.yaml $ cat foo.cue [{ kind: \u0026#34;Service\u0026#34; name: \u0026#34;booster\u0026#34; }, { kind: \u0026#34;Deployment\u0026#34; name: \u0026#34;booster replicas: 1 }] # collate files with the same path into a list $ cue import -f -list -l \u0026#39;strings.ToLower(kind)\u0026#39; foo.yaml $ cat foo.cue service: [{ kind: \u0026#34;Service\u0026#34; name: \u0026#34;booster\u0026#34; } deployment: [{ kind: \u0026#34;Deployment\u0026#34; name: \u0026#34;booster replicas: 1 }] Embedded data files The --recursive or -R flag enables the parsing of fields that are string representations of data formats themselves. A field that can be parsed is replaced with a call encoding the data from a structured form that is placed in a sibling field. It is also possible to recursively hoist data formats: Example: $ cat \u0026lt;\u0026lt;EOF \u0026gt; example.json \u0026#34;a\u0026#34;: { \u0026#34;data\u0026#34;: \u0026#39;{ \u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2 }\u0026#39;, } EOF $ cue import -R example.json $ cat example.cue import \u0026#34;encoding/json\u0026#34; a: { data: json.Encode(_data), _data = { foo: 1 bar: 2 } } Usage: cue import [mode] [inputs] [flags] Flags: --dry-run show what files would be created --ext stringArray match files with these extensions --files split multiple entries into different files -f, --force force overwriting existing files --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -R, --recursive recursively parse string values -d, --schema string expression to select schema for evaluating values in non-CUE files --with-context",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "3cec68e34e97750e18f83c3496033770_2",
        "title": "cue help import",
        "link": "/docs/reference/command/cue-help-import/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help import import converts other formats, like JSON and YAML to CUE files Files can either be specified explicitly, or inferred from the specified packages. Within packages, import only looks for JSON and YAML files by default (see the \u0026#34;filetypes\u0026#34; help topic for more info). This behavior can be overridden by specifying one of the following modes: Mode Extensions json Look for JSON files (.",
        "content": "import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "5586fc5f83a9991002a96429b108cbf0_1",
        "title": "cue help injection",
        "link": "/docs/reference/command/cue-help-injection/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help injection Many of the cue commands allow injecting values or selecting files from the command line using the --inject/-t flag. Injecting files A \u0026#34;build\u0026#34; attribute defines a boolean expression that causes a file to only be included in a build if its expression evaluates to true. There may only be a single @if attribute per file and it must appear before a package clause, or before any CUE declarations if there is no package clause.",
        "content": "TERMINAL Copy code Copied! $ cue help injection Many of the cue commands allow injecting values or selecting files from the command line using the --inject/-t flag. Injecting files A \u0026#34;build\u0026#34; attribute defines a boolean expression that causes a file to only be included in a build if its expression evaluates to true. There may only be a single @if attribute per file and it must appear before a package clause, or before any CUE declarations if there is no package clause. The expression is a subset of CUE consisting only of identifiers and the operators \u0026amp;\u0026amp;, ||, !, where identifiers refer to tags defined by the user on the command line. For example, the following file will only be included in a build if the user includes the flag \u0026#34;-t prod\u0026#34; on the command line. // File prod.cue @if(prod) package foo Ignoring files An \u0026#34;ignore\u0026#34; attribute causes a file to be unconditionally excluded from a build. The @ignore attribute must appear before a package clause or before any other CUE syntax if there is no package clause. For example: @ignore() // This file will be excluded for all purposes. package foo Injecting values The injection mechanism allows values to be injected into fields that are not defined within the scope of a comprehension, list, or optional field and that are marked with a \u0026#34;tag\u0026#34; attribute. For any field of the form field: x @tag(key) an \u0026#34;--inject key=value\u0026#34; flag will modify the field to field: x \u0026amp; \u0026#34;value\u0026#34; By default, the injected value is treated as a string. Alternatively, the \u0026#34;type\u0026#34; option allows a value to be interpreted as an int, number, or bool. For instance, for a field field: x @tag(key,type=int) the flag \u0026#34;-t key=2\u0026#34; modifies the field to field: x \u0026amp; 2 Valid values for type are \u0026#34;int\u0026#34;, \u0026#34;number\u0026#34;, \u0026#34;bool\u0026#34;, and \u0026#34;string\u0026#34;. A tag attribute can also define shorthand values, which can be injected into the fields without having to specify the key. For instance, for environment: string @tag(env,short=prod|staging) \u0026#34;-t prod\u0026#34; sets the environment field to the value \u0026#34;prod\u0026#34;. It is still possible to specify \u0026#34;-t env=prod\u0026#34; in this case. Use the usual CUE constraints to limit the possible values of a field. For instance environment: \u0026#34;prod\u0026#34; | \u0026#34;staging\u0026#34; @tag(env,short=prod|staging) ensures the user may only specify \u0026#34;prod\u0026#34; or \u0026#34;staging\u0026#34;. Tag variables The injection mechanism allows for the injection of system variables: when variable injection is enabled by passing the --inject-vars/-T flag, tags of the form @tag(dir,var=cwd) will inject the named variable (here cwd) into the tag. An explicitly set value for a tag using --inject/-t takes precedence over an available tag variable. The following variables are supported: now current time in RFC3339 format. os OS identifier of the current system. Valid values: aix android darwin dragonfly freebsd illumos ios js (wasm) linux netbsd openbsd plan9 solaris windows arch architecture identifier of the current system. Valid values: 386 amd64 amd64p32 arm armbe arm64 arm64be loong64 mips mipsle mips64 mips64le mips64p32 mips64p32le ppc ppc64 ppc64le riscv riscv64 s390 s390x sparc sparc64 wasm cwd working directory username current username hostname current hostname rand a random 128-bit integer",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "5e3b271e7154c54066074900c6be4742_1",
        "title": "cue help inputs",
        "link": "/docs/reference/command/cue-help-inputs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help inputs Many commands apply to a set of inputs: cue \u0026lt;command\u0026gt; [inputs] The list [inputs] may specify CUE packages, CUE files, non-CUE files or some combinations of those. An empty list specifies the package in the current directory, provided there is a single named package in this directory. CUE packages are specified as an import path. An import path that begins with a \u0026#34;.",
        "content": "TERMINAL Copy code Copied! $ cue help inputs Many commands apply to a set of inputs: cue \u0026lt;command\u0026gt; [inputs] The list [inputs] may specify CUE packages, CUE files, non-CUE files or some combinations of those. An empty list specifies the package in the current directory, provided there is a single named package in this directory. CUE packages are specified as an import path. An import path that begins with a \u0026#34;.\u0026#34; or \u0026#34;..\u0026#34; element is a relative import path, is interpreted as a file system path, and denotes the package instance in that directory. Otherwise, the import path P is absolute and denotes a package that may be external, usually found in an external registry. It may also refer to a package in cue.mod/{pkg|gen|usr}/P - this is legacy behavior that might be removed at a later date. An absolute import path is of the form P or P@vN where vN is the major version of the module containing the package. An import path is mapped to a registry location by consulting cue.mod/module.cue and the registry configuration (see \u0026#34;cue help modules\u0026#34; and \u0026#34;cue help registryconfig\u0026#34; for more details). An import may contain a \u0026#34;:name\u0026#34; suffix to indicate a specific package to load within a given path. It is necessary to specify this when there is more than one package at the path. For example, the following import path specifies a package named \u0026#34;other\u0026#34; in some external module with major version v1. foo.example/bar/baz@v1:other A local import path may contain one or more \u0026#34;...\u0026#34; to match any subdirectory: pkg/... matches all packages below pkg, including pkg itself, while foo/.../bar matches all directories named bar within foo. In all cases, directories containing cue.mod directories are excluded from the result. \u0026#34;...\u0026#34; is not currently supported in external import paths. Directory and file names that begin with \u0026#34;.\u0026#34; or \u0026#34;_\u0026#34; are ignored, unless explicitly listed as inputs. File with names ending \u0026#34;_tool.cue\u0026#34; are ignored unless running \u0026#34;cue cmd\u0026#34; and they are in packages explicitly mentioned on the command line. Files with names ending \u0026#34;_test.cue\u0026#34; are ignored for the time being; they are reserved for future testing functionality. A package may also be specified as a list of .cue files. The special symbol \u0026#39;-\u0026#39; denotes stdin or stdout and defaults to the cue file type for stdin. For stdout, the default depends on the cue command. A .cue file package may not be combined with regular packages. Non-cue files are interpreted based on their file extension or, if present, an explicit file qualifier (see the \u0026#34;filetypes\u0026#34; help topic). By default, all recognized files are unified at their root value. See the \u0026#34;filetypes\u0026#34; and \u0026#34;flags\u0026#34; help topics on how to treat each file individually or how to combine them differently. If a data file has multiple values, such as allowed with JSON Lines or YAML, each value is interpreted as a separate file. If the --schema/-d is specified, data files are not merged, and are compared against the specified schema within a package or non-data file. For OpenAPI, the -d flag specifies a schema name. For JSON Schema the -d flag specifies a schema defined in \u0026#34;definitions\u0026#34;. In all other cases, the -d flag is a CUE expression that is evaluated within the package. Examples (also see also \u0026#34;flags\u0026#34; and \u0026#34;filetypes\u0026#34; help topics): # Show the definition of each package named foo for each # directory dir under path. $ cue def ./path/.../dir:foo # Unify each document in foo.yaml with the value Foo in pkg. $ cue export ./pkg -d Foo foo.yaml # Unify data.json with schema.json. $ cue export data.json schema: schema.json",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "bd97a901e517bd38516792b6ee168d8f_1",
        "title": "cue help login",
        "link": "/docs/reference/command/cue-help-login/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help login Log into a CUE registry via the OAuth 2.0 Device Authorization Grant. Without an argument, CUE_REGISTRY is used if it points to a single registry. Use the --token flag to provide a token generated via the web interface, removing the need for a human to interact with the OAuth device flow. Once the authorization is successful, a token is stored in a logins.",
        "content": "TERMINAL Copy code Copied! $ cue help login Log into a CUE registry via the OAuth 2.0 Device Authorization Grant. Without an argument, CUE_REGISTRY is used if it points to a single registry. Use the --token flag to provide a token generated via the web interface, removing the need for a human to interact with the OAuth device flow. Once the authorization is successful, a token is stored in a logins.json file inside $CUE_CONFIG_DIR; see \u0026#39;cue help environment\u0026#39;. Usage: cue login [registry] [flags] Flags: --token string provide an access token rather than starting the OAuth device flow Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "d7cad037d762526bb9957b0eac58c034_1",
        "title": "cue help mod",
        "link": "/docs/reference/command/cue-help-mod/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod Mod groups commands which operate on CUE modules. Note that support for modules is built into all the cue commands, not just \u0026#39;cue mod\u0026#39;. See also: cue help modules Usage: cue mod \u0026lt;cmd\u0026gt; [arguments] [flags] cue mod [command] Available Commands: edit edit cue.mod/module.cue fix fix a legacy cue.mod/module.cue file get add and upgrade module dependencies init initialize new module in current directory mirror mirror module content between registries publish publish the current module to a registry rename rename the current module resolve Show how a module path resolves to a registry tidy download and tidy module dependencies Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Use \u0026#34;cue mod [command] --help\u0026#34; for more information about a command.",
        "content": "TERMINAL Copy code Copied! $ cue help mod Mod groups commands which operate on CUE modules. Note that support for modules is built into all the cue commands, not just \u0026#39;cue mod\u0026#39;. See also: cue help modules Usage: cue mod \u0026lt;cmd\u0026gt; [arguments] [flags] cue mod [command] Available Commands: edit edit cue.mod/module.cue fix fix a legacy cue.mod/module.cue file get add and upgrade module dependencies init initialize new module in current directory mirror mirror module content between registries publish publish the current module to a registry rename rename the current module resolve Show how a module path resolves to a registry tidy download and tidy module dependencies Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Use \u0026#34;cue mod [command] --help\u0026#34; for more information about a command. Related content Reference: cue help modules Reference: cue help mod edit Reference: cue help mod fix Reference: cue help mod get Reference: cue help mod init Reference: cue help mod publish Reference: cue help mod rename Reference: cue help mod resolve Reference: cue help mod tidy",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "a309872debeee0de329d5c2f6c1916c1_1",
        "title": "cue help mod edit",
        "link": "/docs/reference/command/cue-help-mod-edit/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod edit Edit provides a command-line interface for editing cue.mod/module.cue. It reads only that file; it does not look up information about the modules involved. The editing flags specify a sequence of editing operations. The -require=path@version and -drop-require=path@majorversion flags add and drop a requirement on the given module path and version. Note that -require overrides any existing requirements on path. These flags are mainly for tools that understand the module graph.",
        "content": "TERMINAL Copy code Copied! $ cue help mod edit Edit provides a command-line interface for editing cue.mod/module.cue. It reads only that file; it does not look up information about the modules involved. The editing flags specify a sequence of editing operations. The -require=path@version and -drop-require=path@majorversion flags add and drop a requirement on the given module path and version. Note that -require overrides any existing requirements on path. These flags are mainly for tools that understand the module graph. Users should prefer \u0026#39;cue mod get path@version\u0026#39; which makes other cue.mod adjustments as needed to satisfy constraints imposed by other modules. The --module flag changes the module\u0026#39;s path (the module.cue file\u0026#39;s module field). The --source flag changes the module\u0026#39;s declared source. The --drop-source flag removes the source field. Note that this command is not yet stable and may be changed. Usage: cue mod edit [flags] Flags: --drop-require string remove a requirement --drop-source remove the source field (default ) --language-version string set language.version (\u0026#39;current\u0026#39; means current language version) --module string set the module path --require string add a required module@version --source string set the source field Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "176d4d7816b4b703521fabe234ab5c11_1",
        "title": "cue help mod fix",
        "link": "/docs/reference/command/cue-help-mod-fix/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod fix Fix provides a way to migrate from a legacy module.cue file to the new standard syntax. It - adds a language.version field - moves unrecognized fields into the custom.legacy field - adds a major version to the module path If there is no module path, it chooses an arbitrary path (test.example@v0). If the module.cue file is already compatible with the new syntax, it is just formatted without making any other changes.",
        "content": "TERMINAL Copy code Copied! $ cue help mod fix Fix provides a way to migrate from a legacy module.cue file to the new standard syntax. It - adds a language.version field - moves unrecognized fields into the custom.legacy field - adds a major version to the module path If there is no module path, it chooses an arbitrary path (test.example@v0). If the module.cue file is already compatible with the new syntax, it is just formatted without making any other changes. Note that this command is not yet stable and may be changed. Usage: cue mod fix [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "51892304d3bd03aa4794bb71dbe5f39f_1",
        "title": "cue help mod get",
        "link": "/docs/reference/command/cue-help-mod-get/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod get Get updates module dependencies, fetching new dependencies if needed and changing versions to specified versions. It can downgrade a version only when a higher version is not required by other dependencies. Each argument specifies a module path and optionally a version suffix. If there is no version suffix, the latest non-prerelease version of the module will be requested; alternatively a suffix of \u0026#34;@latest\u0026#34; also specifies the latest version.",
        "content": "TERMINAL Copy code Copied! $ cue help mod get Get updates module dependencies, fetching new dependencies if needed and changing versions to specified versions. It can downgrade a version only when a higher version is not required by other dependencies. Each argument specifies a module path and optionally a version suffix. If there is no version suffix, the latest non-prerelease version of the module will be requested; alternatively a suffix of \u0026#34;@latest\u0026#34; also specifies the latest version. A version suffix can contain a major version only (@v1), a major and minor version (@v1.2) or full version (@v1.2.3). If minor or patch version is omitted, the latest non-prerelease version will be chosen that has the same major and minor versions. If the desired version cannot be chosen (for example because a dependency already uses a later version than the desired version), this command will fail. See \u0026#34;cue help environment\u0026#34; for details on how $CUE_REGISTRY is used to determine the modules registry. Note that this command is not yet stable and may be changed. Usage: cue mod get [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Related content Reference: cue help environment",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "4895f90f8a9c9c42140931f177c7d1ff_1",
        "title": "cue help mod init",
        "link": "/docs/reference/command/cue-help-mod-init/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod init Init initializes a cue.mod directory in the current directory, in effect creating a new module rooted at the current directory. The cue.mod directory must not already exist. A legacy cue.mod file in the current directory is moved to the new subdirectory. If the module name is not provided, a default module path (cue.example) will be used. Usage: cue mod init [module] [flags] Flags: -f, --force force moving old-style cue.",
        "content": "TERMINAL Copy code Copied! $ cue help mod init Init initializes a cue.mod directory in the current directory, in effect creating a new module rooted at the current directory. The cue.mod directory must not already exist. A legacy cue.mod file in the current directory is moved to the new subdirectory. If the module name is not provided, a default module path (cue.example) will be used. Usage: cue mod init [module] [flags] Flags: -f, --force force moving old-style cue.mod file --language-version string set the language version (\u0026#39;current\u0026#39; means current language version) (default \u0026#34;current\u0026#34;) --source string set the source field Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "0349538361538c97b1fd37ae9ada6424_1",
        "title": "cue help mod mirror",
        "link": "/docs/reference/command/cue-help-mod-mirror/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help mod mirror WARNING: THIS COMMAND IS EXPERIMENTAL. This commmand ensures that a set of modules and their dependencies are available (\u0026#34;mirrored\u0026#34;) in a registry. For each module specified on the command line, it ensures that the module and all the modules it depends on are present in both the \u0026#34;from\u0026#34; registry and the \u0026#34;to\u0026#34; registry, and that the contents are the same in each.",
        "content": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help mod mirror WARNING: THIS COMMAND IS EXPERIMENTAL. This commmand ensures that a set of modules and their dependencies are available (\u0026#34;mirrored\u0026#34;) in a registry. For each module specified on the command line, it ensures that the module and all the modules it depends on are present in both the \u0026#34;from\u0026#34; registry and the \u0026#34;to\u0026#34; registry, and that the contents are the same in each. If --no-deps is specified then the module will be mirrored without its dependencies. A module may be specified as \u0026lt;module\u0026gt;@\u0026lt;version\u0026gt;, in which case the specified version will be mirrored. If the version is canonical (for example v1.2.3), then exactly that version will be mirrored, otherwise (for example v1) the latest corresponding version will be mirrored (or all corresponding versions if --all-versions is specified). For example: # Copy from $CUE_REGISTRY (usually the Central Registry) to my.registry.example cue mod mirror --to my.registry.example foo.com/m1@v1.2.3 bar.org@v2 will copy the exact module foo.com/m1@v1.2.3 but the latest version of bar.org@2, or all v2.x.y versions if --all-versions is given. If no major version is specified, the latest major version will be chosen. By default the latest version is chosen by consulting the source registry, unless the --mod flag is specified, in which case the current module\u0026#39;s dependencies will be used. When --mod is given and no modules are specified on the command line, all the current module\u0026#39;s dependencies will be mirrored. Note that this command is not yet stable and may be changed. Usage: cue mod mirror [module...] [flags] Flags: -a, --all-versions copy all available versions of the specified modules -n, --dry-run only run simulation --from string source registry (defaults to $CUE_REGISTRY) -m, --mod mirror the current main module\u0026#39;s dependency modules by default --no-deps do not copy module dependencies --to string destination registry (defaults to $CUE_REGISTRY) Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "fb77c6d78ce1bb8d62186e22cf20d703_1",
        "title": "cue help mod publish",
        "link": "/docs/reference/command/cue-help-mod-publish/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod publish Publish the current module to an OCI registry. It consults $CUE_REGISTRY to determine where the module should be published (see \u0026#34;cue help environment\u0026#34; for details). Also note that this command does no dependency or other checks at the moment. When the --dry-run flag is specified, nothing will actually be written to a registry, but all other checks will take place. The --json flag can be used to find out more information about the upload.",
        "content": "TERMINAL Copy code Copied! $ cue help mod publish Publish the current module to an OCI registry. It consults $CUE_REGISTRY to determine where the module should be published (see \u0026#34;cue help environment\u0026#34; for details). Also note that this command does no dependency or other checks at the moment. When the --dry-run flag is specified, nothing will actually be written to a registry, but all other checks will take place. The --json flag can be used to find out more information about the upload. The --out flag can be used to write the module\u0026#39;s contents to a directory in OCI Image Layout format. See this link for more details on the format: https://github.com/opencontainers/image-spec/blob/8f3820ccf8f65db8744e626df17fe8a64462aece/image-layout.md Note that this command is not yet stable and may be changed. Usage: cue mod publish \u0026lt;version\u0026gt; [flags] Flags: -n, --dry-run only run simulation --json print verbose information in JSON format (implies --dry-run) --out string write module contents to specified directory in OCI Image Layout format (implies --dry-run) Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Related content Reference: cue help environment",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "145ac82bfe11c3c49e2f583cc13160a6_1",
        "title": "cue help mod registry",
        "link": "/docs/reference/command/cue-help-mod-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod registry This command starts an OCI-compliant server that stores all its contents in memory. It can serve as a scratch CUE modules registry for use in testing. For example, start a local registry with: cue mod registry localhost:8080 and point CUE_REGISTRY to it to publish a module version: CUE_REGISTRY=localhost:8080 cue mod publish v0.0.1 Note: this command might be removed or changed significantly in the future.",
        "content": "TERMINAL Copy code Copied! $ cue help mod registry This command starts an OCI-compliant server that stores all its contents in memory. It can serve as a scratch CUE modules registry for use in testing. For example, start a local registry with: cue mod registry localhost:8080 and point CUE_REGISTRY to it to publish a module version: CUE_REGISTRY=localhost:8080 cue mod publish v0.0.1 Note: this command might be removed or changed significantly in the future. Usage: cue mod registry [listen-address] [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "807cde4a233300f22dee0902c1c35b1a_1",
        "title": "cue help mod rename",
        "link": "/docs/reference/command/cue-help-mod-rename/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help mod rename Rename changes the name of the current module, updating import statements in source files as required. Note that this command is not yet stable and may be changed. Usage: cue mod rename \u0026lt;newModulePath\u0026gt; [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help mod rename Rename changes the name of the current module, updating import statements in source files as required. Note that this command is not yet stable and may be changed. Usage: cue mod rename \u0026lt;newModulePath\u0026gt; [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "d1824ed00af5a5d2c927cba007551493_1",
        "title": "cue help mod resolve",
        "link": "/docs/reference/command/cue-help-mod-resolve/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod resolve This command prints information about how a given module path will resolve to an actual registry in the form of an OCI reference. If the module version (which must be a canonical semver version) is omitted, it omits the tag from the reference. It only consults local information - it works lexically with respect to the registry configuration (see \u0026#34;cue help registryconfig\u0026#34;) and does not make any network calls to check whether the module exists.",
        "content": "TERMINAL Copy code Copied! $ cue help mod resolve This command prints information about how a given module path will resolve to an actual registry in the form of an OCI reference. If the module version (which must be a canonical semver version) is omitted, it omits the tag from the reference. It only consults local information - it works lexically with respect to the registry configuration (see \u0026#34;cue help registryconfig\u0026#34;) and does not make any network calls to check whether the module exists. If no arguments are provided, the current module path is used. This is equivalent to specifying \u0026#34;.\u0026#34; as an argument, which also refers to the current module. Note that this command is not yet stable and may be changed. Usage: cue mod resolve [\u0026lt;modulepath\u0026gt;[@\u0026lt;version\u0026gt;] ...] [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Related content Reference: cue help registryconfig",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "d0dfc9f24c7e3975e39aa42efcdddcac_1",
        "title": "cue help mod tidy",
        "link": "/docs/reference/command/cue-help-mod-tidy/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help mod tidy Tidy resolves all module dependencies in the current module and updates the cue.mod/module.cue file to reflect them. It also removes dependencies that are not needed. It will attempt to fetch modules that aren\u0026#39;t yet present in the dependencies by fetching the latest available version from a registry. See \u0026#34;cue help environment\u0026#34; for details on how $CUE_REGISTRY is used to determine the modules registry.",
        "content": "TERMINAL Copy code Copied! $ cue help mod tidy Tidy resolves all module dependencies in the current module and updates the cue.mod/module.cue file to reflect them. It also removes dependencies that are not needed. It will attempt to fetch modules that aren\u0026#39;t yet present in the dependencies by fetching the latest available version from a registry. See \u0026#34;cue help environment\u0026#34; for details on how $CUE_REGISTRY is used to determine the modules registry. Note that this command is not yet stable and may be changed. Usage: cue mod tidy [flags] Flags: --check check for tidiness after fetching dependencies; fail if module.cue would be updated Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress Related content Reference: cue help environment",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "bfa9033b5cdb0bfae1bebdae9be10af5_1",
        "title": "cue help modules",
        "link": "/docs/reference/command/cue-help-modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help modules Modules are how CUE publishes packages and manages dependencies. A module is a collection of packages that are released, versioned, and distributed together. Modules are downloaded from OCI-compliant artifact registries. The Central Registry for CUE modules (registry.cue.works) is used as the source for external modules by default. For a detailed reference on modules: https://cuelang.org/docs/reference/modules/ For information on commands that interact with modules: cue help mod For tutorials on how to use the Central Registry, see: https://cuelang.",
        "content": "TERMINAL Copy code Copied! $ cue help modules Modules are how CUE publishes packages and manages dependencies. A module is a collection of packages that are released, versioned, and distributed together. Modules are downloaded from OCI-compliant artifact registries. The Central Registry for CUE modules (registry.cue.works) is used as the source for external modules by default. For a detailed reference on modules: https://cuelang.org/docs/reference/modules/ For information on commands that interact with modules: cue help mod For tutorials on how to use the Central Registry, see: https://cuelang.org/docs/tutorial/working-with-the-central-registry/ https://cuelang.org/docs/tutorial/publishing-modules-to-the-central-registry/ For a tutorial on how to work with a custom OCI registry for CUE modules: https://cuelang.org/docs/tutorial/working-with-a-custom-module-registry/ For information on how to specify the CUE registry: cue help registryconfig Related content Reference: cue help mod Reference: cue help registryconfig",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "3f9c03433c67b896d6ab2040b2c29a7c_1",
        "title": "cue help refactor",
        "link": "/docs/reference/command/cue-help-refactor/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help refactor This command groups together commands relating to altering code within the current CUE module. Usage: cue refactor \u0026lt;cmd\u0026gt; [arguments] [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help refactor This command groups together commands relating to altering code within the current CUE module. Usage: cue refactor \u0026lt;cmd\u0026gt; [arguments] [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "d2ebfc29e00b5060cc1403351bffeb31_1",
        "title": "cue help refactor imports",
        "link": "/docs/reference/command/cue-help-refactor-imports/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help refactor imports WARNING: THIS COMMAND IS EXPERIMENTAL. This command alters import directives in the current module. By default it rewrites any imports in the current module that have a path prefix matching oldImportPath to replace that prefix by newImportPath. It does not attempt to adjust the contents of the cue.",
        "content": "This command is still in an experimental stage \u0026ndash; it may be changed or removed at any time. TERMINAL Copy code Copied! $ cue help refactor imports WARNING: THIS COMMAND IS EXPERIMENTAL. This command alters import directives in the current module. By default it rewrites any imports in the current module that have a path prefix matching oldImportPath to replace that prefix by newImportPath. It does not attempt to adjust the contents of the cue.mod/module.cue file: use \u0026#34;cue mod get\u0026#34; or \u0026#34;cue mod tidy\u0026#34; for that. If oldImportPath is underneath one of the dependency modules, only imports in that module will be altered, unless --all-major is specified, in which case all modules with that as a prefix will be refactored. Note: if oldImportPath specifies a major version, then it *must* be underneath a dependency module. If the --exact flag is specified, then oldImportPath is only considered to match when the entire path matches, rather than matching any path prefix. The --exact flag is implied if either oldImportPath or newImportPath contain an explicit package qualifier or when the --ident flag is specified. With only one argument, the command will first resolve the current default major version for the argument (ignoring any major version) and then take oldImportPath to be path of the argument with that major version. This means that the single argument form can be used to upgrade the major version of a module, assuming the packages in that module remain stable. If oldImportPath is omitted and --exact *is* specified, oldImportPath is taken to be the same as newImportPath. This is useful in conjunction with --ident. By default the identifier that the package is imported as will be kept the same (this is to minimize code churn). However, if --update-ident is specified, the identifier that the package is imported as will be updated according to the new import path\u0026#39;s default identifier. If --ident is specified, the identifier that the package is imported as will be updated to that identifier; this also implies --exact. The resulting CUE code is sanitized: that is, other than importing a different package, identifiers within the file will always refer to the same import directive. For example: # Change from k8s \u0026#34;cue get go\u0026#34; imports to new curated namespace cue refactor imports k8s.io cuelabs.dev/x/k8s # Update to use a new major version of the foo.com/bar module. cue refactor imports foo.com/bar@v0 foo.com/bar@v1 # A shorter form of the above, assuming v0 is the default major # version for foo.com/bar. cue refactor imports foo.com/bar@v1 # Use a different package from the pubsub package directory cue refactor imports github.com/cue-unity/services/pubsub github.com/cue-unity/services/pubsub:otherpkg # Use a different identifier for the import of the pubsub package. cue refactor imports --ident otherPubSub github.com/cue-unity/services/pubsub # Update only foo.com/bar, not (say) foo.com/baz/somethingelse cue refactor imports --exact foo.com/bar foo.com/baz Usage: cue refactor imports [\u0026lt;oldImportPath] \u0026lt;newImportPath\u0026gt; [flags] Flags: --all-major match all versions when major version omitted --exact exact match for package path instead of prefix match --ident string specify imported identifier (implies --exact) --update-ident update imported identifier name too Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "f11b463c3f19cfa517af48f1d4a2af51_1",
        "title": "cue help registryconfig",
        "link": "/docs/reference/command/cue-help-registryconfig/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help registryconfig The registry configuration determines how CUE maps modules to their locations in OCI registries. Given a particular registry configuration, it\u0026#39;s possible to work what registry a given module is stored in, and what repository within that registry, without making any network calls. If no explicit registry configuration is present, a default Central Registry (registry.cue.works) is used for all modules. The simplest way of specifying a registry configuration is to set $CUE_REGISTRY to the hostname of that registry.",
        "content": "TERMINAL Copy code Copied! $ cue help registryconfig The registry configuration determines how CUE maps modules to their locations in OCI registries. Given a particular registry configuration, it\u0026#39;s possible to work what registry a given module is stored in, and what repository within that registry, without making any network calls. If no explicit registry configuration is present, a default Central Registry (registry.cue.works) is used for all modules. The simplest way of specifying a registry configuration is to set $CUE_REGISTRY to the hostname of that registry. Examples: CUE_REGISTRY=myregistry.example CUE_REGISTRY=localhost:5000 CUE_REGISTRY=\u0026#39;[::1]:5000\u0026#39; The special name \u0026#34;none\u0026#34; can be used to indicate that no registry should be used. If a path is present too, all modules will be stored under that path. For example: CUE_REGISTRY=localhost:5000/all/modules/will/be/stored/here By default for hosts other than localhost, a secure (HTTPS) connection will be used. This default can be set by appending \u0026#34;+insecure\u0026#34; or \u0026#34;+secure\u0026#34;. For example: CUE_REGISTRY=100.98.141.117:5000+insecure CUE_REGISTRY=localhost:5000/modules+secure When specified in this way, the registry is used to fetch all modules. To use a specific registry for only certain subsets of modules, a prefix can be specified. This constrains a registry to be used only for modules that match that prefix. If there are multiple registries with a prefix, the longest matching prefix wins. When matching a prefix, only complete path elements (non-slash characters) are considered. It\u0026#39;s an error if there are two identical prefixes in the same registry configuration. For example: CUE_REGISTRY=\u0026#39;foo.example/bar=localhost:5000,myregistry.example\u0026#39; In the above example, modules with the prefix \u0026#34;foo.example/bar\u0026#34;, such as \u0026#34;foo.example/bar/somemodule\u0026#34; (but not \u0026#34;foo.example/barry\u0026#34;), will be fetched from the registry at localhost:5000. All other modules will be fetched from \u0026#34;myregistry.example\u0026#34;. Note that the syntax above implies that the ordering of the elements in CUE_REGISTRY isn\u0026#39;t important because the resolution algorithm is order-independent. To specify that no registry should be used for a given module prefix, the special name \u0026#34;none\u0026#34; can be used. For example: CUE_REGISTRY=\u0026#39;foo.example/bar=none,myregistry.example\u0026#39; In the above example, any attempt to fetch a module under \u0026#34;foo.example/bar\u0026#34; will result in a failure. Note that this will not take effect if the module is already present in the on-disk cache, which is consulted before looking at CUE_REGISTRY. Customizing Name Resolution Some registries have restrictions on what repositories can be used. For example, a registry implementation might restrict the depth of the available repository paths, or might even provide access to a single repository only. In order to accommodate these kinds of limitation, a registry configuration can also be specified in CUE syntax, usually as a configuration file. To do this, set CUE_REGISTRY to \u0026#34;file:\u0026#34; followed by the path to the configuration file. For example: CUE_REGISTRY=file:/home/alice/.config/cue/registry.cue To remove ambiguity, the simpler syntax described earlier can be explicitly requested with the \u0026#34;simple:\u0026#34; prefix. For example: CUE_REGISTRY=simple:myregistry.example If it is preferable not to create a file on disk for the configuration, the \u0026#34;inline:\u0026#34; prefix can be used: CUE_REGISTRY=\u0026#39;inline:defaultRegistry: registry: \u0026#34;myregistry.example\u0026#34;\u0026#39; The configuration file syntax is described by the following CUE #file schema definition: // #file represents the registry configuration schema. #file: { // moduleRegistries specifies a mapping from module path prefix // (excluding any version suffix) to the registry to be used for // all modules under that path. // // A prefix is considered to match if a non-zero number of // initial path elements (sequences of non-slash characters) in // a module path match the prefix. // // If there are multiple matching prefixes, the longest // is chosen. moduleRegistries?: [#modulePath]: #registry // defaultRegistry specifies a fallback registry to be used if no // prefix from moduleRegistry matches. // If it\u0026#39;s not present, a system default will be used. defaultRegistry?: #registry } #registry: { // registry specifies the registry host name and optionally, the // repository prefix to use for all modules in the repository, // and the security to use when accessing the host. // // It is in the form: // hostname[:port][/repoPrefix][+insecure] // // The hostname must be specified in square brackets if it\u0026#39;s an // IPv6 address. // // Connections will be secure unless explicitly specified // otherwise, except for localhost connections which default to // insecure. // // See the doc comment on pathEncoding for details as to how // repoPrefix is used to determine the repository to use for a // specific module. // // As a special case, the registry may be \u0026#34;none\u0026#34;, indicating // that there is no registry for its associated modules. // If a module resolves to a \u0026#34;none\u0026#34; registry, the resolver // will return an error. // // Examples: // \u0026#34;localhost:1234\u0026#34; // \u0026#34;myregistry.example/my-modules+secure\u0026#34; // \u0026#34;none\u0026#34; registry!: string // pathEncoding specifies how module versions map to // repositories within a registry. // Possible values are: // - \u0026#34;path\u0026#34;: the repository is used as a prefix to the unencoded // module path. The version of the module is used as a tag. // - \u0026#34;hashAsPath\u0026#34;: the hex-encoded SHA256 hash of the path is // used as a suffix to the above repository value. The version // of the module is used as a tag. // - \u0026#34;hashAsTag\u0026#34;: the repository is used as is: the hex-encoded // SHA256 hash of the path followed by a hyphen and the version // is used as a tag. pathEncoding?: \u0026#34;path\u0026#34; | \u0026#34;hashAsRepo\u0026#34; | \u0026#34;hashAsTag\u0026#34; // prefixForTags specifies an arbitrary prefix that\u0026#39;s added to // all tags. This can be used to disambiguate tags when there // might be some possibility of confusion with tags in use for // other purposes. prefixForTags?: #tag // TODO we could encode the invariant below in CUE but that // would result in poor error messages. With an error builtin, // that could perhaps be improved. // stripPrefix specifies that the pattern prefix should be // stripped from the module path before using as a repository // path. This only applies when pathEncoding is \u0026#34;path\u0026#34;. stripPrefix?: bool } // TODO more specific schemas below #modulePath: string #tag: string",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command","modules"],
        "authors": ""
    },
    
            {
        "objectID": "e5ec39853e1a2d242ee53c8d5dd6648a_1",
        "title": "cue help trim",
        "link": "/docs/reference/command/cue-help-trim/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help trim trim removes fields from structs that can be inferred from constraints A field, struct, or list is removed if it is implied by a constraint, such as from an optional field matching a required field, a list type value, a comprehension or any other implied content. It will modify the files in place. Limitations Removal is on a best effort basis. Some caveats: - Fields in implied content may refer to fields within the struct in which they are included, but are only resolved on a best-effort basis.",
        "content": "TERMINAL Copy code Copied! $ cue help trim trim removes fields from structs that can be inferred from constraints A field, struct, or list is removed if it is implied by a constraint, such as from an optional field matching a required field, a list type value, a comprehension or any other implied content. It will modify the files in place. Limitations Removal is on a best effort basis. Some caveats: - Fields in implied content may refer to fields within the struct in which they are included, but are only resolved on a best-effort basis. - Disjunctions that contain structs in implied content cannot be used to remove fields. - There is currently no verification step: manual verification is required. Examples: $ cat \u0026lt;\u0026lt;EOF \u0026gt; foo.cue light: [string]: { room: string brightnessOff: *0.0 | \u0026gt;=0 \u0026amp; \u0026lt;=100.0 brightnessOn: *100.0 | \u0026gt;=0 \u0026amp; \u0026lt;=100.0 } light: ceiling50: { room: \u0026#34;MasterBedroom\u0026#34; brightnessOff: 0.0 // this line brightnessOn: 100.0 // and this line will be removed } EOF $ cue trim foo.cue $ cat foo.cue light: [string]: { room: string brightnessOff: *0.0 | \u0026gt;=0 \u0026amp; \u0026lt;=100.0 brightnessOn: *100.0 | \u0026gt;=0 \u0026amp; \u0026lt;=100.0 } light: ceiling50: { room: \u0026#34;MasterBedroom\u0026#34; } It is guaranteed that the resulting files give the same output as before the removal. Usage: cue trim [flags] Flags: -n, --dry-run only run simulation -f, --force force overwriting existing files -o, --outfile string filename or - for stdout with optional file prefix (run \u0026#39;cue help filetypes\u0026#39; for more info) Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "8aae5e67230c6a85394b451f388b84ec_1",
        "title": "cue help version",
        "link": "/docs/reference/command/cue-help-version/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": " TERMINAL Copy code Copied! $ cue help version print CUE version Usage: cue version [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress ",
        "content": "TERMINAL Copy code Copied! $ cue help version print CUE version Usage: cue version [flags] Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "261056c94cee0c85f3ce8d046d2b4d38_1",
        "title": "cue help vet",
        "link": "/docs/reference/command/cue-help-vet/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "TERMINAL Copy code Copied! $ cue help vet The vet command validates CUE and other data files. The command is silent when it succeeds, emitting no output and an exit code of zero. Otherwise, errors are reported and the command returns a non-zero exit code. vet starts by ensuring that there are no validation errors. If errors are found then they are reported and the command exits. If there are no validation errors then, by default, vet checks that the result of the evaluation is concrete.",
        "content": "TERMINAL Copy code Copied! $ cue help vet The vet command validates CUE and other data files. The command is silent when it succeeds, emitting no output and an exit code of zero. Otherwise, errors are reported and the command returns a non-zero exit code. vet starts by ensuring that there are no validation errors. If errors are found then they are reported and the command exits. If there are no validation errors then, by default, vet checks that the result of the evaluation is concrete. It reports an error if the evaluation contains any regular fields that have non-concrete values. Skip this step by specifying -c=false, which permits regular fields to have non-concrete values. Specify -c/-c=true to report errors mentioning which regular fields have non-concrete values. Checking non-CUE files Vet can also check non-CUE files. The following file formats are currently supported: Format Extensions JSON .json .jsonl .ndjson YAML .yaml .yml TOML .toml TEXT .txt (validate a single string value) To activate this mode, the non-CUE files must be explicitly mentioned on the command line. There must also be at least one CUE file to hold the constraints. In this mode, each file will be verified against a CUE constraint. If the files contain multiple objects (such as using --- in YAML) then each object will be verified individually. By default, each file is checked against the root of the loaded CUE files. The -d can be used to only verify files against the result of an expression evaluated within the CUE files. This can be useful if the CUE files contain a set of definitions to pick from. Examples: # Check files against a CUE file: cue vet -c foo.cue foo.yaml # Check files against a particular expression cue vet -c foo.cue lang/en.yaml lang/de.yaml -d \u0026#39;#Translation\u0026#39; More than one expression may be given using multiple -d flags. Each non-CUE file must match all expression values. Usage: cue vet [flags] Flags: -c, --concrete require the evaluation to be concrete, or set -c=false to allow incomplete values -t, --inject stringArray set the value of a tagged field -T, --inject-vars inject system variables in tags --list concatenate multiple objects into a list --merge merge non-CUE files (default true) -n, --name string glob filter for non-CUE file names in directories -p, --package string package name for non-CUE files -l, --path stringArray CUE expression for single path component (see \u0026#39;cue help flags\u0026#39; for details) --proto_enum string mode for rendering enums (int|json) (default \u0026#34;int\u0026#34;) -I, --proto_path stringArray paths in which to search for imports -d, --schema string expression to select schema for evaluating values in non-CUE files --with-context import as object with contextual data Global Flags: -E, --all-errors print all available errors -i, --ignore proceed in the presence of errors -s, --simplify simplify output --trace trace computation -v, --verbose print information about progress",
        "breadcrumb": ["Documentation","References","The cue command"],
        "contentType": "References",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "35f1c4ef05a74967640cabe60dd35f60_1",
        "title": "Next: Explore CUE!",
        "link": "/docs/tour/packages/next/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "You\u0026rsquo;ve reached the end of this tour through CUE. Next, you could:\nInstall the cue CLI and try out CUE on your computer Experiment with CUE in your browser, in the CUE Playground Return to the main CUE documentation page ",
        "content": "You\u0026rsquo;ve reached the end of this tour through CUE. Next, you could: Install the cue CLI and try out CUE on your computer Experiment with CUE in your browser, in the CUE Playground Return to the main CUE documentation page",
        "breadcrumb": ["Documentation","Tour","Packages and Imports"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "eea24f55f663b2c7ccd14c94298748bc_1",
        "title": "Next: Expressions",
        "link": "/docs/tour/references/next/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Tour","References and Visibility"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "829253d6fe6b79ac06231ccfda4df70e_1",
        "title": "Next: Packages and Imports",
        "link": "/docs/tour/expressions/next/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Tour","Expressions"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "56ca7e9d316192e09f99db4fe673416c_1",
        "title": "Next: References and Visibility",
        "link": "/docs/tour/types/next/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Tour","Types and Values"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "4305215508a83e27702ec9a9725662e6_1",
        "title": "Next: Types and Values",
        "link": "/docs/tour/basics/next/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": ["Documentation","Tour","The Basics of CUE"],
        "contentType": "Tour",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "cca01acbd45dbccf7d681f1b74e120dd_1",
        "title": "Encoding JSON or YAML with CUE",
        "link": "/docs/howto/encode-json-yaml-with-cue/",
        "publishDate": "2023-08-22T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIt may be necessary to include \u003cstrong\u003enested data\u003c/strong\u003e as an encoded string, such as a bit\nof YAML embedded as a string inside a JSON request. The steps below show how to\naccomplish that with the \u003ccode\u003ecue\u003c/code\u003e command line. First with JSON, then with YAML.\u003c/p\u003e",
        "content": "Introduction It may be necessary to include nested data as an encoded string, such as a bit of YAML embedded as a string inside a JSON request. The steps below show how to accomplish that with the cue command line. First with JSON, then with YAML. Prerequisites You have CUE installed locally. This allows you to run cue commands Encoding Nested JSON Create a CUE file which uses the json package to encode an inner value: Copied! nested-json.cue Copy code Copied! import \u0026#34;encoding/json\u0026#34; _innerData: { innerString: \u0026#34;inside\u0026#34; } nestedJSON: json.Marshal(_innerData) outerString: \u0026#34;outside\u0026#34; Use cue export to evaluate and encode the entire value: TERMINAL Copy code Copied! $ cue export nested-json.cue { \u0026#34;nestedJSON\u0026#34;: \u0026#34;{\\\u0026#34;innerString\\\u0026#34;:\\\u0026#34;inside\\\u0026#34;}\u0026#34;, \u0026#34;outerString\u0026#34;: \u0026#34;outside\u0026#34; } Encoding YAML to JSON Use a different encoding package for encoding the nested value, such as yaml: Copied! nested-yaml.cue Copy code Copied! import \u0026#34;encoding/yaml\u0026#34; _innerData: { innerString: \u0026#34;inside\u0026#34; } nestedYAML: yaml.Marshal(_innerData) outerString: \u0026#34;outside\u0026#34; TERMINAL Copy code Copied! $ cue export nested-yaml.cue { \u0026#34;nestedYAML\u0026#34;: \u0026#34;innerString: inside\\n\u0026#34;, \u0026#34;outerString\u0026#34;: \u0026#34;outside\u0026#34; } Choosing different encodings with cue export --out Use a different encoding for the entire value via the --out flag, such as yaml: TERMINAL Copy code Copied! $ cue export nested-json.cue --out yaml nestedJSON: \u0026#39;{\u0026#34;innerString\u0026#34;:\u0026#34;inside\u0026#34;}\u0026#39; outerString: outside \u0026hellip; or cue: TERMINAL Copy code Copied! $ cue export nested-yaml.cue --out cue nestedYAML: \u0026#34;\u0026#34;\u0026#34; innerString: inside \u0026#34;\u0026#34;\u0026#34; outerString: \u0026#34;outside\u0026#34; For all encodings see the encoding package listing.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["encodings"],
        "authors": ["myitcv","mpvl"]
    },
    
            {
        "objectID": "7aeab8e98fe01670e6c33c2dbac5e244_1",
        "title": "Alias and reference scopes",
        "link": "/docs/concept/alias-and-reference-scopes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"problem-1\"\u003e\n    \u003ca href=\"#problem-1\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eProblem #1\u003c/h2\u003e\n\u003cp\u003eA user asked for help with a problem they were having with their CUE:\u003c/p\u003e\n\u003cblockquote class=\"quote\"\u003e\n    \u003cp\u003e\nCan you help me with \u003ccode\u003eproblem1.cue\u003c/code\u003e? I'm trying to get YAML that\nlooks like \u003ccode\u003eexpected.yaml\u003c/code\u003e, but instead I end up with these\n\"incomplete value\" errors!\n\u003c/p\u003e\n\n    \n\u003c/blockquote\u003e",
        "content": "Problem #1 A user asked for help with a problem they were having with their CUE: Can you help me with problem1.cue? I'm trying to get YAML that looks like expected.yaml, but instead I end up with these \"incomplete value\" errors! Copied! problem1.cue Copy code Copied! #Metadata: { name: string namespace: string } #BaseConfig: { metadata: #Metadata } #Config: { metadata: #Metadata serviceA: #BaseConfig \u0026amp; { metadata: metadata } serviceB: #BaseConfig \u0026amp; { metadata: metadata } } config: #Config \u0026amp; { metadata: { name: \u0026#34;test\u0026#34; namespace: \u0026#34;dev\u0026#34; } } Copied! expected.yaml Copy code Copied! config: metadata: name: test namespace: dev serviceA: metadata: name: test namespace: dev serviceB: metadata: name: test namespace: dev TERMINAL Copy code Copied! $ cue export problem1.cue --out yaml config.serviceA.metadata.name: incomplete value string: ./problem1.cue:2:13 config.serviceA.metadata.namespace: incomplete value string: ./problem1.cue:3:13 Explanation #1 Well, CUE user, your solution sure does look reasonable at first glance! You\u0026rsquo;re trying to make sure that wherever #Config is used, the fields serviceA.metadata and serviceB.metadata are identical to the value of the metadata field at the top level of whatever #Config is unified with, and to ensure that these fields adhere to the constraints of #Metadata. The reason that your example doesn\u0026rsquo;t work as expected is because of the metadata: metadata inside serviceA and serviceB: Copy code Copied! #Config: { metadata: #Metadata serviceA: #BaseConfig \u0026amp; { // this is the problem metadata: metadata } serviceB: #BaseConfig \u0026amp; { // and so is this metadata: metadata } } Essentially, metadata: metadata is a reference to itself, and not to the metadata field in the \u0026ldquo;outer\u0026rdquo; scope. This is effectively the same as writing metadata: _ which is almost always not what\u0026rsquo;s intended. Top (\u0026quot;_\u0026quot;) says nothing about a field: it doesn\u0026rsquo;t add any constraints and it doesn\u0026rsquo;t provide a value - therefore this field is incomplete. We have thought about adding a linter that warns about this kind of self reference but, because it\u0026rsquo;s not invalid CUE, it can\u0026rsquo;t be flagged as an evaluation error! Problem #2 The user experimented some more, and asked again: I tried referring to #Config.metadata, but problem2.cue still makes cue complain about incomplete values! Can you tell me why? Copied! problem2.cue Copy code Copied! #Metadata: { name: string namespace: string } #BaseConfig: { metadata: #Metadata } #Config: { metadata: #Metadata serviceA: #BaseConfig \u0026amp; { metadata: #Config.metadata } serviceB: #BaseConfig \u0026amp; { metadata: #Config.metadata } } config: #Config \u0026amp; { metadata: { name: \u0026#34;test\u0026#34; namespace: \u0026#34;dev\u0026#34; } } Copied! expected.yaml Copy code Copied! config: metadata: name: test namespace: dev serviceA: metadata: name: test namespace: dev serviceB: metadata: name: test namespace: dev TERMINAL Copy code Copied! $ cue export problem2.cue --out yaml config.serviceA.metadata.name: incomplete value string: ./problem2.cue:2:13 config.serviceA.metadata.namespace: incomplete value string: ./problem2.cue:3:13 Explanation #2 So, as before, this looks like a very reasonable attempt to solve the problem! However, in problem2.cue, the reference to #Config.metadata is a reference that\u0026rsquo;s baked into the #Config struct at the time it\u0026rsquo;s declared. It will resolve to #Metadata and its contents, but only as they existed at the time that #Config was declared. Your actual use of #Config in the declaration of config, along with a metadata struct that contains concrete values, happens separately. So config.serviceA and config.serviceB each end up with a metadata field that refers to the non-concrete values inside #Metadata. It\u0026rsquo;s these non-concrete values that can\u0026rsquo;t be exported, and which cause cue to complain that they\u0026rsquo;re incomplete. Solution Given both the problems encountered above, how can we successfully refer to the concrete metadata values provided when config is declared? The solution is: use an alias! Copied! solution.cue Copy code Copied! #Metadata: { name: string namespace: string } #BaseConfig: { metadata: #Metadata } #Config: { M=metadata: #Metadata serviceA: #BaseConfig \u0026amp; { metadata: M } serviceB: #BaseConfig \u0026amp; { metadata: M } } config: #Config \u0026amp; { metadata: { name: \u0026#34;test\u0026#34; namespace: \u0026#34;dev\u0026#34; } } Copied! expected.yaml Copy code Copied! config: metadata: name: test namespace: dev serviceA: metadata: name: test namespace: dev serviceB: metadata: name: test namespace: dev TERMINAL Copy code Copied! $ cue export solution.cue --out yaml config: metadata: name: test namespace: dev serviceA: metadata: name: test namespace: dev serviceB: metadata: name: test namespace: dev Declaring an alias means that we\u0026rsquo;re making a different name available for the expression that it refers to. In this case the expression is a reference to the \u0026ldquo;outer\u0026rdquo; metadata field, now pointed to by the alias \u0026ldquo;M\u0026rdquo;. The alias is defined on the right hand side of #Config. Its inside #Config, with the alias being part of the value on the right hand side. It can be thought of as a relative reference, within #Configs value. Critically, because the alias is relative within the right hand side value, this means that the reference is relative wherever #Config is used. So when you create the regular config field, it unifies #Config with this struct: Copy code Copied! { metadata: { name: \u0026#34;test\u0026#34; namespace: \u0026#34;dev\u0026#34; } } The alias M then refers to the constraints of #Config.metadata and #Metadata, and the concrete values of config.metadata, all unified together - giving us output that successfully matches expected.yaml!",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["user question"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "54adb2b4b1867c4231ab019b7ceb469a_1",
        "title": "Building cue-api-java as a JAR file",
        "link": "/docs/howto/build-cue-api-java-jar/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library\n\u003ca href=\"https://github.com/cue-lang/cue-api-java\"\u003e\u003ccode\u003ecue-api-java\u003c/code\u003e\u003c/a\u003e\nprovides a Java API to CUE.\nThis guide demonstrates how to compile the library\nand store the result in a JAR file on your computer.\nThis is a required step before the library can be used by Java programs to\naccess the capabilities of the CUE language.\u003c/p\u003e",
        "content": "The library cue-api-java provides a Java API to CUE. This guide demonstrates how to compile the library and store the result in a JAR file on your computer. This is a required step before the library can be used by Java programs to access the capabilities of the CUE language. cue-api-java is an experimental technology preview which is under development and is subject to change. Prerequisites Java JDK version 22 or later \u0026ndash; choosing a JDK distribution Apache Maven version 3.8.7 or later \u0026ndash; installation details libcue, a low-level library that enables cross-language access to CUE \u0026ndash; installation details Git \u0026ndash; installation details Set up the build environment 1Check that the executable prerequisites are met: TERMINAL Copy code Copied! $ javac --version javac 22.0.2 $ mvn --version ... $ git --version git version 2.39.5 Many package managers choose to install a \u0026ldquo;Long Term Support\u0026rdquo; Java version, such as Java 21. The Java CUE API uses the Foreign Function \u0026amp; Memory API which only became available in Java 22. You must be using JDK 22 or later: make sure to check your Java version before continuing. 2Teach Java and the operating system how to locate your libcue installation: TERMINAL Copy code Copied! $ export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH This guide builds on the process documented in Building libcue as a shared library. That guide installs libcue into the /usr/local/lib/ directory, and so the build process needs to be instructed to search this directory for shared libraries. Here, we choose to use the LD_LIBRARY_PATH environment variable to achieve this because of how the Maven build process works. We don\u0026rsquo;t use other mechanisms here, such as invoking Java with the parameter -Djava.library.path=..., because they may not work as expected with Maven. Whatever mechanism you choose, if you have installed libcue into a different directory then be sure to teach the loader about the appropriate directory for your system. 3Clone the cue-api-java repository and change into its directory: TERMINAL Copy code Copied! $ git clone https://github.com/cue-lang/cue-api-java cue-api-java-source ... $ cd cue-api-java-source 4Select a specific commit to build: TERMINAL Copy code Copied! $ git checkout 3c12bb9e9ea203d4de8308b4145e876e4b60207e Note: switching to \u0026#39;3c12bb9e9ea203d4de8308b4145e876e4b60207e\u0026#39;. ... cue-api-java is not currently versioned, so this step uses a specific commit reference. Build the library 5Use Maven to build cue-api-java: TERMINAL Copy code Copied! $ mvn package ... The build log output from Maven will include the library\u0026rsquo;s dependencies being downloaded, its tests being run, a summary of the test results, and the final build being performed. If the output does not contain a line matching \u0026ldquo;BUILD SUCCESS\u0026rdquo;, you will need to debug and fix the issues with your build. Test the build It\u0026rsquo;s a good idea to test the JAR file created by Maven. 6Create a program to test that Java can load the CUE API successfully: Copied! cue-api-java-source/TestLoad.java Copy code Copied! import org.cuelang.cue.*; public class TestLoad { public static void main(String[] args) throws Exception { var ctx = new CueContext(); System.out.println(\u0026#34;CUE loaded successfully!\u0026#34;); } } 7Compile the test program, after making sure the CUE JAR can be found under a predictable filename: TERMINAL Copy code Copied! $ mv target/CUE*.jar CUE.jar $ javac -cp CUE.jar TestLoad.java 8Execute the test program: TERMINAL Copy code Copied! $ java --enable-native-access=ALL-UNNAMED -cp CUE.jar:. TestLoad CUE loaded successfully! The --enable-native-access flag avoids a runtime warning from Java that the Foreign Function \u0026amp; Memory API is used by cue-api-java to access libcue. Store the library 9To use the JAR file you built in the previous step multiple tools will need to know the locations of the JAR and the libcue shared library on your computer. The Java compiler, the runtime loader, and the language runtime will need to know these locations every time you compile or run a Java program that uses CUE. As discussed above, the location of the libcue shared library can be identified using the LD_LIBRARY_PATH environment variable, or other mechanisms such as Java\u0026rsquo;s -Djava.library.path=... parameter. You can place the JAR anywhere on your system, and tell Java about that location using one of the various mechanisms that it supports. Java guides on cuelang.org assume that the JAR is available in the directory /usr/local/share/java/, which you can set up as follows: TERMINAL Copy code Copied! $ mkdir -p /usr/local/share/java/ $ cp CUE.jar /usr/local/share/java/ On a Linux system your user probably won\u0026rsquo;t have write access to the /usr/local/share/java/ directory. If so, you will need to run these commands as a more privileged user \u0026ndash; possibly the root user, accessed via sudo or su. Related content How-to Guide: Building libcue as a shared library",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["java api"],
        "authors": ["jpluscplusm","4ad"]
    },
    
            {
        "objectID": "c76b1278d62d108e35f2f92acce4acb8_1",
        "title": "Building libcue as a shared library",
        "link": "/docs/howto/build-libcue-shared-library/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library \u003ca href=\"https://github.com/cue-lang/libcue\"\u003e\u003ccode\u003elibcue\u003c/code\u003e\u003c/a\u003e provides a mechanism\nto use CUE in C and C-like languages. This guide demonstrates how it can be\ncompiled as a shared library, which is a required step before using it with\nlanguages such as Java.\u003c/p\u003e\n\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003elibcue\u003c/code\u003e is an experimental technology preview.\nThe library is under development and is subject to change.\u003c/div\u003e\n\u003c/div\u003e",
        "content": "The library libcue provides a mechanism to use CUE in C and C-like languages. This guide demonstrates how it can be compiled as a shared library, which is a required step before using it with languages such as Java. libcue is an experimental technology preview. The library is under development and is subject to change. Prerequisites Go version 1.22 or later with cgo enabled \u0026ndash; installation details GCC or Clang \u0026ndash; any version shipped with a relatively modern Linux or macOS will be sufficient Git \u0026ndash; installation details Set up the build environment 1Enable cgo: TERMINAL Copy code Copied! $ export CGO_ENABLED=1 2Check that the Go prerequisites are met: TERMINAL Copy code Copied! $ go version go version go1.24.0 linux/amd64 $ go env CGO_ENABLED 1 Check that other prerequisites are met: TERMINAL Copy code Copied! $ cc --version cc (Debian 12.2.0-14) 12.2.0 ... $ git --version git version 2.39.5 3Clone the libcue repository and change into its directory: TERMINAL Copy code Copied! $ git clone https://github.com/cue-lang/libcue libcue-source ... $ cd libcue-source 4Select a specific commit to build: TERMINAL Copy code Copied! $ git checkout 1c861cc9cdc5584f5d26b0a7112aa2afee74d4cf Note: switching to \u0026#39;1c861cc9cdc5584f5d26b0a7112aa2afee74d4cf\u0026#39;. ... libcue is not currently versioned, so this step uses a specific commit reference. Build the library 5Build libcue as a shared library: TERMINAL Copy code Copied! $ go build -buildmode=c-shared -o libcue.so ... The value passed to the -o flag is the filename that will contain the compiled output. This value will vary, depending on your operating system. The value shown above (libcue.so) is appropriate for most Unix systems, such as Linux. On macOS you should use libcue.dylib, and Windows requires cue.dll (without a \u0026ldquo;lib\u0026rdquo; prefix). Store the shared library 6To use the shared library built in the previous step the compiler, the runtime loader, and potentially the language runtime will need to know the location of the library on your computer, at the appropriate time. The compiler will need to know this at the point that you compile code, with the language runtime or runtime loader needing the location every time you execute a program that uses libcue. Some compilers and runtimes expect you to specify locations explicitly; some check predefined lists of locations; and some can be controlled through environment variables and settings. The location where you store the shared library will depend on your operating system, the permissions you have on your computer, and the specific compiler and build system that you intend to use libcue with. On a Unix system such as Linux the value of the environment variable LD_LIBRARY_PATH and the contents of the file /etc/ld.so.conf are commonly used to control the behaviour of the runtime loader, as explained in The Linux Documentation Project\u0026rsquo;s Program Library guide. Documentation for Windows also exists. Here is an example of how to make libcue available to compilers and runtimes, system-wide, under Linux: TERMINAL Copy code Copied! $ cp libcue.so /usr/local/lib/ On a Linux system your user probably won\u0026rsquo;t have write access to the /usr/local/lib directory. If so, you will need to run the cp command as a more privileged user \u0026ndash; possibly the root user, accessed via sudo or su. How-to guides and tutorials on cuelang.org that use libcue assume that it has been compiled as a shared library as described above, and has been made available system-wide with an appropriate filename. Related content",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm","4ad"]
    },
    
            {
        "objectID": "c964786208b623f5b4604030d0ab8796_1",
        "title": "Code Generation and Extraction use case",
        "link": "/docs/concept/code-generation-and-extraction-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCode generation and extraction is a broad topic and, for instance, overlaps\nwith the topics discussed in\n\u003ca href=\"/docs/concept/schema-definition-use-case/\"\u003eSchema Definition\u003c/a\u003e and\n\u003ca href=\"/docs/integration/go/\"\u003eGo\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn this section we emphasize the role of CUE in a code-generation pipeline,\nthat is using CUE as an interlingua for the extraction from and the\ngeneration to multiple sources.\u003c/p\u003e",
        "content": "Code generation and extraction is a broad topic and, for instance, overlaps with the topics discussed in Schema Definition and Go. In this section we emphasize the role of CUE in a code-generation pipeline, that is using CUE as an interlingua for the extraction from and the generation to multiple sources. Core issues addressed by CUE Extract data definition from existing sources When one identifies the need to define interchangeable data schema one usually already has some code base to deal with. CUE can currently extract definitions from: Go code Protobuf definitions. Moreover, CUE can combine and reduce the constraints from various sources and report if there are any inconsistencies. Enhance existing standards CUE also allows annotating existing sources with CUE expressions. This allows one to keep using existing sources or allow for a smoother transition into taking a CUE-centric approach. For instance, a project might be quite reliant on protobuf definitions as the source of truth of at least one aspect of schema definition. For this particular case, CUE allows annotating Protobuf field declarations with CUE expressions using field options. Copy code Copied! message Server { int32 port = 1 [(cue.val) = \u0026#34;\u0026gt;5000 \u0026amp; \u0026lt;10_000\u0026#34;]; } A similar approach is supported for Go: Copy code Copied! type Sum struct { A int `cue:\u0026#34;c-b\u0026#34; json:\u0026#34;a,omitempty\u0026#34;` B int `cue:\u0026#34;c-a\u0026#34; json:\u0026#34;b,omitempty\u0026#34;` C int `cue:\u0026#34;a+b\u0026#34; json:\u0026#34;c,omitempty\u0026#34;` } In both cases, the constraints will be included the extraction to CUE. In the case of Go, the constraints specified in the field tags can also be used to validate Go structs directly. Convert CUE to other standards Currently, CUE supports converting CUE to OpenAPI and Go, although it is certainly not limited to these cases. Comparisons CEL The Common Expression Language, or CEL, defines a simple expression language that can be used as a standardization of constraints. It focuses on simplicity, speed, termination guarantees and being able run embedded in applications. Unification of basic typed-feature structures has pseudo-linear run time complexity. The addition of comprehensions make the operation polynomial. Not disallowing recursion would make CUE Turing complete. The addition of sum types in CUE make certain operations NP-complete. The NP-completeness manifests itself only when reasoning over incomplete types. Trying to optimize a CEL expression would generally suffer from the same issue. The same problem does not exist when applying CUE to concrete values. That said, CUE is currently not optimized for embedded running. Currently, generated Go stubs embed a CUE interpreter into the code. These stubs are compatible with a mode where CUE generates native code, which would give it similar characteristics. CEL allows embedded implementation to add arbitrary functions. CUE does not. CUE keeps tight control over the pureness or hermeticity of evaluation and to ensure the properties of the value lattice are not broken. It would be possible, however, to provide the ability to add custom functions for restricted to concrete values. Protoc-gen-validate (PGV) PGV also allows annotating Protobuf fields with validation code, with implementations for Go and Java and an experimental versions for C++ as of this writing. Copy code Copied! message Server { int32 port = 1 [(validate.rules).int32 = { gte: 5000, lte: 10000 }]; }",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "619d6a3af0ed85e1ab9caf88c39ad9c9_1",
        "title": "Combining multiple JSON files by using file metadata",
        "link": "/docs/howto/combine-multiple-json-files-by-using-file-metadata/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the \u003ccode\u003ecue\u003c/code\u003e command to combine multiple JSON files by\nmaking reference to the files\u0026rsquo; metadata.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the cue command to combine multiple JSON files by making reference to the files\u0026rsquo; metadata. The TERMINAL section shows the use of: the --with-context parameter, which makes information about each input file available as metadata the filename metadata field combined with the -l parameter, which places each file\u0026rsquo;s contents at an individual and deterministic location in the evaluation space Copied! a.json Copied! b.json Copied! c.json Copy code Copied! { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 } Copy code Copied! { \u0026#34;a\u0026#34;: \u0026#34;a string\u0026#34;, \u0026#34;b\u0026#34;: true, \u0026#34;c\u0026#34;: 42 } Copy code Copied! [ \u0026#34;a list element\u0026#34;, \u0026#34;another element\u0026#34;, \u0026#34;the last element\u0026#34; ] Copied! example.cue Copy code Copied! package example // inputs is the location under which we place // each data file\u0026#39;s contents, so that their // contents can be accessed by the CUE in this // file. The cue CLI -l parameter places them // here, under a secondary key determined by each // file\u0026#39;s name. inputs: [string]: _ output: { for _name, _content in inputs { (_name): { filename: _name content: _content } } } TERMINAL Copy code Copied! $ cue export --with-context -l \u0026#39;inputs:\u0026#39; -l \u0026#39;path.Base(filename)\u0026#39; -e output a.json b.json c.json example.cue { \u0026#34;a.json\u0026#34;: { \u0026#34;filename\u0026#34;: \u0026#34;a.json\u0026#34;, \u0026#34;content\u0026#34;: { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 } }, \u0026#34;b.json\u0026#34;: { \u0026#34;filename\u0026#34;: \u0026#34;b.json\u0026#34;, \u0026#34;content\u0026#34;: { \u0026#34;a\u0026#34;: \u0026#34;a string\u0026#34;, \u0026#34;b\u0026#34;: true, \u0026#34;c\u0026#34;: 42 } }, \u0026#34;c.json\u0026#34;: { \u0026#34;filename\u0026#34;: \u0026#34;c.json\u0026#34;, \u0026#34;content\u0026#34;: [ \u0026#34;a list element\u0026#34;, \u0026#34;another element\u0026#34;, \u0026#34;the last element\u0026#34; ] } } Related content How-to Guide: Combining multiple YAML files by using file metadata Reference: cue help flags documents the --with-context and -l flags",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "919595686afd51f83eb385f6dc1763c7_1",
        "title": "Combining multiple JSON files into a list",
        "link": "/docs/howto/combine-multiple-json-files-into-a-list/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the \u003ccode\u003ecue\u003c/code\u003e command to combine multiple JSON files into a\nlist.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the cue command to combine multiple JSON files into a list. Copied! a.json Copied! b.json Copied! c.json Copy code Copied! { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;c\u0026#34;: 33.3 } Copy code Copied! { \u0026#34;a\u0026#34;: 22, \u0026#34;b\u0026#34;: \u0026#34;some string\u0026#34; } Copy code Copied! { \u0026#34;a\u0026#34;: 333, \u0026#34;c\u0026#34;: 42 } Copied! example.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // _inputs is the location under which we place // each data file\u0026#39;s contents, so that their // contents can be accessed by the CUE in this // file. The cue CLI -l parameter places them // here, under a secondary key taken from the // file\u0026#39;s name. _inputs: [string]: _ // Each file\u0026#39;s contents must adhere to the #Input // schema. _inputs: [string]: #Input #Input: { a!: int b?: string c?: number } // Construct a sorted list of the input files\u0026#39; // names so that our output (an ordered list) can // remain stable no matter the order the // filenames are provided to the cue CLI. let sortedInputs = list.SortStrings([ for k, _ in _inputs {k}, ]) // Iterate over the stable input filename list, // and emit each input file\u0026#39;s contents in turn. contents: [for _name in sortedInputs { _inputs[_name] }] TERMINAL Copy code Copied! $ cue export --with-context -l \u0026#39;_inputs:\u0026#39; -l filename a.json b.json c.json example.cue { \u0026#34;contents\u0026#34;: [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;c\u0026#34;: 33.3 }, { \u0026#34;a\u0026#34;: 22, \u0026#34;b\u0026#34;: \u0026#34;some string\u0026#34; }, { \u0026#34;a\u0026#34;: 333, \u0026#34;c\u0026#34;: 42 } ] } Related content How-to Guide: Combining multiple YAML files into a list Reference: cue help flags documents the --with-context and -l flags",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "97137bacd8488bb868e8ec59779ff3bf_1",
        "title": "Combining multiple YAML files by using file metadata",
        "link": "/docs/howto/combine-multiple-yaml-files-by-using-file-metadata/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the \u003ccode\u003ecue\u003c/code\u003e command to combine multiple YAML files by\nmaking reference to the files\u0026rsquo; metadata.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the cue command to combine multiple YAML files by making reference to the files\u0026rsquo; metadata. The TERMINAL section shows the use of: the --with-context parameter, which makes information about each input file available as metadata the filename metadata field combined with the -l parameter, which places each file\u0026rsquo;s contents at an individual and deterministic location in the evaluation space Copied! a.yaml Copied! b.yml Copied! c.yaml Copy code Copied! a: 1 b: 2 c: 3 Copy code Copied! a: a string b: true c: 42 Copy code Copied! - a list element - another element - the last element Copied! example.cue Copy code Copied! package example // inputs is the location under which we place // each data file\u0026#39;s contents, so that their // contents can be accessed by the CUE in this // file. The cue CLI -l parameter places them // here, under a secondary key determined by each // file\u0026#39;s name. inputs: [string]: _ output: { for _name, _content in inputs { (_name): { filename: _name content: _content } } } TERMINAL Copy code Copied! $ cue export --with-context -l \u0026#39;inputs:\u0026#39; -l \u0026#39;path.Base(filename)\u0026#39; -e output a.yaml b.yml c.yaml example.cue --out yaml a.yaml: filename: a.yaml content: a: 1 b: 2 c: 3 b.yml: filename: b.yml content: a: a string b: true c: 42 c.yaml: filename: c.yaml content: - a list element - another element - the last element Related content How-to Guide: Combining multiple JSON files by using file metadata Reference: cue help flags documents the --with-context and -l flags",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "ae17f125c017d0f7defa7825bdf8016f_1",
        "title": "Combining multiple YAML files into a list",
        "link": "/docs/howto/combine-multiple-yaml-files-into-a-list/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the \u003ccode\u003ecue\u003c/code\u003e command to combine multiple YAML files into a\nlist.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the cue command to combine multiple YAML files into a list. Copied! a.yaml Copied! b.yml Copied! c.yaml Copy code Copied! a: 1 b: \u0026#34;two\u0026#34; c: 33.3 Copy code Copied! a: 22 b: \u0026#34;some string\u0026#34; Copy code Copied! a: 333 c: 42 Copied! example.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // _inputs is the location under which we place // each data file\u0026#39;s contents, so that their // contents can be accessed by the CUE in this // file. The cue CLI -l parameter places them // here, under a secondary key taken from the // file\u0026#39;s name. _inputs: [string]: _ // Each file\u0026#39;s contents must adhere to the #Input // schema. _inputs: [string]: #Input #Input: { a!: int b?: string c?: number } // Construct a sorted list of the input files\u0026#39; // names so that our output (an ordered list) can // remain stable no matter the order the // filenames are provided to the cue CLI. let sortedInputs = list.SortStrings([ for k, _ in _inputs {k}, ]) // Iterate over the stable input filename list, // and emit each input file\u0026#39;s contents in turn. contents: [for _name in sortedInputs { _inputs[_name] }] TERMINAL Copy code Copied! $ cue export --with-context -l \u0026#39;_inputs:\u0026#39; -l filename a.yaml b.yml c.yaml example.cue --out yaml contents: - a: 1 b: two c: 33.3 - a: 22 b: some string - a: 333 c: 42 Related content How-to Guide: Combining multiple YAML files into a list Reference: cue help flags documents the --with-context and -l flags",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command","commented cue"],
        "authors": ["jpluscplusm"]
    },
    {
        "objectID": "a430e75a78a24fb2105e9c2d933edb59_1",
        "title": "Community",
        "link": "/community/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Join the CUE community CUE is an open source project that anyone in the community can use, improve, and enjoy. We'd love for you to join us \u0026ndash; here are a few ways to find out what's happening and get involved. Talks and Community\nTalks and Presentations Community Calls Community Calendar Get connected\nGitHub Slack Discord X (Twitter) Bluesky YouTube Contributing to CUE\nIssue Tracker Contribution Guidelines CUE Code of Conduct Project Roadmaps",
        "content": "Join the CUE community CUE is an open source project that anyone in the community can use, improve, and enjoy. We'd love for you to join us \u0026ndash; here are a few ways to find out what's happening and get involved. Talks and Community Talks and Presentations Community Calls Community Calendar Get connected GitHub Slack Discord X (Twitter) Bluesky YouTube Contributing to CUE Issue Tracker Contribution Guidelines CUE Code of Conduct Project Roadmaps Evaluator Modules Docs and Content cuelang.org CUE Language Server (cue pls)",
        "breadcrumb": [],
        "contentType": "Community",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "48df933b89f4c2249e23151780bd1c4a_1",
        "title": "Conditionally including CUE files using build attributes",
        "link": "/docs/howto/conditionally-include-cue-files-using-build-attributes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to include CUE files in an evaluation\nconditionally, using build attributes.\u003c/p\u003e",
        "content": "This guide demonstrates how to include CUE files in an evaluation conditionally, using build attributes. Our example CUE package is composed of four files: Copied! foo.cue Copied! bar.cue Copied! qux.cue Copy code Copied! @if(foo) package example \u0026#34;data from foo.cue\u0026#34;: true Copy code Copied! @if(!bar) package example \u0026#34;data from bar.cue\u0026#34;: true Copy code Copied! @if((foo \u0026amp;\u0026amp; !bar) || (!foo \u0026amp;\u0026amp; bar)) package example \u0026#34;data from qux.cue\u0026#34;: true Copied! baz.cue Copy code Copied! package example \u0026#34;data from baz.cue\u0026#34;: true The first three of these files contain build attributes, which control if the file\u0026rsquo;s contents are included in evaluations of the example package based on the presence or absence of tags: foo.cue is only included when the foo tag is present. bar.cue is only included when the bar tag is not present. qux.cue is only included when one of the bar or foo tags is present (but not when both or neither are present). baz.cue is always included. The following cue export invocations all specify different tags to change the evaluation as described above: TERMINAL Copy code Copied! $ cue export { \u0026#34;data from bar.cue\u0026#34;: true, \u0026#34;data from baz.cue\u0026#34;: true } $ cue export -t foo { \u0026#34;data from bar.cue\u0026#34;: true, \u0026#34;data from baz.cue\u0026#34;: true, \u0026#34;data from foo.cue\u0026#34;: true, \u0026#34;data from qux.cue\u0026#34;: true } $ cue export -t bar { \u0026#34;data from baz.cue\u0026#34;: true, \u0026#34;data from qux.cue\u0026#34;: true } $ cue export -t foo -t bar { \u0026#34;data from baz.cue\u0026#34;: true, \u0026#34;data from foo.cue\u0026#34;: true } The foo and bar tags are only aligned with their respective filenames to help you understand their relationships in this example. Tags and filenames do not need to overlap in any way \u0026ndash; they are entirely unrelated strings. Related content Reference: cue help injection \u0026ndash; injecting tags and values into cue command invocations",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "d6af6988627d40f2872fd76cc2d47997_1",
        "title": "Conditionally including elements in a list",
        "link": "/docs/howto/conditionally-include-list-elements/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to include elements in a list based on some testable condition.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to include elements in a list based on some testable condition. Copied! example.cue Copy code Copied! package example #a: \u0026#34;yes\u0026#34; A: [ 1, 2, // Include a single element using this form: if #a == \u0026#34;yes\u0026#34; { 3 }, // Include multiple elements using this form, // which only tests the condition once: if #a == \u0026#34;yes\u0026#34; for e in [ 4, 5, 6, ] {e}, ] TERMINAL Copy code Copied! $ cue export { \u0026#34;A\u0026#34;: [ 1, 2, 3, 4, 5, 6 ] }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "97a16fdb4b14631a65a9d88bcb6de4c4_1",
        "title": "Configuration use case",
        "link": "/docs/concept/configuration-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eArguably, validation should be the foremost task of any configuration language.\nMost configuration languages, however, focus on boilerplate removal.\nCUE is different in that it takes the validation first stance.\nBut CUE\u0026rsquo;s constraints are also effective at reducing boilerplate,\nalthough the approach it takes is quite different from conventional\ndata templating languages.\u003c/p\u003e\n\u003cp\u003eCUE basic operation merges configurations in a way that the outcome is\nalways the same regardless of the order in which it is carried out\n(it is associative, commutative and idempotent).\nThis property is the foundation for many other favorable properties, as discussed below.\u003c/p\u003e",
        "content": "Arguably, validation should be the foremost task of any configuration language. Most configuration languages, however, focus on boilerplate removal. CUE is different in that it takes the validation first stance. But CUE\u0026rsquo;s constraints are also effective at reducing boilerplate, although the approach it takes is quite different from conventional data templating languages. CUE basic operation merges configurations in a way that the outcome is always the same regardless of the order in which it is carried out (it is associative, commutative and idempotent). This property is the foundation for many other favorable properties, as discussed below. Core issues addressed by CUE Type checking For large code bases, no one will question a requirement to have a compiled/typed language. Why should one not require the same kind of rigor for data? Many configuration languages, including GCL and its offspring, focus on reducing boilerplate as the primary task of configuration. Support for typing, however, is minimal or almost non-existent. Some languages do add typing support, but it is usually limited to validating basic types, as is common with programming languages. For data, however, this is insufficient. Evidence of this is the uprise of standards like CDDL and OpenAPI that go beyond basic typing. In CUE types and values are a unified concept, which gives it very expressive, yet intuitive and compact, typing capabilities. Copy code Copied! #Spec: { kind: string name: { first: !=\u0026#34;\u0026#34; // must be specified and non-empty middle?: !=\u0026#34;\u0026#34; // optional, but must be non-empty when specified last: !=\u0026#34;\u0026#34; } // The minimum must be strictly smaller than the maximum and vice versa. minimum?: int \u0026amp; \u0026lt;maximum maximum?: int \u0026amp; \u0026gt;minimum } // A spec is of type #Spec spec: #Spec spec: { knid: \u0026#34;Homo Sapiens\u0026#34; // error, misspelled field name: first: \u0026#34;Jane\u0026#34; name: last: \u0026#34;Doe\u0026#34; } Simplicity at Scale When using a configuration language to reduce boilerplate one should consider whether the reduced verbosity is worth the increased complexity. Most configurations use an override model to reducing boilerplate: an existing configuration is used as a base and modified to result in a new configuration. This is often in the form of inheritance. For small-scale projects, using inheritance can be too complex, and the simplicity of spelling everything out is often a superior approach. For large-scale projects, however, using inheritance often leads to deep layerings of modifications, making it very hard to see where values come from. In the end, it is again questionable whether the added complexity is worth it. Like with other configuration languages, CUE can add complexity if values are organized to come from multiple places. However, as CUE disallows overrides, deep layerings are naturally prevented. More importantly, CUE can also enhance readability. A definition in one file may apply to values in many other files. Where one would usually have to open all these files to verify validity; with CUE one can see it at a glance. CUE\u0026rsquo;s approach has been battle-tested in computational linguistics where it has been used for decades to describe human languages; effectively very large, complex and irregular configurations. Abstractions versus Direct Access A common debate for configuration languages is whether a language should provide an abstraction layer for APIs. On the one hand, abstraction layers allow for protecting the user against misuse. On the other hand, they need to keep up with API changes and are inevitably prone to drift. So it goes. CUE addresses both issues. On the one hand, its fine-grained typing allows layering detailed constraints on top of native APIs, without the need for an abstraction layer. New features can be used without support of existing definitions. On the other hand, CUE\u0026rsquo;s order independence allows abstraction layers to inject arbitrary raw API in a controlled manner, allowing a general escape hatch to support new or uncovered features. See the Manual section of the Kubernetes tutorial for an example. Tooling A configuration language usually transforms its configurations to a lower-level representation, like JSON, YAML, or Protobuf so that it can be consumed by tools taking in these languages. Piping such output to the needed tools works initially; but sooner or later one will get the desire to automate this, usually in the form of some kind of tool. And so it goes. The rise of systems requiring advanced configuration has been paired with a rise of even more specialized command line tools. The core structure of all these tools is more or less the same. More annoyingly, many have overlapping functionality yet are hardly extendable or interoperable. In the latter case, one may see the need to layer on yet another set of tools. Having tools like kubectl or etcdctl that directly control core infrastructure makes sense, but at higher levels of abstraction one needs a more open approach. CUE attempts to address this by providing an open, declarative scripting layer on top of the configuration layer. Aside from the above-mentioned case, it is designed to address various other issues: inject environmental data into configuration, something not allowed in CUE itself (it is pure, or hermetic, or side-effect free) inject computed data into configurations as part of a pipeline allow composability of tool integration Again, the ability to deterministically merge data from different sources make this a shoo-in task for CUE. Comparisons Inheritance-based configuration languages Inheritance, is not commutative and idempotent in the general case. In other words, order matters. This makes it hard to track where values are coming from. This is not only true for humans, but also machines. It makes it very complicated, if not impossible, to do any kind of automation. The complexity of inheritance is even bigger if values can enter an object from one of several directions (super, overlay, etc.). The basic operation of CUE is commutative, associative and idempotent. This order independence helps both humans and machines. The resulting model is much less complex. Inheritance in CUE Although CUE does not have inheritance in the override sense, it does have the notion of one value being an instance of another. In",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "97a16fdb4b14631a65a9d88bcb6de4c4_2",
        "title": "Configuration use case",
        "link": "/docs/concept/configuration-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eArguably, validation should be the foremost task of any configuration language.\nMost configuration languages, however, focus on boilerplate removal.\nCUE is different in that it takes the validation first stance.\nBut CUE\u0026rsquo;s constraints are also effective at reducing boilerplate,\nalthough the approach it takes is quite different from conventional\ndata templating languages.\u003c/p\u003e\n\u003cp\u003eCUE basic operation merges configurations in a way that the outcome is\nalways the same regardless of the order in which it is carried out\n(it is associative, commutative and idempotent).\nThis property is the foundation for many other favorable properties, as discussed below.\u003c/p\u003e",
        "content": "fact, this is a core principle. Let\u0026rsquo;s use a real-world example to make this distinction clear: In the override model of inheritance, one can take an existing template, say a dog, and modify it to become a cat. Trim the ears, dry off the nose, and what have you. In CUE, it is a matter of classification. Cats and dogs are both instances of animals, but once an entity is defined to be a cat, it can never become a dog. To most humans (aka computer scientists that have not become accustomed to inheritance) this makes total sense. Although one can create instances of values (remember, types are values), one can not alter any of the values of a parent. A template acts as a type. Just as in statically typed languages where one cannot assign an integer to a string, one cannot violate the properties of a type in CUE. These restrictions reduce flexibility, but also enhance clarity. To ensure that a configuration holds a certain property, just declare it in any file included in the project to make it so. There is no need to look at other files. As we saw; the imposed restrictions can also improve, rather than hurt, the ability to remove boilerplate compared to inheritance-based languages. The complexity of inheritance-based models also hampers automation. The introduction of GCL was paired with the promise of advanced tooling. The mantra of declarative languages was even repeated with some of its offspring. The tooling never materialized, though, as the model made it intractable. CUE already provides power tools like trim, and its API provides unify and subsumption operations for incomplete configurations, the building blocks for powerful analysis. Jsonnet/ GCL Like Jsonnet, CUE is a superset of JSON. They also are both influenced by GCL. CUE, in turn is influenced by Jsonnet. This may give the semblance that the languages are very similar. At the core, though, they are very different. CUE\u0026rsquo;s focus is data validation whereas Jsonnet focuses on data templating (boilerplate removal). Jsonnet was not designed with validation in mind. Jsonnet and GCL can be quite powerful at reducing boilerplate. The goal of CUE is not to be better at boilerplate removal than Jsonnet or GCL. CUE was designed to be an answer to two major shortcomings of these approaches: complexity and lack of typing. Jsonnet reduces some of the complexities of GCL, but largely falls into the same category. For CUE, the tradeoff was to add typing and reduce complexity (for humans and machines), at the expense of giving up flexibility. HCL HCL has some striking similarities with GCL. But whether this was a coincidence or deliberate, it removes the core source of complexity of GCL: inheritance. It does introduce a poor man\u0026rsquo;s version of inheritance: file overlays. Fields may be defined in multiple files that get overwritten in a certain order of the file names. Although not nearly as complex as GCL, it does have some of the same issues. Also, whether the removal of inheritance was a coincidence or great insight, there is no construct given in return that one might need for larger scale configuration management. This means the use of HCL may hit a ceiling for medium to larger setups. So what CUE has to offer to users of HCL is: typing, better growth prospects to larger scale operations, and eliminating the peculiarities of file overlays. CUE does borrow one construct from HCL: the folding of single-field objects onto a single line was directly inspired by HCL\u0026rsquo;s very similar approach.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "7d9f5161a700bf8da00cbc43264427c7_1",
        "title": "Constraining a string to be a valid integer",
        "link": "/docs/howto/constrain-string-as-valid-integer/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to constrain fields to contain string representations of\ninteger values.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to constrain fields to contain string representations of integer values. Copied! example.cue Copy code Copied! package example import \u0026#34;strconv\u0026#34; // Constrain s1 and s2 to be the string // interpolation of the result of converting // their respective values to integers. s1?: \u0026#34;\\(strconv.Atoi(s1))\u0026#34; s2?: \u0026#34;\\(strconv.Atoi(s2))\u0026#34; Copied! data.yml Copy code Copied! # s1 is a valid integer s1: \u0026#34;137\u0026#34; # s2 is not a valid integer s2: \u0026#34;42.7\u0026#34; TERMINAL Copy code Copied! $ cue vet -c .:example data.yml s2: invalid interpolation: error in call to strconv.Atoi: strconv.Atoi: parsing \u0026#34;42.7\u0026#34;: invalid syntax: ./example.cue:9:6 ./example.cue:9:9 The constraint enforces that the concrete values of s1 and s2 are equal to the string-to-int-to-string conversions of those same values. This process must start and end with identical values, otherwise validation fails, as in the case of s2. cue\u0026rsquo;s error messages can, at times, be rather hard to interpret. This is an area we are actively looking to improve. Please raise bug reports with examples you find hard to understand. Related content The strconv package in the CUE standard library",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["validation","commented cue"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "547969e60877c2942008e68241101123_1",
        "title": "Constraining the length of a string",
        "link": "/docs/howto/constrain-the-length-of-a-string/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to make sure a string has a minimum length, or a maximum\nlength, or both.\u003c/p\u003e\n\u003cp\u003eThis CUE shows string fields being constrained by their lengths as expressed in\nbytes, and also in runes, as introduced by\n\u003ca href=\"https://go.dev/blog/strings#code-points-characters-and-runes\"\u003ethe Go programming language\u003c/a\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to make sure a string has a minimum length, or a maximum length, or both. This CUE shows string fields being constrained by their lengths as expressed in bytes, and also in runes, as introduced by the Go programming language. Copied! example.cue Copy code Copied! package example import \u0026#34;strings\u0026#34; // 2 examples that use only single-byte, ASCII characters ascii_constrain_runes: \u0026#34;only ASCII characters\u0026#34; // 21 runes composed of 21 bytes // enforce that the field contains between 2 and 8 runes ascii_constrain_runes: strings.MinRunes(2) \u0026amp; strings.MaxRunes(8) ascii_constrain_bytes: { // set up an alias to allow the following CUE to refer to it let content = \u0026#34;only ASCII characters\u0026#34; // 21 runes composed of 21 bytes // this embedded scalar ultimately sets the value of the containing field, // \u0026#34;ascii_constrain_bytes\u0026#34; content // enforce that \u0026#34;content\u0026#34; contains between 50 and 100 bytes #bytes: len(content) \u0026amp; \u0026gt;=50 \u0026amp; \u0026lt;=100 } // 2 examples that use multi-byte, South Korean Hangul characters multibyte_constrain_runes: \u0026#34;\u0026#34; // 2 runes composed of 6 bytes // enforce that the field contains 5 or fewer runes multibyte_constrain_runes: strings.MaxRunes(5) multibyte_constrain_bytes: { // set up an alias to allow the following CUE to refer to it let content = \u0026#34;\u0026#34; // 2 runes composed of 6 bytes // this embedded scalar ultimately sets the value of the containing field, // \u0026#34;multibyte_constrain_bytes\u0026#34; content // enforce that \u0026#34;content\u0026#34; contains 5 or fewer bytes #bytes: len(content) \u0026amp; \u0026lt;=5 } // 2 examples that use multi-byte, emoji characters emoji_constrain_runes: \u0026#34;\u0026#34; // 4 runes composed of 16 bytes // enforce that the field contains 10 or more runes emoji_constrain_runes: strings.MinRunes(10) emoji_constrain_bytes: { // set up an alias to allow the following CUE to refer to it let content = \u0026#34;\u0026#34; // 4 runes composed of 16 bytes // this embedded scalar ultimately sets the value of the containing field, // \u0026#34;emoji_constrain_bytes\u0026#34; content // enforce that \u0026#34;content\u0026#34; contains 10 or more bytes #bytes: len(content) \u0026amp; \u0026gt;=10 } TERMINAL Copy code Copied! $ cue vet -c .:example ascii_constrain_runes: invalid value \u0026#34;only ASCII characters\u0026#34; (does not satisfy strings.MaxRunes(8)): ./example.cue:8:46 ./example.cue:6:24 ./example.cue:8:24 ./example.cue:8:63 ascii_constrain_bytes.#bytes: invalid value 21 (out of bound \u0026gt;=50): ./example.cue:19:25 ./example.cue:19:10 multibyte_constrain_bytes.#bytes: invalid value 6 (out of bound \u0026lt;=5): ./example.cue:36:25 ./example.cue:36:10 emoji_constrain_runes: invalid value \u0026#34;\u0026#34; (does not satisfy strings.MinRunes(10)): ./example.cue:42:24 ./example.cue:40:24 ./example.cue:42:41 The len()-based examples use an embedded scalar value with an alias to permit their fields to be of type string whilst also allowing their byte lengths to be constrained. This pattern will be obsoleted by the must() directive, which is tracked in issue #575.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","validation"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "bc038372b79119e998a5096ba8a25d52_1",
        "title": "Constraining the sum of a list of numbers",
        "link": "/docs/howto/constrain-the-sum-of-a-list-of-numbers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates constraining the sum of a list of numbers.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates constraining the sum of a list of numbers. Copied! schema.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // both data fields are lists of numbers good_list: [...number] bad_list: [...number] // We introduce a hidden CUE field for each list // we want to check. Each hidden field unifies // the relevant value constraint with the list\u0026#39;s // sum _good_sum: \u0026lt;=100 \u0026amp; list.Sum(good_list) _bad_sum: \u0026lt;=99.5 \u0026amp; list.Sum(bad_list) Copied! data.yml Copy code Copied! good_list: [ 1,2,3,4 ] bad_list: [ 1,2,3,100.5 ] TERMINAL Copy code Copied! $ cue vet -c .:example data.yml _bad_sum: invalid value 106.5 (out of bound \u0026lt;=99.5): ./schema.cue:14:12 ./schema.cue:14:21",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["validation","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "96b016883ee51994c075d5d4601f6538_1",
        "title": "Controlling Kubernetes with CUE",
        "link": "/docs/tutorial/controlling-kubernetes/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn this tutorial you will learn how to import Kubernetes configuration files\nfor a collection of microservices.\u003c/p\u003e\n\u003cp\u003eThis tutorial can be read on CUE By Example:\n\u003ca href=\"https://github.com/cue-labs/cue-by-example/tree/main/003_kubernetes_tutorial#controlling-kubernetes-with-cue\"\u003egithub.com/cue-labs/cue-by-example\u003c/a\u003e.\u003c/p\u003e",
        "content": "In this tutorial you will learn how to import Kubernetes configuration files for a collection of microservices. This tutorial can be read on CUE By Example: github.com/cue-labs/cue-by-example.",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["cue command","tooling"],
        "authors": ""
    },
    
            {
        "objectID": "40487ead2d9951b551b74b5b7ead684b_1",
        "title": "Converting JSON Schema to CUE",
        "link": "/docs/tutorial/converting-json-schema-to-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eCUE is a concise and powerful language for describing and constraining data, but\nnot all systems speak CUE. Some systems can only produce schemas formatted in\n\u003ca href=\"https://json-schema.org/\"\u003eJSON Schema\u003c/a\u003e. This isn\u0026rsquo;t a problem for the \u003ccode\u003ecue\u003c/code\u003e\ncommand because it speaks JSON Schema - letting you use JSON Schema alongside\nschemas written in CUE.\u003c/p\u003e\n\u003cp\u003eIn this tutorial you\u0026rsquo;ll use \u003ccode\u003ecue\u003c/code\u003e to convert a JSON Schema to CUE,\nand then use the result to validate some data.\u003c/p\u003e",
        "content": "Introduction CUE is a concise and powerful language for describing and constraining data, but not all systems speak CUE. Some systems can only produce schemas formatted in JSON Schema. This isn\u0026rsquo;t a problem for the cue command because it speaks JSON Schema - letting you use JSON Schema alongside schemas written in CUE. In this tutorial you\u0026rsquo;ll use cue to convert a JSON Schema to CUE, and then use the result to validate some data. Prerequisites The cue binary \u0026ndash; follow the installation instructions if you don\u0026rsquo;t already use cue A tool to edit text files \u0026ndash; any text editor you have will be fine, such as VSCode, Notepad, or Vim A command terminal \u0026ndash; cue works on all platforms, so you can use any Linux or macOS terminal, or a Windows terminal such as PowerShell, cmd, or WSL to run commands. Some awareness of CUE schemata \u0026ndash; the language tour\u0026rsquo;s pages on Constraints and Definitions are a good refresher This tutorial is written using the following version of cue: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Steps This tutorial takes you through converting some JSON Schema to a CUE definition using the cue import command, and then using the result to validate some YAML. 1Create a JSON schema file: Copied! schema.json Copy code Copied! { \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;additionalProperties\u0026#34;: false, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;cuisine\u0026#34;, \u0026#34;tables\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;cuisine\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;tables\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/table\u0026#34; } } }, \u0026#34;$defs\u0026#34;: { \u0026#34;table\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;additionalProperties\u0026#34;: false, \u0026#34;required\u0026#34;: [ \u0026#34;seats\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;seats\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;minimum\u0026#34;: 2, \u0026#34;maximum\u0026#34;: 10 }, \u0026#34;view\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } } } } } This schema validates data that defines a restaurant. 2Convert the JSON Schema to a CUE definition called #restaurant: TERMINAL Copy code Copied! $ cue import -l \u0026#39;#restaurant:\u0026#39; -p cuisine schema.json It\u0026rsquo;s good practise to tell cue to place imported CUE inside a package. Here, we choose the cuisine package. cue import creates the file schema.cue containing this CUE: Copied! schema.cue Copy code Copied! package cuisine #restaurant: { @jsonschema(schema=\u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;) close({ name!: string cuisine!: string tables!: [...#table] }) #table: close({ seats!: \u0026gt;=2 \u0026amp; \u0026lt;=10 view?: bool }) } CUE natively understands JSON Schema, and is able to convert all of the JSON Schema constraints into CUE constraints. Notice the CUE schema is also considerably more concise and readable. 3Create some data files that contain restaurant details: Copied! split_pea.yml Copy code Copied! name: The Split Pea cuisine: Contemporary tables: - seats: 4 view: true - seats: 6 Copied! pomodoro.yml Copy code Copied! name: Il Pomodoro Marcio cuisine: Italian tables: - seats: 100 - seats: 8 view: true One of these files contains a deliberate problem that cue will catch for us, shortly. If you spotted the problem while entering the data, make sure you didn\u0026rsquo;t correct it! 4Validate the data using the schema and constraints: TERMINAL Copy code Copied! $ cue vet -c -d \u0026#39;#restaurant\u0026#39; schema.cue *.yml tables.0.seats: invalid value 100 (out of bound \u0026lt;=10): ./schema.cue:13:17 ./pomodoro.yml:4:12 cue vet outputs nothing when validation succeeds. But as you can see, there are some validation errors. 5Fix the data validation error by updating your pomodoro.yml file: Copied! pomodoro.yml Copy code Copied! name: Il Pomodoro Marcio cuisine: Italian tables: - seats: 10 - seats: 8 view: true 6Re-validate the data using the schema and constraints: TERMINAL Copy code Copied! $ cue vet -c -d \u0026#39;#restaurant\u0026#39; schema.cue *.yml The \u0026ldquo;silent\u0026rdquo; lack of output from cue vet confirms that the fixed data validates successfully. Conclusion You\u0026rsquo;ve completed this tutorial - well done! In this tutorial you converted JSON Schema to CUE using cue import, and then used the resulting CUE to catch and fix an error in some data.",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["cue command","encodings"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "04548aed4ae87eb8e15336b1e686b016_1",
        "title": "Converting values between Java and CUE",
        "link": "/docs/tutorial/convert-values-java-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library \u003ccode\u003ecue-api-java\u003c/code\u003e provides a way to use CUE from Java programs.\nThis tutorial helps you to use the library to convert Java values to CUE\nvalues, and to convert \u003cem\u003econcrete\u003c/em\u003e CUE values to Java values.\u003c/p\u003e\n\u003cp\u003eNot all CUE values can be represented in Java. For instance, the CUE constraint\n\u003ccode\u003eint \u0026amp; \u0026lt;5\u003c/code\u003e doesn\u0026rsquo;t have a direct equivalent in Java.\u003c/p\u003e\n\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003ecue-api-java\u003c/code\u003e is an experimental technology preview. This means that it\u0026rsquo;s\nunder development and its behaviour might change from one release to the next.\u003c/div\u003e\n\u003c/div\u003e",
        "content": "The library cue-api-java provides a way to use CUE from Java programs. This tutorial helps you to use the library to convert Java values to CUE values, and to convert concrete CUE values to Java values. Not all CUE values can be represented in Java. For instance, the CUE constraint int \u0026amp; \u0026lt;5 doesn\u0026rsquo;t have a direct equivalent in Java. cue-api-java is an experimental technology preview. This means that it\u0026rsquo;s under development and its behaviour might change from one release to the next. Prerequisites You need the low-level library libcue to be compiled and available on your computer, which is demonstrated in the guide \u0026ldquo;Building libcue as a shared library\u0026rdquo;. You must have the Java library cue-api-java compiled and available on your computer. The guide \u0026ldquo;Building cue-api-java as a JAR file\u0026rdquo; shows you how to compile and install it. This tutorial needs you to install the same version as that guide. Your computer needs to have the Java Development Kit (JDK) version 22 (or later) installed. If you need help choosing a distribution of Java, the site whichjdk.com is a useful guide. Note that many operating systems offer a \u0026ldquo;Long Term Support\u0026rdquo; version of Java, but this often means JDK version 21, which isn\u0026rsquo;t recent enough. Make sure that you have version 22 or later! Set up your environment 1Tell the operating system (and Java) where to find the library libcue on your computer: TERMINAL Copy code Copied! $ export LD_LIBRARY_PATH=/usr/local/lib/ If you have installed libcue into a different directory than /usr/local/lib/ then adapt the command to refer to that directory instead. 2Tell Java where to find the library cue-api-java on your computer: TERMINAL Copy code Copied! $ export CLASSPATH=\u0026#39;/usr/local/share/java/*\u0026#39; If you have installed cue-api-java into a different directory than /usr/local/share/java/ then adapt the command to refer to that directory instead. 3Cross-check the value of this important variable: TERMINAL Copy code Copied! $ echo \u0026#34;$CLASSPATH\u0026#34; /usr/local/share/java/* Java\u0026rsquo;s requirements mean that we need the value of the CLASSPATH variable to end with an asterisk: make sure you see the trailing *. If this value ends with a filename instead of an asterisk (for example: /usr/local/share/java/CUE.jar) then you need to fix this. Repeat the previous step while making sure that you surround the value of the variable with quotes (') when you export it. 4Check that this tutorial\u0026rsquo;s prerequisites are present: TERMINAL Copy code Copied! $ javac --version javac 22.0.2 $ ls $LD_LIBRARY_PATH | grep libcue.so || echo \u0026#39;fail!\u0026#39; libcue.so $ ls $CLASSPATH | grep /CUE.*jar$ || echo \u0026#39;fail!\u0026#39; /usr/local/share/java/CUE.jar If any of these commands fail then your computer doesn\u0026rsquo;t have the related prerequisite installed as expected and this is a problem that you need to fix before continuing with this tutorial. 5Create a directory to hold some files, and change into it: TERMINAL Copy code Copied! $ mkdir -p cue-java-api-tutorials $ cd cue-java-api-tutorials Create a Java program 6Place this Java program in the file ConvertValues.java: Copied! cue-java-api-tutorials/ConvertValues.java Copy code Copied! import java.util.Arrays; import org.cuelang.cue.*; public class ConvertValues { public static void main(String[] args) throws Exception { var ctx = new CueContext(); // The toValue() method converts a Java value to a CUE value. var v1 = ctx.toValue(42); // A Value can also be constructed, which achieves the same result. var v2 = new Value(ctx, 42); System.out.println(\u0026#34;v1 equals v2: \u0026#34; + v1.equals(v2)); System.out.println(); // Various Java types can be converted using either mechanism. var aBool = ctx.toValue(false); var aLong = ctx.toValue(42); var aDouble = ctx.toValue(1.2345); var aString = new Value(ctx, \u0026#34;Hello!\u0026#34;); byte[] buf = {1, 2, 3, 4, 5}; var aSlice = ctx.toValue(buf); // The different getX() methods convert a concrete CUE value to a Java value. System.out.println(\u0026#34;aBool is: \\t\u0026#34; + aBool.getBoolean()); System.out.println(\u0026#34;aLong is: \\t\u0026#34; + aLong.getLong()); System.out.println(\u0026#34;aDouble is: \u0026#34; + aDouble.getDouble()); System.out.println(\u0026#34;aString is: \u0026#34; + aString.getString()); System.out.println(\u0026#34;aSlice is: \\t\u0026#34; + Arrays.toString(aSlice.getBytes())); System.out.println(); // The getJSON() method converts a concrete CUE value to its JSON // representation as a Java String. var aStruct = ctx.compile(\u0026#34;\u0026#34;\u0026#34; x: { y: { a: true b: 42 } } \u0026#34;\u0026#34;\u0026#34;); System.out.println(\u0026#34;aStruct as JSON: \\t\u0026#34; + aStruct.getJSON()); System.out.println(\u0026#34;aString as JSON: \\t\u0026#34; + aString.getJSON()); System.out.println(\u0026#34;aBool as JSON: \\t\\t\u0026#34; + aBool.getJSON()); } } Compile the program 7Compile the Java program: TERMINAL Copy code Copied! $ javac ConvertValues.java The Java compiler automatically uses the value of the CLASSPATH environment variable to locate the JAR file containing cue-api-java. Run the program 8Run the Java program: TERMINAL Copy code Copied! $ java --enable-native-access=ALL-UNNAMED -cp .:$CLASSPATH ConvertValues v1 equals v2: true aBool is: false aLong is: 42 aDouble is: 1.2345 aString is: Hello! aSlice is: [1, 2, 3, 4, 5] aStruct as JSON: {\u0026#34;x\u0026#34;:{\u0026#34;y\u0026#34;:{\u0026#34;a\u0026#34;:true,\u0026#34;b\u0026#34;:42}}} aString as JSON: \u0026#34;Hello!\u0026#34; aBool as JSON: false The Java runtime must be told about a slightly different classpath from the compiler, through the -cp flag, because it needs to locate both the cue-api-java JAR and your compiled code. The --enable-native-access flag avoids a runtime warning that the Foreign Function \u0026amp; Memory API is being used by cue-api-java. Conclusion Well done - you\u0026rsquo;ve successfully converted values between CUE and Java! See Related content, below, for tutorials and guides that explain more about using CUE in Java. Related content How-to Guide: Building cue-api-java as a JAR file Tutorial: Getting started using CUE in Java Tutorial: Handling errors in the Java API Tutorial: Validating data against a schema in Java java api \u0026ndash; all pages exploring the CUE Java API",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["java api"],
        "authors": ["jpluscplusm","4ad"]
    },
    {
        "objectID": "3971dee9690c45ec29595f6ae97154f9_1",
        "title": "CUE",
        "link": "/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "Configure Unify Execute Validate, define, and use dynamic and text\u0026#8209;based data\nLearn more Get started with CUE CUE makes it easy to validate data, write schemas, and ensure configurations align with policies.\nGet started learning about CUE with these links .. Let's begin Introduction Take a tour Language Tour Download and install Install GitHub Infinite possibilities CUE is an open source language, with a rich set of APIs and tooling, for defining, generating, and validating all kinds of data: configuration, APIs, database schemas, code, .",
        "content": "Configure Unify Execute Validate, define, and use dynamic and text\u0026#8209;based data Learn more Get started with CUE CUE makes it easy to validate data, write schemas, and ensure configurations align with policies. Get started learning about CUE with these links .. Let's begin Introduction Take a tour Language Tour Download and install Install GitHub Infinite possibilities CUE is an open source language, with a rich set of APIs and tooling, for defining, generating, and validating all kinds of data: configuration, APIs, database schemas, code, ... just name it! Data validation Validate text-based data like JSON or YAML using CUE's powerful and flexible constraints Learn more Learn more Configuration Validate existing configurations \u0026circledcirc; Check JSON, YAML and CUE config files \u0026circledcirc; Reduce boilerplate in large-scale configurations \u0026circledcirc; \u0026amp; more Learn more Learn more Schema definition Validate text-based data files or programmatic data such as incoming RPCs or database documents Learn more Learn more Scripting Automate the use of your data without writing yet another tool Learn more Learn more Generate code and schema Keep validation code in sync across code bases, Protobuf definitions, and OpenAPI definitions Learn more Learn more Querying Find the locations of instances of CUE types and values in data Learn more Learn more Learn more CUE integrations CUE works with a wide range of tools and formats that you're already using ... Go Read about how CUE\u0026rsquo;s Go API brings its power and flexibility into your programs, and lets you convert Go types to CUE schemas. Learn more Learn more JSON CUE might look a bit like JSON, but that\u0026rsquo;s where the similarity ends. Discover how CUE helps you tame your static JSON data files. Learn more Learn more YAML Love YAML\u0026rsquo;s \u0026ldquo;anchors\u0026rdquo;? No. No, you don\u0026rsquo;t - no-one does \u0026hellip; and for good reason! Learn about how CUE reads and writes YAML, whilst delivering a much better referencing system! Learn more Learn more OpenAPI CUE has first class support for OpenAPI\u0026rsquo;s data schemas, using them to validate data directly. See how CUE makes OpenAPI easier to handle and understand. Learn more Learn more JSON Schema JSON Schema can be used as if it were CUE - and can be converted to CUE just as easily. Find out more about CUE\u0026rsquo;s native support for JSON Schema. Learn more Learn more Protocol Buffers CUE understands Protocol Buffers, extending Protobuf\u0026rsquo;s capabilities by validating data values and not just the data schema. Find out how \u0026hellip; Learn more Learn more CUE users Organizations in every industry use CUE to power their software and services Go to the website Go to the website Go to the website Go to the website Go to the website Go to the website Go to the website Go to the website Supporters of CUE Organizations actively supporting CUE Go to the website Go to the website",
        "breadcrumb": [],
        "contentType": "CUE",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "e953566b8c2d6048a9ebb8d1b0d3bbe5_1",
        "title": "CUE language versions",
        "link": "/docs/concept/cue-language-version/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ccode\u003ecue.mod/module.cue\u003c/code\u003e file has a mandatory \u003ccode\u003elanguage.version\u003c/code\u003e field\nthat sets the language version for a given module. But what does it actually\ndo? This page explores that question.\u003c/p\u003e",
        "content": "The cue.mod/module.cue file has a mandatory language.version field that sets the language version for a given module. But what does it actually do? This page explores that question. Here is an example module.cue file: Copied! cue.mod/module.cue Copy code Copied! module: \u0026#34;cue.example\u0026#34; language: version: \u0026#34;v0.9.2\u0026#34; At the time of writing, the latest CUE release is v0.9.2, so we can see that the language version is closely related to the CUE toolchain (cue command or API) version. The language.version field is required for two main reasons. The information that it encodes: protects you from using CUE modules that rely on language features that aren\u0026rsquo;t implemented in the version of CUE you have installed; allows the CUE language developers to make changes to the language that aren\u0026rsquo;t backwards compatible Let us consider each of these separately. Use of future-versioned code When the CUE evaluator comes across a module that declares a language version greater than that of the evaluator itself, it produces an error. This is because the evaluator cannot know what semantics apply to the newer version. Even if the module does not actually make use of any newer language features, the older version of the evaluator cannot know that\u0026rsquo;s the case, so the conservative choice is to produce an error. This would happen, for example, if you used v0.9.0 of the cue command to evaluate a module that declares a language.version field containing v0.10.0. As a historical counterpoint, the Go language took a different approach initially: when it came across a newer version, it tried to compile the code anyway, optimistically assuming that it might be OK. On failure, it produced an error message saying that the syntax error \u0026ldquo;might be due to use of a newer language feature\u0026rdquo;. CUE does not use that approach for a few reasons: the resulting errors are obscure and may well not pinpoint the actual reason for failure, which may not be anything to do with the language version the language change might be subtle enough that it doesn\u0026rsquo;t actually result in an error Go deliberately moved away from that approach Making backwards incompatible changes It\u0026rsquo;s important to be able to move forward with changes to the language, adding new features, and sometimes deprecating or even removing features. One example is the way that aliases are defined. Originally, an alias was defined using this syntax: Copy code Copied! x = 5 // Don\u0026#39;t use this old alias syntax! but in more recent CUE versions, this has been changed to: Copy code Copied! let x = 5 If the language were never to be changed in a backwards incompatible way, the original syntax would need to be supported forever, but that would preclude the possibility of moving forward and perhaps repurposing the x=5 syntax for other things. However, having the language version inside the module.cue file provides the CUE language designers with the freedom to both support the old syntax and to repurpose it for other things by interpreting the files in a module in the knowledge of the language version declared for that module. Specifically the evaluator can see that a module declares an older version and apply the older syntax or semantics to the files in that module. This also applies to changes to the module.cue schema itself. Although the CUE developers will strive to avoid making backwards incompatible changes, they cannot necessarily foresee future requirements, so the language version also allows us to make backwards incompatible changes to the module.cue file syntax. How CUE behaves So how does CUE actually behave when it evaluates modules? Given an evaluator version E and a module version V: if V is after E, the evaluator will fail with an error (module is too new) if V is before E, the evaluator will interpret the module as if it were evaluator version V In time, it is likely that support for some old features will be removed, with plenty of notice given. In that case, if V is a long way before E, the evaluator may fail instead of interpreting the module as V.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "a13025903757ccdf9b12f578d922dbae_1",
        "title": "CUE Modules",
        "link": "/docs/reference/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eModules are how CUE manages dependencies.\nThis document is a detailed reference manual for CUE\u0026rsquo;s module system.\nCUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules\nand this document has substantial parts that have been taken\ndirectly from the \u003ca href=\"https://go.dev/ref/mod\"\u003eGo modules reference\u003c/a\u003e.\nThanks very much to Russ Cox and the Go team for their\namazing work there.\u003c/p\u003e\n\u003cp\u003eThis document largely supercedes the\n\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eprior modules documentation\u003c/a\u003e\nalthough, as a transitionary measure, the CUE tool still supports\nthe import of packages present in the \u003ccode\u003ecue.mod/pkg\u003c/code\u003e, \u003ccode\u003ecue.mod/usr\u003c/code\u003e and\n\u003ccode\u003ecue.mod/gen\u003c/code\u003e directories. This only applies to the main module, and if\nthere is any ambiguity with respect to regular module dependencies an\n\u0026ldquo;ambiguous import\u0026rdquo; error will be reported.\u003c/p\u003e",
        "content": "Introduction Modules are how CUE manages dependencies. This document is a detailed reference manual for CUE\u0026rsquo;s module system. CUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules and this document has substantial parts that have been taken directly from the Go modules reference. Thanks very much to Russ Cox and the Go team for their amazing work there. This document largely supercedes the prior modules documentation although, as a transitionary measure, the CUE tool still supports the import of packages present in the cue.mod/pkg, cue.mod/usr and cue.mod/gen directories. This only applies to the main module, and if there is any ambiguity with respect to regular module dependencies an \u0026ldquo;ambiguous import\u0026rdquo; error will be reported. Modules, packages, and versions A module is a collection of packages that are released, versioned, and distributed together. Modules are downloaded from OCI-compliant artifact registries. This means that if you are deploying CUE to the cloud, you can use the same distribution mechanism that you might be using for Docker images to deploy your CUE configuration too. A module is identified by a module path, which is declared in a cue.mod/module.cue file, together with information about the modules dependencies. The module root directory is the directory that contains the cue.mod directory. The main module is the module containing the directory where the cue command is invoked. Each package within a module is a collection of source files that are unified together, usually all in the same directory. A package path is the module path joined with the subdirectory containing the package, relative to the module root. Module paths A module path is the canonical name for a module, declared with the module field in the modules cue.mod/module.cue file. A modules path is the prefix for package paths within the module. A module path consists of a root path and a major version suffix, for example in the module path myhost.example/foo@v0, the root path is myhost.example/foo and the major version suffix is @v0. Module paths are domain-name qualified: a module path always begins with a host name, although that host is only a guide to the origin of the module and is not used directly to fetch the module\u0026rsquo;s contents (see here for details about that)). The expectation is that any modules you create should have names that are inside domains or namespaces that you have control of, enabling modules from different creators to live together without conflicts in the same registry. The root path is the portion of the module path that identifies the OCI repository within a registry. All versions of a module are located in that same OCI repository. The major version suffix declares the major version of the module and is of the form @v1 where the version v1 here must match the major version of the full version it\u0026rsquo;s been published as. There are also several lexical restrictions on characters allowed in module paths. As modules are stored in OCI repositories, these correspond to the restrictions documented there. To summarize: The path must consist of one or more path elements separated by slashes (/, U+002F). It must not begin or end with a slash. No characters are allowed in the path except lower case ASCII letters, ASCII digits, and limited ASCII punctuation (-, _, .). The first character of each path element is a letter or a digit. No more than one period (.) is allowed in sequence. No more than two underscores (_) are allowed in sequence. In addition, the first path element must contain at least one period character (.). No restriction is directly enforced on the length of module names, but as registries can refuse module paths over 128 characters, and it\u0026rsquo;s possible to specify an arbitrary storage prefix, long module paths may fail. Versions A version identifies an immutable snapshot of a module, which may be either a release or a pre-release (with a pre-release suffix). Each version starts with the letter v, followed by a semantic version. See Semantic Versioning 2.0.0 for details on how versions are formatted, interpreted, and compared. To summarize, a semantic version consists of three non-negative integers (the major, minor, and patch versions, from left to right) separated by dots. The patch version may be followed by an optional pre-release string starting with a hyphen. Each part of a version indicates whether the version is stable and whether it is compatible with previous versions. The major version must be incremented and the minor and patch versions must be set to zero after a backwards incompatible change is made to the module\u0026rsquo;s public interface or documented functionality, for example, after a package is removed. The minor version must be incremented and the patch version set to zero after a backwards compatible change, for example, after a new function is added. The patch version must be incremented after a change that does not affect the module\u0026rsquo;s public interface, such as a bug fix or change to the documentation. The pre-release suffix indicates a version is a pre-release. Pre-release versions sort before the corresponding release versions. For example, v1.2.3-pre comes before v1.2.3. A version is considered unstable if its major version is 0 or it has a pre-release suffix. Unstable versions are not subject to compatibility requirements. For example, v0.2.0 may not be compatible with v0.1.0, and v1.5.0-beta may not be compatible with v1.5.0. Major version suffixes Module paths must have a major version suffix like @v2 that matches the major version. For example, if a module has the path foo.example/mod@v1 at v1.0.0, it must have the path foo.example/mod@v2 at version v2.0.0. Major version suffixes implement the import compatibility rule: If an old package and a new package have the same import path, the new package must be backwards compatible with the old package. By definition, packages in a new major version of a module are not backwards compatible with the corresponding packages in the previous major version. Consequently each new major version of a package needs a new import path. This is accomplished",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "a13025903757ccdf9b12f578d922dbae_2",
        "title": "CUE Modules",
        "link": "/docs/reference/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eModules are how CUE manages dependencies.\nThis document is a detailed reference manual for CUE\u0026rsquo;s module system.\nCUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules\nand this document has substantial parts that have been taken\ndirectly from the \u003ca href=\"https://go.dev/ref/mod\"\u003eGo modules reference\u003c/a\u003e.\nThanks very much to Russ Cox and the Go team for their\namazing work there.\u003c/p\u003e\n\u003cp\u003eThis document largely supercedes the\n\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eprior modules documentation\u003c/a\u003e\nalthough, as a transitionary measure, the CUE tool still supports\nthe import of packages present in the \u003ccode\u003ecue.mod/pkg\u003c/code\u003e, \u003ccode\u003ecue.mod/usr\u003c/code\u003e and\n\u003ccode\u003ecue.mod/gen\u003c/code\u003e directories. This only applies to the main module, and if\nthere is any ambiguity with respect to regular module dependencies an\n\u0026ldquo;ambiguous import\u0026rdquo; error will be reported.\u003c/p\u003e",
        "content": "by adding a major version suffix to the module path. The import path for a package also includes the major version suffix, providing a distinct import path for each incompatible version. Unlike in Go, major version suffixes are always required in module paths . The burden of changing import paths in packages is eased by allowing the major version suffix to be omitted and inferred from the module.cue file. See major version defaults for details. Major version suffixes let multiple major versions of a module coexist in the same build. This may be necessary due to a diamond dependency problem. Ordinarily, if a module is required at two different versions by transitive dependencies, the higher version will be used. However, if the two versions are incompatible, neither version will satisfy all clients. Since incompatible versions must have different major version numbers, they must also have different module paths due to major version suffixes. This resolves the conflict: modules with distinct suffixes are treated as separate modules, and their packageseven packages in same subdirectory relative to their module rootsare distinct. Major version defaults When a package import path does not contain a major version, the module.cue file is consulted to determine which major version of the module to use. In a canonical module.cue file, all imports without major versions will have an explicit default: true present in the corresponding dependency entry, but cue mod tidy will add those if not present and there is no ambiguity in the build list. That is, given only a single major version of a module in the build list, the major version need not be specified in any of the package imports. Resolving a package to a module When CUE loads a package using a package path, it needs to determine which module provides the package. It starts by searching the build list for modules with paths that are prefixes of the package path. For example, if the package foo.example/a/b is imported, and the module foo.example/a is in the build list, CUE will check whether foo.example/a contains the package, in the directory b. At least one file with the .cue extension must be present in a directory for it to be considered a package. Build constraints are not applied for this purpose. If exactly one module in the build list provides the package, that module is used. If no modules provide the package or if two or more modules provide the package, CUE reports an error. The cue mod tidy command will attempt to find new modules providing missing packages and to update cue.mod/module.cue accordingly. The CUE_REGISTRY environment variable When CUE looks up a new module for a package path, it checks the CUE_REGISTRY environment variable. This determines the registry and repository within a registry that a module will be searched for. It holds a complete list of any registries that are consulted for fetching modules. Specifically it holds a comma-separated list specifying which registry to use for downloading and publishing modules. A registry is specifed as follows: Copy code Copied! [modulePrefix=]hostname[:port][/repoPrefix][+insecure] The optional modulePrefix specifes that all modules with a path that has the given prefix will use the associated registry. If there are multiple registries with a prefix, the longest matching prefix wins. It\u0026rsquo;s an error for there to be multiple entries with the same prefix. The hostname holds the OCI registry host (in square brackets if it\u0026rsquo;s an IPv6 address), with an optional numeric TCP port. Each module is stored inside its own repository in the registry which is named after the module path. The repoPrefix holds a prefix to be added to the repository name. That is, all repositories in the registry will be of the form repoPrefix/modulePath. If there\u0026rsquo;s a +insecure suffix it specifies that an insecure HTTP connection should be used to this registry. The default is to use a secure HTTPS connection except for localhost addresses. For symmetry, it\u0026rsquo;s also possible to use +secure to force an HTTPS connection even on localhost connections. For example, given: Copy code Copied! CUE_REGISTRY=public-registry.example,github.com/acmecorp=registry.acme.example:6000/modules all modules, such as github.com/foo/bar will be fetched from public-registry.example with the exception of modules with the prefix github.com/acmecorp/, such as github.com/acmecorp/somemodule which will be fetched from the modules/github.com/acmecorp/somemodule repository in the host registry.acme.example at port 6000. cue.mod/module.cue files A module is defined by a cue.mod directory in its root containing a module.cue CUE file. Copy code Copied! // module indicates the module\u0026#39;s path. module!: #Module // version indicates the language version used by the code in this module // - the minimum version of CUE required to evaluate the code in this // module. When a later version of CUE is evaluating code in this module, // this will be used to choose version-specific behavior. If an earlier // version of CUE is used, an error will be given. language?: version?: #Semver // source holds information about the source of the files within the // module. This field is mandatory at publish time. source?: #Source // description describes the purpose of this module. description?: string // deps holds dependency information for modules, keyed by module path. deps?: [#Module]: #Dep // custom holds arbitrary data intended for use by third-party tools. // Each field at the top level represents a tooling namespace, // conventionally a module or domain name. Data migrated from legacy // module.cue files is placed in the \u0026#34;legacy\u0026#34; namespace. custom?: [#Module | \u0026#34;legacy\u0026#34;]: [_]: _ #Dep: { // v indicates the minimum required version of the module. v!: #Semver // default indicates this module is used as a default in case more // than one major version is specified for the same module path. // Imports must specify the exact major version for a module path if // there is more than one major version for that path and default is // not set for exactly one of them. default?: bool } // #Module constrains a module path. The major version indicator is // optional, but should always be present in a normalized module.cue //",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "a13025903757ccdf9b12f578d922dbae_3",
        "title": "CUE Modules",
        "link": "/docs/reference/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eModules are how CUE manages dependencies.\nThis document is a detailed reference manual for CUE\u0026rsquo;s module system.\nCUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules\nand this document has substantial parts that have been taken\ndirectly from the \u003ca href=\"https://go.dev/ref/mod\"\u003eGo modules reference\u003c/a\u003e.\nThanks very much to Russ Cox and the Go team for their\namazing work there.\u003c/p\u003e\n\u003cp\u003eThis document largely supercedes the\n\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eprior modules documentation\u003c/a\u003e\nalthough, as a transitionary measure, the CUE tool still supports\nthe import of packages present in the \u003ccode\u003ecue.mod/pkg\u003c/code\u003e, \u003ccode\u003ecue.mod/usr\u003c/code\u003e and\n\u003ccode\u003ecue.mod/gen\u003c/code\u003e directories. This only applies to the main module, and if\nthere is any ambiguity with respect to regular module dependencies an\n\u0026ldquo;ambiguous import\u0026rdquo; error will be reported.\u003c/p\u003e",
        "content": "file. #Module: =~#\u0026#34;^[^@]+(@v(0|[1-9]\\d*))$\u0026#34;# // #Semver constrains a semantic version. This regular expression is taken // from https://semver.org/spec/v2.0.0.html #Semver: =~#\u0026#34;^v(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\u0026#34;# // #Source describes a source of truth for a module\u0026#39;s content. #Source: { // kind specifies the kind of source. // // The special value \u0026#34;self\u0026#34; signifies a module is stand-alone, associated // with no particular source. The module\u0026#39;s file list is determined from // the contents of the directory (and its subdirectories) that contains // the cue.mod directory. // // See https://cuelang.org/docs/reference/modules/#determining-zip-file-contents // for details on all the possible values for kind, and how they relate // to determining the list of files in a module. kind!: \u0026#34;self\u0026#34; | \u0026#34;git\u0026#34; } For example: Copy code Copied! language: version: \u0026#34;v0.4.3\u0026#34; module: \u0026#34;foo.example/my/thing@v1\u0026#34; deps: { \u0026#34;foo.example/other/thing@v1\u0026#34;: v: \u0026#34;v1.0.2\u0026#34; \u0026#34;foo.example/new/thing@v2\u0026#34;: v: \u0026#34;v2.3.4\u0026#34; } The module.cue file is designed to be human readable and machine writable. The cue command will provide several subcommands that manipulate cue.mod/module.cue files. For now, the only one is cue mod tidy which will fetch dependencies and canonicalize the module.cue file to reflect all the most recent versions. A cue.mod/module.cue file is required for all modules. Minimal version selection (MVS) CUE uses an algorithm called Minimal version selection (MVS) to select a set of module versions to use when building packages. MVS is described in detail in Minimal Version Selection by Russ Cox. Conceptually, MVS operates on a directed graph of modules, specified with module.cue files. Each vertex in the graph represents a module version. Each edge represents a minimum required version of a dependency, specified with an entry in the deps field. MVS produces the build list as output, the list of module versions used for an evaluation. MVS starts at the main modules (special vertices in the graph that have no version) and traverses the graph, tracking the highest required version of each module. At the end of the traversal, the highest required versions comprise the build list: they are the minimum versions that satisfy all requirements. Unlike other dependency management systems, the build list is not saved in a \u0026ldquo;lock\u0026rdquo; file. MVS is deterministic, and the build list doesn\u0026rsquo;t change when new versions of dependencies are released, so MVS is used to compute it at the beginning of every module-aware command. Module version graph with visited versions highlighted Consider the example in this diagram. The main module requires module A at version 1.2 or higher and module B at version 1.2 or higher. A 1.2 and B 1.2 require C 1.3 and C 1.4, respectively. C 1.3 and C 1.4 both require D 1.2. MVS visits and loads the cue.mod/module.cue file for each of the module versions highlighted in blue. At the end of the graph traversal, MVS returns a build list containing the bolded versions: A 1.2, B 1.2, C 1.4, and D 1.2. Note that higher versions of B and D are available but MVS does not select them, since nothing requires them. Module storage format Modules are stored in a registry using a standard manifest + blob format. There is rarely any need to interact directly with these artifacts, since the cue command creates, downloads, and extracts them automatically from registries. However, it\u0026rsquo;s still useful to know about these files to understand cross-platform compatibility constraints. A module is stored in a registry with a top level manifest with media type application/vnd.oci.image.manifest.v1+json and artifact type application/vnd.cue.module.v1+json, that points to two blobs. The first blob (also known as a \u0026ldquo;layer 0\u0026rdquo; although there\u0026rsquo;s actually no layering going on here) has media type application/zip and holds the full contents of the module. The second blob, layer 1, has media type application/vnd.cue.modulefile.v1 and stores an exact copy of the contents of the cue.mod/module.cue file from the zip file. The latter enables fast access to the dependency information without the need to download the entire module archive. Determining zip file contents The source field in module.cue is used by cue mod publish to determine which files to include in a module zip. It is required when publishing a module. The source.kind field specifies the kind of source. The supported kinds are listed below. source: kind: \u0026quot;self\u0026quot; determines the module file list from the module root directory tree on disk. source: kind: \u0026quot;git\u0026quot; requires that the module root directory be under the control of a Git VCS repository. The git ls-files command is then used to determine the module file list within the module root directory. When publishing a module that is not in the repository root directory, if the module does not have a file named LICENSE in its root directory, cue mod publish will include the file named LICENSE from the repository root directory at the module root. Every entry in the module file list must be \u0026ldquo;clean\u0026rdquo; with respect to the current commit. The initial list of files determined by the source is then filtered according to file path and size constraints. File path and size constraints There are a number of restrictions on the content of module zip files. These constraints ensure that zip files can be extracted safely and consistently on a wide range of platforms. A module zip file may be at most 500 MiB in size. The total uncompressed size of its files is also limited to 500 MiB. module.cue files are limited to 16 MiB. LICENSE files are also limited to 16 MiB. These limits exist to mitigate denial of service attacks on users, proxies, and other parts of the module ecosystem. Repositories that contain more than 500 MiB of files in a module directory tree should tag module versions at commits that only include files needed to build the module\u0026rsquo;s packages; videos, models, and other large assets are usually not needed for builds. File modes, timestamps, and other metadata are ignored. Empty directories (entries with paths ending with a slash) may be included in module zip files but are not extracted. The cue command does not include empty directories in zip files it creates. Symbolic links and other irregular files are",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "a13025903757ccdf9b12f578d922dbae_4",
        "title": "CUE Modules",
        "link": "/docs/reference/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eModules are how CUE manages dependencies.\nThis document is a detailed reference manual for CUE\u0026rsquo;s module system.\nCUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules\nand this document has substantial parts that have been taken\ndirectly from the \u003ca href=\"https://go.dev/ref/mod\"\u003eGo modules reference\u003c/a\u003e.\nThanks very much to Russ Cox and the Go team for their\namazing work there.\u003c/p\u003e\n\u003cp\u003eThis document largely supercedes the\n\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eprior modules documentation\u003c/a\u003e\nalthough, as a transitionary measure, the CUE tool still supports\nthe import of packages present in the \u003ccode\u003ecue.mod/pkg\u003c/code\u003e, \u003ccode\u003ecue.mod/usr\u003c/code\u003e and\n\u003ccode\u003ecue.mod/gen\u003c/code\u003e directories. This only applies to the main module, and if\nthere is any ambiguity with respect to regular module dependencies an\n\u0026ldquo;ambiguous import\u0026rdquo; error will be reported.\u003c/p\u003e",
        "content": "ignored when creating zip files, since they aren\u0026rsquo;t portable across operating systems and file systems, and there\u0026rsquo;s no portable way to represent them in the zip file format. Files within directories containing cue.mod directories, other than the module root directory and the cue.mod directory itself, are ignored when creating zip files, since they are not part of the module. CUE ignores subdirectories containing cue.mod directories when extracting zip files. No two files within a zip file may have paths equal under Unicode case-folding (see strings.EqualFold). This ensures that zip files can be extracted on case-insensitive file systems without collisions. A cue.mod/module.cue file must appear in the top-level directory. If present, it must have the name cue.mod/module.cue (all lowercase). Directories named cue.mod are not allowed in any other directory. File and directory names within a module may consist of Unicode letters, ASCII digits, the ASCII space character (U+0020), and the ASCII punctuation characters !#$%\u0026amp;()+,-.=@[]^_{}~. Note that package paths may not contain all these characters. See module.CheckFilePath and module.CheckImportPath for the differences. A file or directory name up to the first dot must not be a reserved file name on Windows, regardless of case (CON, com1, NuL, and so on). Module caching By default, the cue command caches downloaded modules in the local filesystem. It uses the local user configuration directory by default, but that can be changed by setting $CUE_CACHE_DIR, which is documented under cue help environment. Authorization For custom OCI registries, CUE understands the usual conventions for authorization: specifically the usual way to configure registry authorization information for custom OCI registries is by setting them up in the $HOME/.docker/config.json file. You can use docker login to do this or edit the file directly. The CUE command knows how to read auth tokens from the $HOME/.docker/config.json, including running helper commands to fetch them from secure storage. For organizations that don\u0026rsquo;t allow the use of docker, podman login allows using the --compat-auth-file $HOME/.docker/config.json flag to generate a docker compatible json file. Glossary build constraint: A condition that determines whether a CUE source file is used when compiling a package. Build constraints are expressed with file-level @if(name) annotations. build list: The list of module versions that will be used for a CUE command such as cue export, or cue vet. The build list is determined from the main module\u0026rsquo;s cue.mod/module.cue file and cue.mod/module.cue files in transitively required modules using minimal version selection. The build list contains versions for all modules in the module graph, not just those relevant to a specific command. canonical version: A correctly formatted version without a build metadata suffix other than +incompatible. For example, v1.2.3 is a canonical version, but v1.2.3+meta is not. current module: Synonym for main module. cue.mod/module.cue file: The file that defines a module\u0026rsquo;s path, requirements, and other metadata. Appears in the module\u0026rsquo;s root directory. See the section on cue.mod/module.cue files. import path: A string used to import a package in a CUE source file. Synonymous with package path. main module: The module in which the cue command is invoked. The main module is defined by a cue.mod/module.cue file in the current directory or a parent directory. See Modules, packages, and versions. major version: The first number in a semantic version (1 in v1.2.3). In a release with incompatible changes, the major version must be incremented, and the minor and patch versions must be set to 0. Semantic versions with major version 0 are considered unstable. major version suffix: A module path suffix that matches the major version number. For example, @v2 in foo.example/mod@v2. See the section on Major version suffixes. minimal version selection (MVS): The algorithm used to determine the versions of all modules that will be used in a build. See the section on Minimal version selection for details. minor version: The second number in a semantic version (2 in v1.2.3). In a release with new, backwards compatible functionality, the minor version must be incremented, and the patch version must be set to 0. module: A collection of packages that are released, versioned, and distributed together. module cache: A local directory storing downloaded modules, located in $CUE_CACHE_DIR. See Module cache. module graph: The directed graph of module requirements, rooted at the main module. Each vertex in the graph is a module; each edge is a version from an entry in the deps field in a cue.mod/module.cue file. module path: A path that identifies a module and acts as a prefix for package import paths within the module. For example, \u0026quot;cuelang.org/x/foo\u0026quot;. module root directory: The directory that contains the cue.mod/module.cue file that defines a module. package: A collection of source files, usually in the same directory, that are evaluated together. See the Packages section in the CUE Language Specification. package path: The path that uniquely identifies a package. A package path is a module path joined with a subdirectory within the module. For example \u0026quot;cuelang.org/x/foo/html\u0026quot; is the package path for the package in the module \u0026quot;cuelang.org/x/foo\u0026quot; in the \u0026quot;html\u0026quot; subdirectory. Synonym of import path. patch version: The third number in a semantic version (3 in v1.2.3). In a release with no changes to the module\u0026rsquo;s public interface, the patch version must be incremented. pre-release version: A version with a dash followed by a series of dot-separated identifiers immediately following the patch version, for example, v1.2.3-beta4. Pre-release versions are considered unstable and are not assumed to be compatible with other versions. A pre-release version sorts before the corresponding release version: v1.2.3-pre comes before v1.2.3. See also release version. release version: A version without a pre-release suffix. For example, v1.2.3, not v1.2.3-pre. See also pre-release version. repository root path: The portion of a module path that corresponds to a version control repository\u0026rsquo;s root directory. See Module paths. selected version: The version of a given module chosen by minimal version selection. The selected version is the highest version for the module\u0026rsquo;s path found in the module graph. version: An identifier for an immutable snapshot of a module, written as the letter v followed by a semantic version. See",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "a13025903757ccdf9b12f578d922dbae_5",
        "title": "CUE Modules",
        "link": "/docs/reference/modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eModules are how CUE manages dependencies.\nThis document is a detailed reference manual for CUE\u0026rsquo;s module system.\nCUE\u0026rsquo;s modules support has a lot in common with Go\u0026rsquo;s modules\nand this document has substantial parts that have been taken\ndirectly from the \u003ca href=\"https://go.dev/ref/mod\"\u003eGo modules reference\u003c/a\u003e.\nThanks very much to Russ Cox and the Go team for their\namazing work there.\u003c/p\u003e\n\u003cp\u003eThis document largely supercedes the\n\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eprior modules documentation\u003c/a\u003e\nalthough, as a transitionary measure, the CUE tool still supports\nthe import of packages present in the \u003ccode\u003ecue.mod/pkg\u003c/code\u003e, \u003ccode\u003ecue.mod/usr\u003c/code\u003e and\n\u003ccode\u003ecue.mod/gen\u003c/code\u003e directories. This only applies to the main module, and if\nthere is any ambiguity with respect to regular module dependencies an\n\u0026ldquo;ambiguous import\u0026rdquo; error will be reported.\u003c/p\u003e",
        "content": "the section on Versions. Related content Tutorial: Working with a custom module registry",
        "breadcrumb": ["Documentation","References"],
        "contentType": "References",
        "tags": ["modules"],
        "authors": ["rogpeppe"]
    },
    {
        "objectID": "c23108ca57cd670e00c33fc165a6e85d_1",
        "title": "CUE Playground",
        "link": "/play/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "",
        "content": "",
        "breadcrumb": [],
        "contentType": "CUE",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "702bffdf2f50bb1b8204ebd4b76f2071_1",
        "title": "Data Validation use case",
        "link": "/docs/concept/data-validation-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBy far the most straightforward approach to specify data is in plain\nJSON or YAML files.\nEvery value can be looked up right where it needs to be defined.\nBut even at small scales, one will soon have to deal with\nconsistency issues.\u003c/p\u003e\n\u003cp\u003eData validation tools allow verifying the consistency of such data\nbased on a schema.\u003c/p\u003e",
        "content": "By far the most straightforward approach to specify data is in plain JSON or YAML files. Every value can be looked up right where it needs to be defined. But even at small scales, one will soon have to deal with consistency issues. Data validation tools allow verifying the consistency of such data based on a schema. Core issues addressed by CUE Client-side validation There are not too many handy tools to verify plain data files. Often, validation is relied upon to be done server side. If it is done client side, it either relies on rather verbose schema definitions or using custom tools that verify schema for a specific domain. The cue command line tool provides a fairly straightforward way to define schema and verify them against a collection of data files. Given these two files, the cue vet command can verify that the values in ranges.yaml are correct by just mentioning the two files on the command line. Copied! check.cue Copy code Copied! min?: *0 | number // 0 if undefined // must be strictly greater than min if defined. max?: number \u0026amp; \u0026gt;min Copied! ranges.yaml Copy code Copied! min: 5 max: 10 --- min: 10 max: 5 TERMINAL Copy code Copied! $ cue vet -c ranges.yaml check.cue max: invalid value 5 (out of bound \u0026gt;10): ./check.cue:4:16 ./ranges.yaml:5:6 Validating document-oriented databases Document-oriented databases like Mongo and many others are characterized by having flexible schema. Some of them, like Mongo, optionally allow schema definitions, often in the form of JSON schema. CUE constraints can be used to verify document-oriented databases. Its default mechanism and expression syntax allow for filling in missing values for an older version of a schema. More importantly, CUE\u0026rsquo;s order independence allows \u0026ldquo;patch\u0026rdquo; specifications to be separated from the main schema definition. CUE can take care of merging these and report if there are any inconsistencies in the definitions, even before they are applied to a concrete case. CUE can be applied directly on the data in code using its API, but it can also be used to compute JSON schemas from CUE definitions. (See cuelang.org/go/encoding/openapi.) If a document-oriented database natively supports JSON schema it will likely have its benefits to do so. Using CUE to generate the schema has several advantages over doing so directly: CUE is far less verbose. CUE can extract base definitions from other sources, like Go and Protobuf. It allows annotating validation code in these other sources (e.g. field tags for Go, options for Protobuf). CUE\u0026rsquo;s ability to merge, validate, and normalize configurations, allows separation of concerns between main schema and patches for older version, for instance. CUE can morph definitions in several forms, such as the structural OpenAPI needed for Kubernetes\u0026rsquo; CRDs as of version 1.15. Migration path As discussed in \u0026ldquo;Be useful at all scales\u0026rdquo;, there is a high cost to changing languages as one reaches the limits with a certain approach. CUE adds the benefit of type checking to plain data files. Once in use, it allows the same, familiar tools to move to something more structured as this approach reaches its limits. CUE provides automated rewrite tools, such as cue import and cue trim to aid in such migration. Comparisons JSON Schema The closest approach to validating JSON and YAML with schema is the use of JSON schema and accompanying tools. Compared to CUE, JSON schema does not have a unified type and value model. This makes the ability to use JSON schema for boilerplate reduction minimal. As it is specified in JSON itself (it is not a DSL) it can be quite verbose. Overall CUE is a more concise, yet more powerful schema language. For instance, in CUE one can specify that two fields need to be identical to one another: Copy code Copied! point: { x: number y: number } diagonal: point \u0026amp; { x: y y: x } Such a thing is not possible in JSON schema (or most configuration languages for that matter). More on JSON Schema and its subset, OpenAPI, in Schema Definition.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "e83c2b69d6958fe6b050f18ca7fbc8de_1",
        "title": "Disallowing specific field names",
        "link": "/docs/howto/disallow-a-specific-field-name/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to disallow specific data fields inside an otherwise open\nschema.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to disallow specific data fields inside an otherwise open schema. Copied! file.cue Copy code Copied! package example // This schema is open because we do not know // which additional fields might be present. name!: string address!: string // We must not allow our data model to contain // people\u0026#39;s ages, so we disallow the age field. age?: _|_ Copied! data.yaml Copy code Copied! name: Charlie Cartwright address: Ripon, North Yorkshire species: cat age: 15.5 TERMINAL Copy code Copied! $ cue vet -c . data.yaml explicit error (_|_ literal) in source: ./file.cue:10:7 Another common way to prevent the existence of unwanted data fields is to rely on the closedness property that comes from the use of definitions or the close built-in function. However, in situations such as the example above, closedness cannot be used to disallow specific fields because the schema author cannot specify each and every acceptable field - and therefore the schema must be left open. The technique demonstrated here may be superseded by the error() builtin function proposed in issue #943. This function is not yet available, but would allow for custom error messages instead of the explicit error (_|_ literal) in source shown above. Related content The CUE Tour: Definitions Glossary: the close built-in function Issue #943 contains details of the proposed error() builtin function",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    {
        "objectID": "4cdd37113783e47641dd300543c94e1b_1",
        "title": "Documentation",
        "link": "/docs/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch1 id=\"welcome-to-cue\"\u003e\n    \u003ca href=\"#welcome-to-cue\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWelcome to CUE!\u003c/h1\u003e\n\u003cp\u003eCUE is an\n\u003cdfn title='License: \"Apache-2.0\", DCO: true, CLA: false'\u003eopen-source\u003c/dfn\u003e\ndata validation language with its roots in logic programming.\nIt combines succinct yet clear syntax with powerful, flexible constraints that\nenable data, schema, and policy constraints to coexist seamlessly:\u003c/p\u003e",
        "content": "Welcome to CUE! CUE is an open-source data validation language with its roots in logic programming. It combines succinct yet clear syntax with powerful, flexible constraints that enable data, schema, and policy constraints to coexist seamlessly: Copied! example.cue Copy code Copied! area: length * width area: \u0026lt;100 // Must be less than 100. width: 33.3 \u0026amp; \u0026gt;10 // Must be greater than 10. length: 5 \u0026amp; !=width // Reject square areas. TERMINAL Copy code Copied! $ cue vet -c example.cue area: invalid value 166.5 (out of bound \u0026lt;100): ./example.cue:2:9 ./example.cue:1:9 CUE supports and simplifies a wide variety of applications, such as data validation, configuration, querying, and code generation, with its underlying inference engine enabling data validation in code, and flexible generation pipelines. How to use this documentation Browse through the different documentation sections, or use the search box in the top-right corner of each page. Here\u0026rsquo;s what you\u0026rsquo;ll find in each section: A great place to start Take a trip through what\u0026rsquo;s possible with CUE, and learn how to install it on your computer Introduction Introduction New to CUE? See CUE\u0026rsquo;s features and syntax up close in this tour that\u0026rsquo;s suitable for newcomers to the language Tour Tour JSON, YAML, Go, and more Learn how CUE integrates with a wide ecosystem of formats and tools Integrations Integrations Techniques and tools Learn about different language and tooling features through self-contained lessons that you can run on your own computer Tutorials Tutorials Directions to specific goals Follow practical steps guiding you through completing tasks with CUE How-to Guides How-to Guides Theory and foundations Discover the approaches that CUE makes possible by exploring the ideas and theory that drive the language Concept Guides Concept Guides References Read the CUE language specification, a glossary of terms, the project\u0026rsquo;s code of conduct, and other core documents References References",
        "breadcrumb": [],
        "contentType": "Documentation",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "7e6f9d6eb308d5b2792fa51019f2b408_1",
        "title": "Embedding files in a CUE evaluation",
        "link": "/docs/howto/embed-files-in-cue-evaluation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eUsers frequently need to load JSON, YAML, or other types of files into their CUE code.\nBecause CUE\u0026rsquo;s \u003ccode\u003eimport\u003c/code\u003e declarations only allow references to CUE packages,\nsome workflows resort to using the tooling layer\n(\u003ca href=\"/docs/reference/command/cue-help-cmd/\"\u003e\u003ccode\u003ecue cmd\u003c/code\u003e\u003c/a\u003e)\nto load non-CUE files. This can complicate the process if the tooling layer\u0026rsquo;s\nadvanced features aren\u0026rsquo;t otherwise needed.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e@embed()\u003c/code\u003e attribute is designed to simplify workflows that require data to\nbe loaded at evaluation time, and is available by default from version\n\u003ccode\u003ev0.12.0\u003c/code\u003e of CUE onwards. This guide demonstrates the following version:\u003c/p\u003e\n\u003cdiv class=\"code-block code-block--heading code-block--terminal\"data-copy\u003e\u003cdiv class=\"code-block__heading\"\u003e\n            \u003cspan class=\"code-block__tab\"\u003eTERMINAL\u003c/span\u003e\n        \u003c/div\u003e\u003cdiv class=\"code-block__highlight\"\u003e\u003cbutton class=\"code-block__copy\" type=\"button\" data-copy-button data-copy-type=\"code\" data-copy-value=\"Y3VlIHZlcnNpb24=\"\u003e\n                \u003cspan\u003eCopy code\u003c/span\u003e\n                \u003cspan class=\"code-block__message is-hidden\" data-copy-message aria-hidden=\"true\"\u003e\n                    Copied!\n                \u003c/span\u003e\n            \u003c/button\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ cue version\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecue version v0.13.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\u003c/div\u003e",
        "content": "Users frequently need to load JSON, YAML, or other types of files into their CUE code. Because CUE\u0026rsquo;s import declarations only allow references to CUE packages, some workflows resort to using the tooling layer (cue cmd) to load non-CUE files. This can complicate the process if the tooling layer\u0026rsquo;s advanced features aren\u0026rsquo;t otherwise needed. The @embed() attribute is designed to simplify workflows that require data to be loaded at evaluation time, and is available by default from version v0.12.0 of CUE onwards. This guide demonstrates the following version: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Embedding files in an evaluation 1Initialize a CUE module, or use an existing module if that\u0026rsquo;s appropriate in your situation: TERMINAL Copy code Copied! $ cue mod init 2Include the @extern(embed) directive at the top of each CUE file that uses the @embed() attribute. Use @embed() to embed either a single named file, or a glob identifying multiple files: Copied! example.cue Copy code Copied! @extern(embed) package p oneFile: _ @embed(file=README.md,type=text) manyFiles: _ @embed(glob=*.json) Copied! a.json Copied! b.json Copied! c.json Copied! README.md Copy code Copied! { \u0026#34;aField\u0026#34;: \u0026#34;a value\u0026#34; } Copy code Copied! { \u0026#34;aList\u0026#34;: [ 1, 2, 3 ] } Copy code Copied! { \u0026#34;anObject\u0026#34;: { \u0026#34;foo\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;c\u0026#34; } } Copy code Copied! # How to use this project ## Installation Fetch the latest release from the official site, and unpack it in your home directory. Next ... By default, files are decoded using the encoding implied by their filename extension, and it\u0026rsquo;s an error if the extension is not known. Files or globs with an unknown filename extension can be loaded by adding the type=\u0026lt;filetype\u0026gt; parameter, where \u0026lt;filetype\u0026gt; can be any type described in cue help filetypes. 3Export the resulting configuration: TERMINAL Copy code Copied! $ cue export --out yaml oneFile: | # How to use this project ## Installation Fetch the latest release from the official site, and unpack it in your home directory. Next ... manyFiles: a.json: aField: a value b.json: aList: - 1 - 2 - 3 c.json: anObject: foo: a bar: b baz: c Related content Reference: cue help embed Reference: cue help filetypes",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4c1c639b4e9da306eb3eb4069dd56c91_1",
        "title": "Ensuring a list's values are present in another list",
        "link": "/docs/howto/ensure-list-values-present-in-another-list/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to make sure that a list of concrete, simple values only\ncontains elements that are \u003cem\u003ealso\u003c/em\u003e present in another list.\nIn other words, how to ensure that one list is a \u0026ldquo;subset\u0026rdquo; of another list (even\nthough a list isn\u0026rsquo;t a set, strictly speaking).\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to make sure that a list of concrete, simple values only contains elements that are also present in another list. In other words, how to ensure that one list is a \u0026ldquo;subset\u0026rdquo; of another list (even though a list isn\u0026rsquo;t a set, strictly speaking). Copied! file.cue Copy code Copied! package example _X: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] A: [\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;] // A must contain only values in _X. A: [...or(_X)] B: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;E\u0026#34;] // B must be a subset of _X. B: [...or(_X)] TERMINAL Copy code Copied! $ cue vet -c B.3: 3 errors in empty disjunction: B.3: conflicting values \u0026#34;a\u0026#34; and \u0026#34;E\u0026#34;: ./file.cue:3:6 ./file.cue:9:20 B.3: conflicting values \u0026#34;b\u0026#34; and \u0026#34;E\u0026#34;: ./file.cue:3:11 ./file.cue:9:20 B.3: conflicting values \u0026#34;c\u0026#34; and \u0026#34;E\u0026#34;: ./file.cue:3:16 ./file.cue:9:20 This guide shows some lists of concrete and simple values being validated against another list. The technique it demonstrates can also be used to validate incomplete (non-concrete) and composite (struct and list) values, but the rules around its use are nuanced and evolving. Issue #2583 tracks some open questions about comparability in CUE that are worth considering before using this technique to validate more complex values. Related content Issue #2583 Reference: The CUE Language Specification: Comparison operators \u0026ndash; CUE\u0026rsquo;s comparability rules",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "52bd0e7f828ff7c01afa6c64525b06d7_1",
        "title": "Ensuring lists have no duplicate items",
        "link": "/docs/howto/list-no-duplicates/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn CUE, you often will work with lists of all sorts of values. To ensure a list\nhas no duplicate items, use\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#UniqueItems\"\u003elist.UniqueItems\u003c/a\u003e.\u003c/p\u003e",
        "content": "In CUE, you often will work with lists of all sorts of values. To ensure a list has no duplicate items, use list.UniqueItems. Strings Copy code Copied! import \u0026#34;list\u0026#34; items: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;] items: list.UniqueItems Integers Copy code Copied! import \u0026#34;list\u0026#34; items: [1, 2, 3, 1] items: list.UniqueItems Note that this approach does not work correctly on non-integer values. See issue #2192 for details. Structs A common issue is we have a list of structs, each with some key that must be unique across all items in the list. To ensure a list of structs has no duplicate keys, one common approach is to guarantee that the list has no duplicate items by constructing the list from a map. Copy code Copied! _items: { joe: age: 30 alice: age: 35 } _items: [name=string]: \u0026#34;name\u0026#34;: name items: [ for item in _items { item }, ] If the list must be constrained directly, you can write an auxiliary field that creates a mapping from the keys Copy code Copied! items: [ { name: \u0026#34;joe\u0026#34; age: 30 }, { name: \u0026#34;alice\u0026#34; age: 35 }, { name: \u0026#34;joe\u0026#34; age: 31 }, ] _itemsCheck: { for i, item in items { (item.name): i } } If the key is specified twice, there will be a conflict in _itemsCheck. Ensuring multiple keys to have no duplicates If there are multiple keys that together must be unique, a similar approach can be used, using json.Marshal to form a composite string key from the keys. Here, for example, the combination of name and dateOfBirth must be unique: Copy code Copied! import \u0026#34;encoding/json\u0026#34; items: [ { name: \u0026#34;joe\u0026#34; dateOfBirth: \u0026#34;1983-10-21\u0026#34; country: \u0026#34;US\u0026#34; }, { name: \u0026#34;alice\u0026#34; dateOfBirth: \u0026#34;1987-10-15\u0026#34; country: \u0026#34;DE\u0026#34; }, { name: \u0026#34;joe\u0026#34; dateOfBirth: \u0026#34;2010-02-05\u0026#34; country: \u0026#34;UK\u0026#34; }, { name: \u0026#34;alice\u0026#34; dateOfBirth: \u0026#34;1987-10-15\u0026#34; country: \u0026#34;BE\u0026#34; }, ] _itemsCheck: { for i, item in items { (json.Marshal([item.name, item.dateOfBirth])): i } }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language"],
        "authors": ""
    },
    
            {
        "objectID": "58d3dd5656df9f80394b4f3a38f187d0_1",
        "title": "Exporting fields whose names are not valid identifiers",
        "link": "/docs/howto/export-fields-whose-names-are-not-valid-identifiers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eSome fields have names that are not valid\n\u003ca href=\"/docs/reference/spec/#identifiers\"\u003eCUE identifiers\u003c/a\u003e.\nThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to export these fields using \u003ccode\u003ecue export -e\u003c/code\u003e.\u003c/p\u003e",
        "content": "Some fields have names that are not valid CUE identifiers. This Commented CUE demonstrates how to export these fields using cue export -e. Copied! data.yml Copy code Copied! # data.yml contains a field we want to export with # the \u0026#34;cue export\u0026#34; command\u0026#39;s \u0026#34;-e\u0026#34; parameter \u0026#34;top level field\u0026#34;: a: [ 1, 2, 3 ] TERMINAL Copy code Copied! $ cue export -l input: data.yml -e \u0026#39;input[\u0026#34;top level field\u0026#34;]\u0026#39; { \u0026#34;a\u0026#34;: [ 1, 2, 3 ] } Related content How-to Guide: Refering to fields whose names are not valid identifiers",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4c325e212f926a321ba919c4b6b7aa2c_1",
        "title": "Fetching JSON data over HTTP",
        "link": "/docs/howto/fetch-json-data-http/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use a CUE workflow command to fetch some JSON over HTTP.\u003c/p\u003e\n\u003cp\u003eIt is converted from its JSON representation into data,\nwhich is then used by the workflow command.\u003c/p\u003e",
        "content": "This guide demonstrates how to use a CUE workflow command to fetch some JSON over HTTP. It is converted from its JSON representation into data, which is then used by the workflow command. Copied! a_tool.cue Copy code Copied! package example import ( \u0026#34;tool/http\u0026#34; \u0026#34;tool/cli\u0026#34; \u0026#34;encoding/json\u0026#34; ) command: info: { fetch: http.Get \u0026amp; { url: \u0026#34;https://proxy.golang.org/cached-only/cuelang.org/go/@v/v0.8.2.info\u0026#34; } display: cli.Print \u0026amp; { _data: #info \u0026amp; json.Unmarshal(fetch.response.body) text: \u0026#34;CUE version \\(_data.Version) was released with commit hash \\(_data.Origin.Hash)\u0026#34; } } // The data received is validated against this schema. This is good practice, // but is not required before using the data. #info: { Version!: string Origin?: { Hash!: string ... } ... } TERMINAL Copy code Copied! $ cue cmd info CUE version v0.8.2 was released with commit hash 596c99191ad1eb7c39d547e59bc7085751d7952b Related content Reference: cue help commands \u0026ndash; CUE workflow commands Go API: tool/http \u0026ndash; make HTTP requests in workflow commands Go API: encoding/json \u0026ndash; convert data to and from its JSON representation Go API: tool/cli \u0026ndash; interact with the user\u0026rsquo;s terminal in workflow commands",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["workflow command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4a3b0cf5263bea555490697c7a5888ad_1",
        "title": "Generating CUE from a Go dependency",
        "link": "/docs/howto/generate-cue-from-go-dependency/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to generate CUE from Go types defined in some\ndependency of a Go module.\u003c/p\u003e",
        "content": "This guide demonstrates how to generate CUE from Go types defined in some dependency of a Go module. Initialize Go and CUE modules 1Create a Go module, or use an existing one if that\u0026rsquo;s more suitable for your situation: TERMINAL Copy code Copied! $ go mod init go.example ... 2Create a CUE module if you don\u0026rsquo;t already have one: TERMINAL Copy code Copied! $ cue mod init cue.example Declare a Go dependency If your Go doesn\u0026rsquo;t already depend on the module containing the Go types you\u0026rsquo;re interested in, add it as a dependency. 3Create a Go file to signal the required package to the go command. Our example depends on a Kubernetes package: Copied! deps.go Copy code Copied! package deps import _ \u0026#34;k8s.io/api/apps/v1\u0026#34; 4Add a dependency on a specific version of the target Go package, and tidy the main module: TERMINAL Copy code Copied! $ go get k8s.io/api/apps/v1@v0.23.4 # \u0026#34;@latest\u0026#34; would also work. ... $ go mod tidy ... Generate CUE from Go 5Use the cue command to generate CUE from the target Go package: TERMINAL Copy code Copied! $ cue get go k8s.io/api/apps/v1 6Inspect the CUE packages generated in cue.mod/gen: TERMINAL Copy code Copied! $ tree -d cue.mod/gen cue.mod/gen  k8s.io  api   apps    v1   core   v1  apimachinery  pkg  api ... More CUE packages are generated than just the target. These are dependencies of the target package. Test the generated CUE 7Use the generated code in a CUE package: Copied! example.cue Copy code Copied! package example import ( core \u0026#34;k8s.io/api/core/v1\u0026#34; apps \u0026#34;k8s.io/api/apps/v1\u0026#34; ) service: [string]: core.#Service deployment: [string]: apps.#Deployment daemonSet: [string]: apps.#DaemonSet statefulSet: [string]: apps.#StatefulSet 8Export an empty configuration to confirm that everything works: TERMINAL Copy code Copied! $ cue export --out yaml service: {} deployment: {} daemonSet: {} statefulSet: {} Related content Issue #2865 tracks the plans for CUE to support finding well-known types (such as the Kubernetes example used above) at a well-known location, without having to import them manually. How-to Guide: Generating CUE from local Go code",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command","encodings"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "2a3d3f69806c20a50377af0f59393c9d_1",
        "title": "Generating CUE from local Go code",
        "link": "/docs/howto/generate-cue-from-local-go/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to generate CUE from types defined in a local Go\nmain package, placing the CUE in the same directory as the Go code.\u003c/p\u003e",
        "content": "This guide demonstrates how to generate CUE from types defined in a local Go main package, placing the CUE in the same directory as the Go code. Initialize Go and CUE modules 1Create a Go module, or use an existing one if that\u0026rsquo;s more suitable for your situation: TERMINAL Copy code Copied! $ go mod init an.example ... 2Create a CUE module if you don\u0026rsquo;t already have one: TERMINAL Copy code Copied! $ cue mod init an.example This module will hold the CUE generated from your local Go types. Fetch or create your Go types 3Place Go code in the current working directory that contains the types you\u0026rsquo;re interested in. If you are following this guide by working inside an existing Go package then the code and types will already be in place. This guide uses the following example: a simple program that loads a JSON-encoded config from its stdin. You don\u0026rsquo;t need to use this example in any way. You should use your own Go code and types. Copied! main.go Copy code Copied! package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) type Config struct { Vals []Val `json:\u0026#34;vals\u0026#34;` Level int `json:\u0026#34;level\u0026#34;` } type Val struct { Name string `json:\u0026#34;name\u0026#34;` Value string `json:\u0026#34;value\u0026#34;` } func main() { var cfg Config dec := json.NewDecoder(os.Stdin) if err := dec.Decode(\u0026amp;cfg); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Config level: %d.\\n\u0026#34;, cfg.Level) fmt.Printf(\u0026#34;Val count: %d.\\n\u0026#34;, len(cfg.Vals)) if len(cfg.Vals) \u0026gt; 0 { fmt.Printf(\u0026#34;First val name: %q.\\n\u0026#34;, cfg.Vals[0].Name) } } config.json contains a sample configuration to test our example program: Copied! config.json Copy code Copied! { \u0026#34;level\u0026#34;: 42, \u0026#34;vals\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;cueckoo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bird\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;porcuepine\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;mammal\u0026#34; } ] } We check that our example code accepts the sample configuration: TERMINAL Copy code Copied! $ cat config.json | go run . Config level: 42. Val count: 2. First val name: \u0026#34;cueckoo\u0026#34;. Generate CUE from Go types 4Use the cue command to generate CUE from the Go types in the main package: TERMINAL Copy code Copied! $ cue get go --local . The main package is inferred from the Go files present in our example and the symbol ., which refers to the Go package in the current working directory. The --local flag is required because of issue #452, and when that issue is resolved the flag won\u0026rsquo;t be needed (so long as the CUE and Go package import paths are identical). 5Inspect the generated CUE code: Copied! main_go_gen.cue Copy code Copied! // Code generated by cue get go. DO NOT EDIT. //cue:generate cue get go an.example package main #Config: { vals: [...#Val] @go(Vals,[]Val) level: int @go(Level) } #Val: { name: string @go(Name) value: string @go(Value) } Test the generated CUE 6We can use cue vet to validate our sample config file against the generated CUE: TERMINAL Copy code Copied! $ cue vet -c -d \u0026#39;#Config\u0026#39; . config.json Your Go code will probably have known-good and known-bad data for testing your generated CUE. Related content Reference: cue help get go Issue #452: path resolution issue for files generated by cue get go How-to Guide: Generating CUE from a Go dependency",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "222a2473c9cd121d482f2805a73f02d9_1",
        "title": "Generating Go types from CUE definitions",
        "link": "/docs/howto/generate-go-types-from-cue-definitions/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE v0.12.0 introduced an experimental new command:\n\u003ca href=\"/docs/reference/command/cue-help-exp-gengotypes/\"\u003e\u003ccode\u003egengotypes\u003c/code\u003e\u003c/a\u003e.\nThis command generates Go types from CUE definitions and places them in \u003ccode\u003e.go\u003c/code\u003e\nfiles. It uses sensible defaults for the generated Go code that you can\noverride by configuring various CUE attributes.\u003c/p\u003e\n\u003cp\u003eThis guide shows you how to use the \u003ccode\u003ecue exp gengotypes\u003c/code\u003e command.\u003c/p\u003e",
        "content": "CUE v0.12.0 introduced an experimental new command: gengotypes. This command generates Go types from CUE definitions and places them in .go files. It uses sensible defaults for the generated Go code that you can override by configuring various CUE attributes. This guide shows you how to use the cue exp gengotypes command. Why was gengotypes introduced? When a Go program works with CUE it can be useful to declare Go types which mirror its CUE schemas. For example, if the program loads a YAML configuration file and validates it using a CUE schema it\u0026rsquo;s often useful to hold the config as a Go struct value that controls how the program should behave. Using gengotypes allows you to declare your schemas in CUE and automatically derive compatible Go types \u0026ndash; without having to repeat yourself or maintain two versions of the same structure. Generating Go types 1Start with some CUE that contains at least one definition: Copied! pets.cue Copy code Copied! package pet // These are the only pet types we can handle. petTypes: [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;goldfish\u0026#34;] // A dog tracks information we hold about each dog. #dog: { // A dog has at least one name. name!: string age?: float \u0026amp; \u0026lt;30 } Hidden definitions (fields with names that start _#) are ignored by the gengotypes command. 2Run the cue exp gengotypes command targetting the single CUE package in the current directory: TERMINAL Copy code Copied! $ cue exp gengotypes . The command is silent when it succeeds. 3Observe the contents of the cue_types_gen.go file: Copied! cue_types_gen.go Copy code Copied! // Code generated by \u0026#34;cue exp gengotypes\u0026#34;; DO NOT EDIT. package pet // A dog tracks information we hold about each dog. type Dog struct { // A dog has at least one name. Name string `json:\u0026#34;name\u0026#34;` Age float64 `json:\u0026#34;age,omitempty\u0026#34;` } Notice these differences between the contents of pets.cue and cue_types_gen.go: By default, gengotypes ensures the first character of each struct\u0026rsquo;s name is upper-cased (#dog vs Dog). The top-level regular field petTypes and its comment aren\u0026rsquo;t present in the Go file. Only fields inside a definition are translated to Go. The optional field age has a numeric constraint in CUE (\u0026lt;30) which can\u0026rsquo;t be expressed in the simpler, less powerful Go type system \u0026ndash; so the Go encodes a float64 type. Generated Go types are guaranteed to accept any value accepted by the CUE definitions but, as with age, they may be more general. Controlling the generated Go If you need to control the generated Go package, type, and field names, you can use the @go() attribute to specify them in your CUE: 4Add another CUE file, morePets.cue, containing the following code: Copied! morePets.cue Copy code Copied! package pet @go(acmecorppets) // Rename this package when emitted as Go. // A cat represents an instance of a domestic cat. #cat: { @go(cat) // Rename this definition when emitted as Go. // Cats consider themselves to have a title, not a name. title!: string @go(Name) // Rename this field when emitted as Go socialMediaAccount!: string @go(-) // Don\u0026#39;t emit this field as Go. } #horse: { @go(-) // Don\u0026#39;t emit this definition as Go. status: \u0026#34;Unsupported\u0026#34; } 5Run the cue exp gengotypes command again: TERMINAL Copy code Copied! $ cue exp gengotypes . 6Observe the new contents of the cue_types_gen.go file: Copied! cue_types_gen.go Copy code Copied! // Code generated by \u0026#34;cue exp gengotypes\u0026#34;; DO NOT EDIT. package acmecorppets // A cat represents an instance of a domestic cat. type cat struct { // Cats consider themselves to have a title, not a name. Name string `json:\u0026#34;title\u0026#34;` } // A dog tracks information we hold about each dog. type Dog struct { // A dog has at least one name. Name string `json:\u0026#34;name\u0026#34;` Age float64 `json:\u0026#34;age,omitempty\u0026#34;` } Notice these differences between the contents of morePets.cue and the new cue_types_gen.go: At the package level: The @go(acmecorppets) attribute renamed the generated Go package from pet. The cue command targetted the whole of the CUE package so the dog-related contents of pets.cue are included under the renamed Go package. Only a single package-level renaming attribute is needed. Inside #cat: The definition-level @go(cat) attribute renamed the generated Go type from the default that would otherwise have been emitted (Cat). The field-level @go(Name) attribute renamed the generated Go field from Title. The field-level @go(-) attribute caused the socialMediaAccount field to be omitted from the generated Go type. Inside #horse, the definition-level @go(-) attribute caused the entire definition to be omitted from the generated Go. You can also use the @go() attribute to control the type of a generated field \u0026ndash; see cue help exp gengotypes for more information. The gengotypes command is still in an experimental stage, which means that it may be changed or removed at any time. The objective is for the CUE project to gain experience through your feedback about this experimental command, and then move the feature elsewhere. Related content Reference: cue help exp gengotypes \u0026ndash; the built-in help text for the cue exp gengotypes command",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "c2807ec5489d2b83c425005134ec6448_1",
        "title": "Getting started using CUE in Java",
        "link": "/docs/tutorial/get-started-cue-java/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library \u003ccode\u003ecue-api-java\u003c/code\u003e provides a way to use CUE from Java programs.\nThis tutorial helps you get started using \u003ccode\u003ecue-api-java\u003c/code\u003e,\nafter you have installed it successfully.\u003c/p\u003e\n\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003ecue-api-java\u003c/code\u003e is an experimental technology preview. This means that it\u0026rsquo;s\nunder development and its behaviour might change from one release to the next.\u003c/div\u003e\n\u003c/div\u003e",
        "content": "The library cue-api-java provides a way to use CUE from Java programs. This tutorial helps you get started using cue-api-java, after you have installed it successfully. cue-api-java is an experimental technology preview. This means that it\u0026rsquo;s under development and its behaviour might change from one release to the next. Prerequisites You need the low-level library libcue to be compiled and available on your computer, which is demonstrated in the guide \u0026ldquo;Building libcue as a shared library\u0026rdquo;. You must have the Java library cue-api-java compiled and available on your computer. The guide \u0026ldquo;Building cue-api-java as a JAR file\u0026rdquo; shows you how to compile and install it. This tutorial needs you to install the same version as that guide. Your computer needs to have the Java Development Kit (JDK) version 22 (or later) installed. If you need help choosing a distribution of Java, the site whichjdk.com is a useful guide. Note that many operating systems offer a \u0026ldquo;Long Term Support\u0026rdquo; version of Java, but this often means JDK version 21, which isn\u0026rsquo;t recent enough. Make sure that you have version 22 or later! Set up your environment 1Tell the operating system (and Java) where to find the library libcue on your computer: TERMINAL Copy code Copied! $ export LD_LIBRARY_PATH=/usr/local/lib/ If you have installed libcue into a different directory than /usr/local/lib/ then adapt the command to refer to that directory instead. 2Tell Java where to find the library cue-api-java on your computer: TERMINAL Copy code Copied! $ export CLASSPATH=\u0026#39;/usr/local/share/java/*\u0026#39; If you have installed cue-api-java into a different directory than /usr/local/share/java/ then adapt the command to refer to that directory instead. 3Cross-check the value of this important variable: TERMINAL Copy code Copied! $ echo \u0026#34;$CLASSPATH\u0026#34; /usr/local/share/java/* Java\u0026rsquo;s requirements mean that we need the value of the CLASSPATH variable to end with an asterisk \u0026ndash; make sure you see the trailing *. If this value ends with a filename instead of an asterisk (for example: /usr/local/share/java/CUE.jar) then you need to fix this. Repeat the previous step while making sure that you surround the value of the variable with quotes (') when you export it. 4Check that this tutorial\u0026rsquo;s prerequisites are present: TERMINAL Copy code Copied! $ javac --version javac 22.0.2 $ ls $LD_LIBRARY_PATH | grep libcue.so || echo \u0026#39;fail!\u0026#39; libcue.so $ ls $CLASSPATH | grep /CUE.*jar$ || echo \u0026#39;fail!\u0026#39; /usr/local/share/java/CUE.jar If any of these commands fail then your computer doesn\u0026rsquo;t have the related prerequisite installed as expected and this is a problem that you need to fix before continuing with this tutorial. 5Create a directory to hold some files, and change into it: TERMINAL Copy code Copied! $ mkdir -p cue-java-api-tutorials $ cd cue-java-api-tutorials Create a Java program 6Place this Java program in the file GetStarted.java: Copied! cue-java-api-tutorials/GetStarted.java Copy code Copied! import org.cuelang.cue.*; public class GetStarted { public static void main(String[] args) throws Exception { // Begin by creating a context. Every CUE value must come from a // context, and every CUE operation must use CUE values that come from // the *same* context. var ctx = new CueContext(); // The compile() method loads CUE passed as a string and evaluates it. var a1 = ctx.compile(\u0026#34;x: true\u0026#34;); var b1 = ctx.compile(\u0026#34;y: 42\u0026#34;); // The equals() method checks concrete values for equality. var a2 = ctx.compile(\u0026#34;x: false\u0026#34;); var b2 = ctx.compile(\u0026#34;y: 42\u0026#34;); System.out.println(\u0026#34;a1 equals a2:\\t\\t\\t\u0026#34; + a1.equals(a2)); System.out.println(\u0026#34;b1 equals b2:\\t\\t\\t\u0026#34; + b1.equals(b2)); // The unify() method unifies CUE values, returning a new CUE value. var c1 = ctx.compile(\u0026#34;a: int\u0026#34;); var c2 = ctx.compile(\u0026#34;a: 5\u0026#34;); var c3 = ctx.compile(\u0026#34;b: true\u0026#34;); var c = c1.unify(c2).unify(c3); var d = ctx.compile(\u0026#34;{ a: 5, b: true }\u0026#34;); System.out.println(\u0026#34;c equals d:\\t\\t\\t\\t\u0026#34; + c.equals(d)); // The lookup() method extracts a CUE value from a struct. var s = ctx.compile(\u0026#34;\u0026#34;\u0026#34; A: { val: 1 B: { val: 1 } } \u0026#34;\u0026#34;\u0026#34;); var sAval = s.lookup(\u0026#34;A\u0026#34;).lookup(\u0026#34;val\u0026#34;); var sABval = s.lookup(\u0026#34;A.B.val\u0026#34;); System.out.println(\u0026#34;A.val equals A.B.val:\\t\u0026#34; + sAval.equals(sABval)); } } Compile the program 7Compile the Java program: TERMINAL Copy code Copied! $ javac GetStarted.java The Java compiler automatically uses the value of the CLASSPATH environment variable to locate the JAR file containing cue-api-java. Run the program 8Run the Java program: TERMINAL Copy code Copied! $ java --enable-native-access=ALL-UNNAMED -cp .:$CLASSPATH GetStarted a1 equals a2: false b1 equals b2: true c equals d: true A.val equals A.B.val: true The Java runtime must be told about a slightly different classpath from the compiler, through the -cp flag, because it needs to locate both the cue-api-java JAR and your compiled code. The --enable-native-access flag avoids a runtime warning that the Foreign Function \u0026amp; Memory API is being used by cue-api-java. Conclusion Congratulations - you\u0026rsquo;ve successfully used CUE in a Java program using the library cue-api-java. See Related content, below, for tutorials and guides that explain more about using CUE in Java. Related content How-to Guide: Building cue-api-java as a JAR file Tutorial: Converting values between Java and CUE Tutorial: Handling errors in the Java API Tutorial: Validating data against a schema in Java java api \u0026ndash; all pages exploring the CUE Java API",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["java api"],
        "authors": ["jpluscplusm","4ad"]
    },
    
            {
        "objectID": "9585412371e015516764889b15e9450a_1",
        "title": "Handling errors in the Go API",
        "link": "/docs/howto/handle-errors-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe CUE Go API contains several functions that might need to communicate\nruntime errors to their caller, such as problems during evaluation or\nvalidation. They do this using the\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/cue/errors#Error\"\u003e\u003ccode\u003ecue/errors.Error\u003c/code\u003e\u003c/a\u003e type,\nand the \u003ca href=\"https://pkg.go.dev/cuelang.org/go/cue/errors\"\u003e\u003ccode\u003ecue/errors\u003c/code\u003e\u003c/a\u003e\npackage contains functions that allow you to interrogate and manipulate these\nerrors.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates how to catch these errors\nand how to use the \u003ccode\u003ecue/errors\u003c/code\u003e package to examine their details.\u003c/p\u003e",
        "content": "The CUE Go API contains several functions that might need to communicate runtime errors to their caller, such as problems during evaluation or validation. They do this using the cue/errors.Error type, and the cue/errors package contains functions that allow you to interrogate and manipulate these errors. This guide demonstrates how to catch these errors and how to use the cue/errors package to examine their details. Set up some CUE code 1If you don\u0026rsquo;t already have an existing CUE module, initialize one to contain a configuration: TERMINAL Copy code Copied! $ cue mod init cue.example 2If you don\u0026rsquo;t already have some known-bad CUE that contains evaluation or validation errors, create some: Copied! bad.cue Copy code Copied! package example #Schema: { i: int s: string } val: #Schema \u0026amp; { i: \u0026#34;hello\u0026#34; // Not an int. s: 42 // Not a string. } 3Verify that the configuration does not validate successfully, as expected: TERMINAL Copy code Copied! $ cue vet -c val.i: conflicting values \u0026#34;hello\u0026#34; and int (mismatched types string and int): ./bad.cue:4:5 ./bad.cue:9:5 val.s: conflicting values 42 and string (mismatched types int and string): ./bad.cue:5:5 ./bad.cue:10:5 Set up a Go program 4If you don\u0026rsquo;t already have an existing Go module, initialize one to contain a Go program: TERMINAL Copy code Copied! $ go mod init go.example ... 5Write a Go program that loads the CUE, evalutes some of it, and then prints a summary and details of any evaluation or validation errors that ocurr: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/errors\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; ) func main() { ctx := cuecontext.New() // Load the CUE package in the current directory and extract a value from it. insts := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) pkg := ctx.BuildInstance(insts[0]) val := pkg.LookupPath(cue.ParsePath(\u0026#34;val\u0026#34;)) // Check if the value evaluates successfully. err := val.Validate(cue.Concrete(true)) if err != nil { // Extract one or more errors from the evaluation. errs := errors.Errors(err) // Display information about the errors. fmt.Println(`# Error summary [err]:`) fmt.Printf(\u0026#34;%v\\n\\n\u0026#34;, err) fmt.Println(`# Error details [errors.Details(err)]:`) fmt.Printf(\u0026#34;%v\\n\u0026#34;, errors.Details(err, nil)) fmt.Println(`# Error count [len(errs)]:`) fmt.Printf(\u0026#34;%d\\n\u0026#34;, len(errs)) } } 6Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... You can use @latest in place of the specific version mentioned here. Run the Go program 7Run the Go program: TERMINAL Copy code Copied! $ go run . # Error summary [err]: val.i: conflicting values \u0026#34;hello\u0026#34; and int (mismatched types string and int) (and 1 more errors) # Error details [errors.Details(err)]: val.i: conflicting values \u0026#34;hello\u0026#34; and int (mismatched types string and int): /home/runner/bad.cue:4:5 /home/runner/bad.cue:9:5 val.s: conflicting values 42 and string (mismatched types int and string): /home/runner/bad.cue:5:5 /home/runner/bad.cue:10:5 # Error count [len(errs)]: 2 Notice that cue/errors.Details is simply a convenience function that returns the error texts of the underlying errors, aggregated as a single string. The information and metadata contained in each underlying error can be accessed by iterating through the slice of individual errors returned by the cue/errors.Errors method. Related content Tag: go api \u0026ndash; pages documenting and using the Go API Go API: cue/errors \u0026ndash; package documentation",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["go api"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "c58f094620171455e369c89a9c9a85f7_1",
        "title": "Handling errors in the Java API",
        "link": "/docs/tutorial/handle-errors-java-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library \u003ccode\u003ecue-api-java\u003c/code\u003e provides a way to use CUE from Java programs.\nIn certain situations the library might need to let you know that there\u0026rsquo;s a\nproblem with some CUE that you asked it to handle, and it does this by throwing\na \u003ccode\u003eCueError\u003c/code\u003e. This tutorial helps you learn how to handle errors returned by\n\u003ccode\u003ecue-api-java\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003ecue-api-java\u003c/code\u003e is an experimental technology preview. This means that it\u0026rsquo;s\nunder development and its behaviour might change from one release to the next.\u003c/div\u003e\n\u003c/div\u003e",
        "content": "The library cue-api-java provides a way to use CUE from Java programs. In certain situations the library might need to let you know that there\u0026rsquo;s a problem with some CUE that you asked it to handle, and it does this by throwing a CueError. This tutorial helps you learn how to handle errors returned by cue-api-java. cue-api-java is an experimental technology preview. This means that it\u0026rsquo;s under development and its behaviour might change from one release to the next. Prerequisites You need the low-level library libcue to be compiled and available on your computer, which is demonstrated in the guide \u0026ldquo;Building libcue as a shared library\u0026rdquo;. You must have the Java library cue-api-java compiled and available on your computer. The guide \u0026ldquo;Building cue-api-java as a JAR file\u0026rdquo; shows you how to compile and install it. This tutorial needs you to install the same version as that guide. Your computer needs to have the Java Development Kit (JDK) version 22 (or later) installed. If you need help choosing a distribution of Java, the site whichjdk.com is a useful guide. Note that many operating systems offer a \u0026ldquo;Long Term Support\u0026rdquo; version of Java, but this often means JDK version 21, which isn\u0026rsquo;t recent enough. Make sure that you have version 22 or later! Set up your environment 1Tell the operating system (and Java) where to find the library libcue on your computer: TERMINAL Copy code Copied! $ export LD_LIBRARY_PATH=/usr/local/lib/ If you have installed libcue into a different directory than /usr/local/lib/ then adapt the command to refer to that directory instead. 2Tell Java where to find the library cue-api-java on your computer: TERMINAL Copy code Copied! $ export CLASSPATH=\u0026#39;/usr/local/share/java/*\u0026#39; If you have installed cue-api-java into a different directory than /usr/local/share/java/ then adapt the command to refer to that directory instead. 3Cross-check the value of this important variable: TERMINAL Copy code Copied! $ echo \u0026#34;$CLASSPATH\u0026#34; /usr/local/share/java/* Java\u0026rsquo;s requirements mean that we need the value of the CLASSPATH variable to end with an asterisk: make sure you see the trailing *. If this value ends with a filename instead of an asterisk (for example: /usr/local/share/java/CUE.jar) then you need to fix this. Repeat the previous step while making sure that you surround the value of the variable with quotes (') when you export it. 4Check that this tutorial\u0026rsquo;s prerequisites are present: TERMINAL Copy code Copied! $ javac --version javac 22.0.2 $ ls $LD_LIBRARY_PATH | grep libcue.so || echo \u0026#39;fail!\u0026#39; libcue.so $ ls $CLASSPATH | grep /CUE.*jar$ || echo \u0026#39;fail!\u0026#39; /usr/local/share/java/CUE.jar If any of these commands fail then your computer doesn\u0026rsquo;t have the related prerequisite installed as expected and this is a problem that you need to fix before continuing with this tutorial. 5Create a directory to hold some files, and change into it: TERMINAL Copy code Copied! $ mkdir -p cue-java-api-tutorials $ cd cue-java-api-tutorials Create a Java program 6Place this Java program in the file HandleErrors.java: Copied! cue-java-api-tutorials/HandleErrors.java Copy code Copied! import org.cuelang.cue.*; public class HandleErrors { public static void main(String[] args) { var ctx = new CueContext(); try { var v = ctx.compile(\u0026#34;x: {\u0026#34;); // Syntax error. } catch (CueError e) { System.out.println(\u0026#34;## Catch block #1\u0026#34;); System.out.println(e.getMessage()); } try { var v = ctx.compile(\u0026#34;a: b: c: d: 1\u0026#34;); var v1 = v.lookup(\u0026#34;x\u0026#34;); // Invalid path. } catch (CueError e) { System.out.println(\u0026#34;\\n## Catch block #2\u0026#34;); System.out.println(e.getMessage()); } try { var v = ctx.compile(\u0026#34;123\u0026#34;); var s = v.getString(); // Not a string. } catch (CueError e) { System.out.println(\u0026#34;\\n## Catch block #3\u0026#34;); System.out.println(e.getMessage()); } try { var v = ctx.compile(\u0026#34;{ x: bool, y: 42 }\u0026#34;); var s = v.getJSON(); // x isn\u0026#39;t a concrete value. } catch (CueError e) { System.out.println(\u0026#34;\\n## Catch block #4\u0026#34;); System.out.println(e.getMessage()); } try { // Unification of valid CUE never throws an error. The result is // always defined, with a value of _|_ (bottom) if unification failed. System.out.println(\u0026#34;\\n## Unification #1\u0026#34;); var a = ctx.compile(\u0026#34;A: true\u0026#34;); var b = ctx.compile(\u0026#34;A: true\u0026#34;); var ab = a.unify(b); System.out.println(\u0026#34;ab is: \u0026#34; + ab.getJSON()); System.out.println(\u0026#34;printError() reports: \u0026#34;); printError(ab); System.out.println(\u0026#34;\\n## Unification #2\u0026#34;); var x = ctx.compile(\u0026#34;B: 1\u0026#34;); var y = ctx.compile(\u0026#34;B: 2\u0026#34;); var xy = x.unify(y); System.out.println(\u0026#34;printError() reports: \u0026#34;); printError(xy); } catch (CueError e) { System.out.println(\u0026#34;## Catch block #5\u0026#34;); } } static void printError(Value v) { // To check if a unification resulted in an error use the error() method on Value. // error() returns a Result, which can be Ok (success) or Err (an error occurred). switch (v.error()) { case Result.Ok\u0026lt;Value, String\u0026gt; ok -\u0026gt; System.out.println(\u0026#34;ok\u0026#34;); case Result.Err\u0026lt;Value, String\u0026gt; err -\u0026gt; System.out.println(err.err()); } } } Compile the program 7Compile the Java program: TERMINAL Copy code Copied! $ javac HandleErrors.java The Java compiler automatically uses the value of the CLASSPATH environment variable to locate the JAR file containing cue-api-java. Run the program 8Run the Java program: TERMINAL Copy code Copied! $ java --enable-native-access=ALL-UNNAMED -cp .:$CLASSPATH HandleErrors ## Catch block #1 expected \u0026#39;}\u0026#39;, found \u0026#39;EOF\u0026#39; ## Catch block #2 field not found: x ## Catch block #3 cannot use value 123 (type int) as string ## Catch block #4 cue: marshal error: x: cannot convert incomplete value \u0026#34;bool\u0026#34; to JSON ## Unification #1 ab is: {\u0026#34;A\u0026#34;:true} printError() reports: ok ## Unification #2 printError() reports: B: conflicting values 2 and 1 The Java runtime must be told about a slightly different classpath from the compiler, through the -cp flag, because it needs to locate both the cue-api-java JAR and your compiled code. The --enable-native-access flag avoids a runtime warning that the Foreign Function \u0026amp; Memory API is being used by cue-api-java. Conclusion Excellent work! You\u0026rsquo;ve successfully handled problems in Java related to invalid CUE syntax, invalid paths, non-concrete value conversions to JSON, and other runtime errors that can occur. See Related content, below, for tutorials and guides that explain more about using CUE in Java. Related content How-to Guide: Building cue-api-java as a JAR file Tutorial: Getting started using CUE in Java Tutorial: Converting values between Java and CUE Tutorial: Validating data against a schema in Java java api \u0026ndash; all pages exploring the CUE Java API",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["java api"],
        "authors": ["jpluscplusm","4ad"]
    },
    
            {
        "objectID": "3382b216107d83087d926c6ed7fc142e_1",
        "title": "How CUE enables configuration",
        "link": "/docs/concept/how-cue-enables-configuration/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eConfiguration is one of CUE\u0026rsquo;s core tasks\u003c/strong\u003e. People often start using CUE\nbecause it makes it \u003cem\u003esafer and easier\u003c/em\u003e to produce new configuration files and\nto validate existing files - but its capabilities run deeper.\nIn this guide we\u0026rsquo;ll begin with the basics of how CUE makes configuration better,\nand then explore the potential of some of its more advanced features for configuration.\nHere\u0026rsquo;s what you\u0026rsquo;ll find in this guide:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#validating-existing-configuration-files\"\u003eValidating existing configuration files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#type-checking\"\u003eType checking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#generating-configurations\"\u003eGenerating configurations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#reducing-boilerplate\"\u003eReducing boilerplate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#tooling-and-automation\"\u003eTooling and automation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#abstractions-versus-direct-access\"\u003eAbstractions versus direct access\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "Configuration is one of CUE\u0026rsquo;s core tasks. People often start using CUE because it makes it safer and easier to produce new configuration files and to validate existing files - but its capabilities run deeper. In this guide we\u0026rsquo;ll begin with the basics of how CUE makes configuration better, and then explore the potential of some of its more advanced features for configuration. Here\u0026rsquo;s what you\u0026rsquo;ll find in this guide: Validating existing configuration files Type checking Generating configurations Reducing boilerplate Tooling and automation Abstractions versus direct access Validating existing configuration files An easy first step with CUE is using the cue command to check that existing configuration files are valid. Checks can be added to an existing configuration-handling process without teaching any of the other components about CUE because the language and tooling make it easy to adopt CUE incrementally. Validation can start as small and simple as verifying only specific parts of a configuration\u0026rsquo;s data. Then, as confidence increases that the range of information the system contains is well understood, the scope of the validation can be expanded. CUE makes it possible to delay fully describing a configuration until it makes sense to do so, whilst still getting the benefit of robust validation from the start. In this example we use cue vet to validate just a couple of important fields in a larger automated testing configuration file, and we catch a mistake before it has the chance to affect a deployment: Copied! check.cue Copied! .github/workflows/deploy-to-ecs.yml Copy code Copied! Workflow: { jobs: deploy: { // environment must be specified. environment!: string // Production deployments must be performed from a supported runner. if environment == \u0026#34;production\u0026#34; { \u0026#34;runs-on\u0026#34;!: \u0026#34;ubuntu-latest\u0026#34; } } } Copy code Copied! # Adapted from https://github.com/actions/starter-workflows/blob/main/deployments/aws.yml name: Deploy to Amazon ECS on: push: branches: [ $default-branch ] env: AWS_REGION: MY_AWS_REGION ECR_REPOSITORY: MY_ECR_REPOSITORY ECS_SERVICE: MY_ECS_SERVICE ECS_CLUSTER: MY_ECS_CLUSTER ECS_TASK_DEFINITION: MY_ECS_TASK_DEFINITION CONTAINER_NAME: MY_CONTAINER_NAME permissions: contents: read jobs: deploy: name: Deploy runs-on: ubuntu-20.04 environment: production steps: - name: Checkout uses: actions/checkout@v3 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v1 - name: Build, tag, and push image to Amazon ECR id: build-image env: ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }} IMAGE_TAG: ${{ github.sha }} run: | docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG . docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG echo \u0026#34;image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT - name: Fill in the new image ID in the Amazon ECS task definition id: task-def uses: aws-actions/amazon-ecs-render-task-definition@v1 with: task-definition: ${{ env.ECS_TASK_DEFINITION }} container-name: ${{ env.CONTAINER_NAME }} image: ${{ steps.build-image.outputs.image }} - name: Deploy Amazon ECS task definition uses: aws-actions/amazon-ecs-deploy-task-definition@v1 with: task-definition: ${{ steps.task-def.outputs.task-definition }} service: ${{ env.ECS_SERVICE }} cluster: ${{ env.ECS_CLUSTER }} wait-for-service-stability: true TERMINAL Copy code Copied! $ cue vet -c check.cue .github/workflows/deploy-to-ecs.yml -d \u0026#39;Workflow\u0026#39; jobs.deploy.\u0026#34;runs-on\u0026#34;: conflicting values \u0026#34;ubuntu-latest\u0026#34; and \u0026#34;ubuntu-20.04\u0026#34;: .github/workflows/deploy-to-ecs.yml:22:14 ./check.cue:7:16 Type checking When teams work in a large codebase, they often need their programming languages to help them by providing type safety for their code. CUE brings that same rigor to configuration and data. In fact, CUE goes further than many programming languages, which can commonly validate only basic data types. In CUE, types and values are a unified concept. This important property gives the language highly expressive typing capabilities whilst being both intuitive and concise. Here\u0026rsquo;s an example of cue vet checking aSpec.yaml against the schema #Spec that contains some of the types and constraints CUE can encode, along with the detail that\u0026rsquo;s provided when validation fails: Copied! spec.cue Copy code Copied! import \u0026#34;strings\u0026#34; #Spec: { // Required string. Must not contain \u0026#34;-\u0026#34;. name!: string \u0026amp; !~\u0026#34;-\u0026#34; // Required. One of three options. kind!: \u0026#34;app\u0026#34; | \u0026#34;VM\u0026#34; | \u0026#34;service\u0026#34; // Required. Must match name and kind fields. id!: strings.HasPrefix(name + \u0026#34;-\u0026#34; + kind + \u0026#34;-\u0026#34;) // Optional. Must be a float or an int. maxLoad?: number users?: { // Optional ints. If specified, min // must be strictly less than max. max?: int \u0026amp; \u0026gt;min min?: int \u0026amp; \u0026lt;max } } Copied! aSpec.yaml Copy code Copied! name: production-www-svc kind: service id: production-www-svc-4fc78 users: min: 1024 max: 1024 maxLoad: \u0026#34;4.2\u0026#34; TERMINAL Copy code Copied! $ cue vet -c spec.cue aSpec.yaml -d \u0026#39;#Spec\u0026#39; maxLoad: conflicting values \u0026#34;4.2\u0026#34; and number (mismatched types string and number): ./aSpec.yaml:7:10 ./spec.cue:11:12 name: invalid value \u0026#34;production-www-svc\u0026#34; (out of bound !~\u0026#34;-\u0026#34;): ./spec.cue:5:18 ./aSpec.yaml:1:7 ./spec.cue:5:9 users.min: invalid value 1024 (out of bound \u0026lt;1024): ./spec.cue:16:15 ./aSpec.yaml:5:8 Generating configurations Validating existing configuration files reduces risk for many operations-related processes, but wouldn\u0026rsquo;t it be useful to shift the validation left and stop incorrect configuration values from entering the system in the first place? By describing a configuration\u0026rsquo;s different elements in discrete CUE schemas and policies, folks who contribute data to a configuration can check it against these definitions before the data is used. Developers can be confident that updating their existing configuration-related tools won\u0026rsquo;t cause a later validation or process to fail - allowing them to make changes with more certainty. The same discrete schemas and policies can be used when operations processes generate complete configurations. Whether the inputs and outputs need to be JSON, YAML, CUE, or a mix of all three, the cue command can assemble data and values from disparate sources - all whilst checking the same constraints that were available to the developer. In this next example we see four files combining data with requirements, or constraints, from multiple stakeholders: File Purpose Stakeholders schema.cue Specifies a deployment\u0026rsquo;s input data and output configuration Agreed by the whole team policy.cue Asserts that certain values meet specific constraints Management, Product, and Operations deploy.cue Contributes operational data only available during a deployment Operations values.yml Contains the details of an app needing deployment Application developers Because the configuration is valid the cue command unifies all four files\u0026rsquo; data; transforms it into the output field (in deploy.cue); and exports a JSON file for the deployment process to use: Copied! schema.cue Copied! policy.cue Copied! deploy.cue Copied! values.yml Copy code Copied! package config App: { name!: string memory!: int replicas!: int replicaMem?: number } Config: {",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation","workflow command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3382b216107d83087d926c6ed7fc142e_2",
        "title": "How CUE enables configuration",
        "link": "/docs/concept/how-cue-enables-configuration/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eConfiguration is one of CUE\u0026rsquo;s core tasks\u003c/strong\u003e. People often start using CUE\nbecause it makes it \u003cem\u003esafer and easier\u003c/em\u003e to produce new configuration files and\nto validate existing files - but its capabilities run deeper.\nIn this guide we\u0026rsquo;ll begin with the basics of how CUE makes configuration better,\nand then explore the potential of some of its more advanced features for configuration.\nHere\u0026rsquo;s what you\u0026rsquo;ll find in this guide:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#validating-existing-configuration-files\"\u003eValidating existing configuration files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#type-checking\"\u003eType checking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#generating-configurations\"\u003eGenerating configurations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#reducing-boilerplate\"\u003eReducing boilerplate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#tooling-and-automation\"\u003eTooling and automation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#abstractions-versus-direct-access\"\u003eAbstractions versus direct access\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "id!: string appName!: string appMemory!: int replicaCount!: int clusterName!: string region!: string } Copy code Copied! package config import \u0026#34;strings\u0026#34; App: { name!: !~#\u0026#34;\\.\u0026#34;# // no dots memory: \u0026gt;=1024 \u0026amp; \u0026lt;10240 replicas: \u0026gt;=2 replicaMem: memory/replicas \u0026amp; \u0026gt;=1024 } Config: { appName: strings.MaxRunes(62) appMemory: \u0026gt;=(replicaCount * 1024) replicaCount: \u0026gt;=2 clusterName: \u0026#34;PROD\u0026#34; | \u0026#34;STAGE\u0026#34; | \u0026#34;DEV\u0026#34; region: \u0026#34;EU\u0026#34; | \u0026#34;NA\u0026#34; | \u0026#34;APAC\u0026#34; | \u0026#34;AMEA\u0026#34; } Copy code Copied! package config import \u0026#34;strings\u0026#34; app: App deployment: region: \u0026#34;AMEA\u0026#34; deployment: cluster: \u0026#34;PROD\u0026#34; output: Config \u0026amp; { appName: \u0026#34;\\(app.name).service\u0026#34; appMemory: app.memory replicaCount: app.replicas region: deployment.region clusterName: deployment.cluster id: strings.ToLower(strings.Join( [appName, clusterName, region], \u0026#34;.\u0026#34;)) } Copy code Copied! app: name: frontend-ng memory: 3072 replicas: 3 TERMINAL Copy code Copied! $ cue export . values.yml -e output { \u0026#34;appMemory\u0026#34;: 3072, \u0026#34;appName\u0026#34;: \u0026#34;frontend-ng.service\u0026#34;, \u0026#34;clusterName\u0026#34;: \u0026#34;PROD\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;frontend-ng.service.prod.amea\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;AMEA\u0026#34;, \u0026#34;replicaCount\u0026#34;: 3 } But watch what happens when a developer updates their replicas field with a setting which causes a policy violation on the derived value of the replicaMem field. An early cue vet on the developer\u0026rsquo;s laptop helps prevent a deployment failure by shortening their feedback cycle: TERMINAL Copy code Copied! $ cue vet -c . values.yml -d \u0026#39;{ app: App }\u0026#39; app.replicaMem: invalid value 768.0 (out of bound \u0026gt;=1024): ./policy.cue:9:32 ./policy.cue:9:14 Copied! values.yml Copied! schema.cue Copied! policy.cue Copy code Copied! app: name: frontend-ng memory: 3072 # 20% more traffic expected: increase replica baseline from 3. replicas: 4 Copy code Copied! package config App: { name!: string memory!: int replicas!: int replicaMem?: number } Config: { id!: string appName!: string appMemory!: int replicaCount!: int clusterName!: string region!: string } Copy code Copied! package config import \u0026#34;strings\u0026#34; App: { name: !~#\u0026#34;\\.\u0026#34;# // no dots memory: \u0026gt;=1024 \u0026amp; \u0026lt;10240 replicas: \u0026gt;=2 replicaMem: memory/replicas \u0026amp; \u0026gt;=1024 } Config: { appName: strings.MaxRunes(62) appMemory: \u0026gt;=(replicaCount * 1024) replicaCount: \u0026gt;=2 clusterName: \u0026#34;PROD\u0026#34; | \u0026#34;STAGE\u0026#34; | \u0026#34;DEV\u0026#34; region: \u0026#34;EU\u0026#34; | \u0026#34;NA\u0026#34; | \u0026#34;APAC\u0026#34; | \u0026#34;AMEA\u0026#34; } CUE\u0026rsquo;s processing model allows these kinds of benefits to persist at scale, no matter how many people and teams feed data and constraints into the process: The powerful \u0026ldquo;types are values\u0026rdquo; concept merges the handling of basic types, concrete data, and the constraints that apply to values. The language disallows \u0026ldquo;overrides\u0026rdquo;, so the location where a specific value originates is never in doubt. The order-independent unification of values and constraints removes the need for confusing, overlapping defaults that can be painful to understand. That last point is really powerful: CUE\u0026rsquo;s constraints unify, like any other value. This allows schemas and policies simply to state the values and limits that they need to enforce, whilst CUE does the hard work of checking that all their constraints are compatible and that any configuration data meets the combined requirements. Reducing boilerplate CUE has several language features that allow configuration sources to reduce boilerplate - as well as a command that removes boilerplate automatically! Here\u0026rsquo;s a short example that demonstrates a couple of features that make it really productive to describe configurations in CUE: templates and defaults. Notice how the job struct, at the top of jobs.cue, contains only the unique detail that defines each entry. This allows each job\u0026rsquo;s important data to stand out, uncluttered by the common information that\u0026rsquo;s added elsewhere in the file: Copied! jobs.cue Copy code Copied! job: { nginx: replicas: 2 manager: command: \u0026#34;monit -I\u0026#34; policyd: _ boltdb: replicas: 3 postgres: replicas: 5 } // This template\u0026#39;s constraints are unified with // each member of the job struct. job: [Name=_]: { name: Name // command can be set, but has a default. command: string | *\u0026#34;exec \\(Name)\u0026#34; // replicas can be set, but defaults to 1. replicas: uint | *1 } // Databases are important, so increase the replica // minimum for members of the job struct whose keys // match #DB. job: [#DB]: replicas: \u0026gt;=3 #DB: \u0026#34;postgres\u0026#34; | \u0026#34;mysql\u0026#34; | =~\u0026#34;db$\u0026#34; TERMINAL Copy code Copied! $ cue export jobs.cue --out yaml job: nginx: replicas: 2 name: nginx command: exec nginx manager: command: monit -I name: manager replicas: 1 policyd: name: policyd command: exec policyd replicas: 1 boltdb: replicas: 3 name: boltdb command: exec boltdb postgres: replicas: 5 name: postgres command: exec postgres Tooling and automation As we\u0026rsquo;ve seen, CUE can validate multiple sources of data and transform them into a unified, vetted configuration for a target system. When dealing with multiple systems, CUE\u0026rsquo;s ability to transform the same inputs into several different forms can often be sufficient. But what happens when components need to be configured using information that\u0026rsquo;s only available from other components? The rise of complex systems requiring complicated or lengthy configurations has been paired with a rise of even more specialized tools, such as kubectl, etcdctl, or crossplane. The core operation of many of these tools is pretty similar, accepting configurations in complex forms that are only suitable for their specific use. Some of these tools have significant overlaps in functionality, along with areas where they\u0026rsquo;re particularly strong - and yet linking them together or composing them is painful, as they haven\u0026rsquo;t been designed for interoperability. This is where CUE\u0026rsquo;s tooling layer can help, using \u0026ldquo;workflow commands\u0026rdquo; to extend CUE configurations and enable data-driven workflows. Workflow commands allow the particular strengths of existing, individual tools to be harnessed, by allowing configurations to be built up incrementally. The output of each tool can be processed through CUE\u0026rsquo;s powerful language constraints, before being transformed and used as the validated input that drives the next tool. The tooling layer enables declarative specification of how external data, schema, and policy are combined by modifying CUE\u0026rsquo;s normal operation and allowing tasks to fetch information directly from external sources. Reading files, calling APIs, invoking external commands, fetching files from source control - if it can be scripted, then a workflow command can extract its information to use as data, schema, and policy. For more information on workflow commands, and how their ability to deterministically combine data from static and dynamic sources can supercharge automation, see the cue help commands reference documentation. Abstractions versus direct access Abstractions can be a powerful",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation","workflow command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3382b216107d83087d926c6ed7fc142e_3",
        "title": "How CUE enables configuration",
        "link": "/docs/concept/how-cue-enables-configuration/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003cstrong\u003eConfiguration is one of CUE\u0026rsquo;s core tasks\u003c/strong\u003e. People often start using CUE\nbecause it makes it \u003cem\u003esafer and easier\u003c/em\u003e to produce new configuration files and\nto validate existing files - but its capabilities run deeper.\nIn this guide we\u0026rsquo;ll begin with the basics of how CUE makes configuration better,\nand then explore the potential of some of its more advanced features for configuration.\nHere\u0026rsquo;s what you\u0026rsquo;ll find in this guide:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#validating-existing-configuration-files\"\u003eValidating existing configuration files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#type-checking\"\u003eType checking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#generating-configurations\"\u003eGenerating configurations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#reducing-boilerplate\"\u003eReducing boilerplate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#tooling-and-automation\"\u003eTooling and automation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/concept/how-cue-enables-configuration/#abstractions-versus-direct-access\"\u003eAbstractions versus direct access\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "mechanism for protecting a user from detail they don\u0026rsquo;t need to know, whilst guarding them against mistakes or misuse of the system or API being abstracted. But they come with a significant downside: the extra toil and investment that\u0026rsquo;s required to keep the abstraction up to date with changes in the systems they encapsulate. Over time, unmaintained abstractions inevitably drift, and even a maintained abstraction over a third-party, as-a-service system can discover drift after the fact, instead of being able to prevent it. Additionally, abstractions don\u0026rsquo;t just need to handle drift against upstream systems - they also require an ongoing time investment in delivering feature parity with new upstream capabilities . To ease this tension between protection and agility, consider using CUE\u0026rsquo;s fine-grained type and constraints to impose strong limits on the known, important values and structures that drive a system, whilst permitting looser validation of the surrounding, perhaps unknown, fields. Layering detailed, cascading constraints over APIs and systems, without developing an abstraction layer, allows more agile teams to take immediate advantage of upstream feature releases whilst still protecting the core functions relied on by all teams. If this approach isn\u0026rsquo;t suitable for your situation, take advantage of CUE\u0026rsquo;s order irrelevance to build abstractions that control API requests or configurations to your specific requirements. Next steps Interested in learning more about CUE? Here\u0026rsquo;s what you could try next: Test out CUE in your browser, with the CUE playground Take a tour through the CUE language Read about the technologies that CUE directly integrates with",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation","workflow command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2b36f35ef16e6d6cf8dc722496dee3b8_1",
        "title": "How CUE enables data validation",
        "link": "/docs/concept/how-cue-enables-data-validation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE is designed to make data validation \u003cstrong\u003esimple\u003c/strong\u003e, \u003cstrong\u003epowerful\u003c/strong\u003e, and \u003cstrong\u003eflexible\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTo achieve this, the project publishes the \u003ccode\u003ecue\u003c/code\u003e\n\u003ca href=\"/docs/introduction/installation/#install-cue-from-official-release-binaries\"\u003ecommand line tool\u003c/a\u003e,\nwhich allows a wide range of data validation tasks to be completed without\nwriting any code.\nFor more complex validation scenarios, CUE\u0026rsquo;s\n\u003ca href=\"/docs/concept/how-cue-works-with-go/#using-cues-go-api\"\u003epowerful Go APIs\u003c/a\u003e\ndeliver fine grained control.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates some of the data validation capabilities of the \u003ccode\u003ecue\u003c/code\u003e command.\u003c/p\u003e",
        "content": "CUE is designed to make data validation simple, powerful, and flexible. To achieve this, the project publishes the cue command line tool, which allows a wide range of data validation tasks to be completed without writing any code. For more complex validation scenarios, CUE\u0026rsquo;s powerful Go APIs deliver fine grained control. This guide demonstrates some of the data validation capabilities of the cue command. CUE makes data validation simple Validating data files with the cue command is easy. All we do is: define some constraints, and tell the cue command to check that each data file unifies successfully with the constraints. Unification is CUE\u0026rsquo;s core operation - it\u0026rsquo;s central to how the language and its tooling works. It allows data and constraints to work at all scales, and is one of the mechanisms that enables CUE to perform automated processes such as removing boilerplate. You\u0026rsquo;ll read more about unification later. As an example of CUE\u0026rsquo;s simplicity, here\u0026rsquo;s a set of data files that we\u0026rsquo;d like to validate - two JSON files and some YAML: Copied! alex.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Alex Atkinson\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;height\u0026#34;: 55, \u0026#34;diet\u0026#34;: \u0026#34;kibble\u0026#34; } Copied! bryn.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Bryn Brown\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;goldfish\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;diet\u0026#34;: \u0026#34;flakes\u0026#34; } Copied! charlie.yaml Copy code Copied! name: Charlie Cartwright type: cat diet: chicken Writing a schema that validates these data files isn\u0026rsquo;t difficult. We just mirror the data structure in a CUE file, marking important fields as either optional or required with ?: and !: respectively, and add some type information: Copied! schema.cue Copy code Copied! package validation name!: string // All animals have a name. type!: string // Every animal must have a type. height?: int // Optional, as we haven\u0026#39;t managed to measure *every* animal just yet. The cue vet command validates our three data files against this schema. Each file is validated independently: TERMINAL Copy code Copied! $ cue vet -c . alex.json bryn.json charlie.yaml height: conflicting values \u0026#34;2\u0026#34; and int (mismatched types string and int): ./bryn.json:4:15 ./schema.cue:5:10 cue vet caught a common JSON error in our data: a number incorrectly encoded as a string. The error message tells us that the problem is on line 4 of the bryn.json file, in the height field. Let\u0026rsquo;s correct that data: Copied! bryn.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Bryn Brown\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;goldfish\u0026#34;, \u0026#34;height\u0026#34;: 2, \u0026#34;diet\u0026#34;: \u0026#34;flakes\u0026#34; } We can then repeat the cue vet command: TERMINAL Copy code Copied! $ cue vet -c . alex.json bryn.json charlie.yaml The command is silent, which tells us that our data validated successfully \u0026hellip; but did you notice that the diet fields don\u0026rsquo;t get flagged up, despite being present in the data files but not in the schema? This is because the constraints we declared in schema.cue were placed at the top level of the validation package, and the top level of each CUE package is left open. The effect of this is that when we invoke cue vet by only telling it about some CUE and some data files, its behaviour is to allow us to specify only the important data fields that we care about, without having to fully describe the data\u0026rsquo;s structure. This lets us get started quickly, performing partial validation of the most critical data - without having to spend time exhaustively documenting each and every field. As we\u0026rsquo;ll see shortly, this behaviour can be changed by placing our constraints inside closed structs. CUE makes data validation powerful In the previous section we validated three simple data files against a trivial schema. The schema contained type constraints that made sure certain fields were of type string and int. CUE\u0026rsquo;s types also include float, number (the superset of int and float), bytes, null and bool, but its constraints enable much more sophisticated data validation than simple type checking. Let\u0026rsquo;s see some examples of different data validations that CUE makes possible, using the same three data files that we worked with above: Copied! alex.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Alex Atkinson\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;height\u0026#34;: 55, \u0026#34;diet\u0026#34;: \u0026#34;kibble\u0026#34; } Copied! bryn.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Bryn Brown\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;goldfish\u0026#34;, \u0026#34;height\u0026#34;: 2, \u0026#34;diet\u0026#34;: \u0026#34;flakes\u0026#34; } Copied! charlie.yaml Copy code Copied! name: Charlie Cartwright type: cat diet: chicken The schema.cue file is in place, as before. Let\u0026rsquo;s create policy.cue as well: Copied! schema.cue Copy code Copied! package validation name!: string type!: string height?: int Copied! policy.cue Copy code Copied! package validation type?: \u0026#34;dog\u0026#34; | \u0026#34;cat\u0026#34; height?: \u0026gt;10 The policy.cue file contains additional constraints for some data fields, which CUE combines with the type constraints in schema.cue through a process called unification. Let\u0026rsquo;s see it in action: TERMINAL Copy code Copied! $ cue vet -c . alex.json bryn.json charlie.yaml type: 2 errors in empty disjunction: type: conflicting values \u0026#34;cat\u0026#34; and \u0026#34;goldfish\u0026#34;: ./bryn.json:3:13 ./policy.cue:3:18 type: conflicting values \u0026#34;dog\u0026#34; and \u0026#34;goldfish\u0026#34;: ./bryn.json:3:13 ./policy.cue:3:10 height: invalid value 2 (out of bound \u0026gt;10): ./policy.cue:4:10 ./bryn.json:4:15 It turns out that our new policy constraints are too restrictive, as they don\u0026rsquo;t permit goldfish, or short animals. Let\u0026rsquo;s correct this by loosening our policies: Copied! policy.cue Copy code Copied! package validation type?: \u0026#34;dog\u0026#34; | \u0026#34;cat\u0026#34; | \u0026#34;goldfish\u0026#34; height?: \u0026gt;=1 We can then run cue vet again: TERMINAL Copy code Copied! $ cue vet -c . alex.json bryn.json charlie.yaml CUE unifies all the constraints that apply to a field, and checks that they\u0026rsquo;re all satisfied simultaneously. In our example, unification allowed us to separate \u0026ldquo;schema\u0026rdquo; from \u0026ldquo;policy\u0026rdquo;, but these terms don\u0026rsquo;t implicitly mean anything to CUE. Unification permits the separation of validation concerns into any number of aspects, guided by the structure that makes sense for your specific scenario. For example: perhaps one team controls the specification of the field names that are permitted, whilst another team controls their types, and a third team imposes more fine grained controls over the fields\u0026rsquo; values. Unification allows each team to control their own constraints independently, with CUE taking responsibility for combining them. CUE does the hard work of unifying all the aspects, so that it can check that your",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2b36f35ef16e6d6cf8dc722496dee3b8_2",
        "title": "How CUE enables data validation",
        "link": "/docs/concept/how-cue-enables-data-validation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE is designed to make data validation \u003cstrong\u003esimple\u003c/strong\u003e, \u003cstrong\u003epowerful\u003c/strong\u003e, and \u003cstrong\u003eflexible\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTo achieve this, the project publishes the \u003ccode\u003ecue\u003c/code\u003e\n\u003ca href=\"/docs/introduction/installation/#install-cue-from-official-release-binaries\"\u003ecommand line tool\u003c/a\u003e,\nwhich allows a wide range of data validation tasks to be completed without\nwriting any code.\nFor more complex validation scenarios, CUE\u0026rsquo;s\n\u003ca href=\"/docs/concept/how-cue-works-with-go/#using-cues-go-api\"\u003epowerful Go APIs\u003c/a\u003e\ndeliver fine grained control.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates some of the data validation capabilities of the \u003ccode\u003ecue\u003c/code\u003e command.\u003c/p\u003e",
        "content": "data validates against every aspect. More Constraints CUE enables powerful data validation by making a rich set of constraints available out of the box. You\u0026rsquo;ve already seen disjunctions in action, constraining the type field, above. Disjunctions are known as \u0026ldquo;sum types\u0026rdquo; in some other languages, or \u0026ldquo;alternation\u0026rdquo; in regular expressions. You\u0026rsquo;ve also seen bounds being used to constrain the height field numerically. Bounds work with int and float typed values, using any of the comparison operators that you\u0026rsquo;d expect, such as \u0026lt;, \u0026gt;=, and !=. CUE uses the same operators to constrain string and bytes values, lexically, byte-by-byte. Data validation often relies on regular expressions to match and constrain string values, and CUE supports them through the =~ and !~ operators. As you\u0026rsquo;ll see in the following CUE, the language\u0026rsquo;s standard library also provides many built-in validator functions. Here we use a pair of functions that can validate string data in a more straightforward and clear way than regular expressions. Copied! example.cue Copy code Copied! package validation import \u0026#34;strings\u0026#34; data: { // Each member\u0026#39;s value must have this prefix. [_]: strings.HasPrefix(\u0026#34;Super\u0026#34;) // Each member\u0026#39;s value must have this suffix. [_]: strings.HasSuffix(\u0026#34;e\u0026#34;) // Each value must start with an uppercase // ASCII letter and end with lowercase ASCII. [_]: =~\u0026#34;^[A-Z].*[a-z]$\u0026#34; // Each value must not contain the letter \u0026#34;v\u0026#34;. [_]: !~\u0026#34;v\u0026#34; } Copied! data.yml Copy code Copied! data: a: Superlative b: supersede c: Superman TERMINAL Copy code Copied! $ cue vet -c . data.yml data.b: invalid value \u0026#34;supersede\u0026#34; (does not satisfy strings.HasPrefix(\u0026#34;Super\u0026#34;)): ./example.cue:7:7 ./data.yml:3:6 ./example.cue:7:25 ./example.cue:9:7 ./example.cue:12:7 ./example.cue:14:7 data.c: invalid value \u0026#34;Superman\u0026#34; (does not satisfy strings.HasSuffix(\u0026#34;e\u0026#34;)): ./example.cue:9:7 ./data.yml:4:6 ./example.cue:7:7 ./example.cue:9:25 ./example.cue:12:7 ./example.cue:14:7 data.b: invalid value \u0026#34;supersede\u0026#34; (out of bound =~\u0026#34;^[A-Z].*[a-z]$\u0026#34;): ./example.cue:12:7 ./data.yml:3:6 ./example.cue:7:7 ./example.cue:9:7 ./example.cue:14:7 data.a: invalid value \u0026#34;Superlative\u0026#34; (out of bound !~\u0026#34;v\u0026#34;): ./example.cue:14:7 ./data.yml:2:6 ./example.cue:7:7 ./example.cue:9:7 ./example.cue:12:7 CUE also provides a way to ensure that only known fields are present in data by using definitions to create closed structs. Here\u0026rsquo;s an example of a definition being used to flag up an extra field that shouldn\u0026rsquo;t be present in our data: Copied! schema.cue Copy code Copied! package validation // #People is a list of zero or more #Person-s #People: [...#Person] #Person: { name!: string address?: string } Copied! data.yml Copy code Copied! - name: Alex Atkinson - name: Bryn Brown address: 123 Main Street, Springfield - name: Charlie Cartwright age: 80 TERMINAL Copy code Copied! $ cue vet -c . data.yml -d \u0026#39;#People\u0026#39; 2.age: field not allowed: ./data.yml:5:3 The language tour demonstrates the full range of CUE\u0026rsquo;s constraints. CUE makes data validation flexible CUE delivers flexibility, letting you adopt its succinct and powerful language at whatever pace is appropriate by enabling you to use your existing data and schemas formats alongside CUE. It does this through its first class support for various alternative schema and data formats - which can be combined, imported, and exported. The Integrations page contains links to the different formats that CUE supports, but here\u0026rsquo;s an example that demonstrates CUE\u0026rsquo;s flexibility through multiple formats being used simultaneously: Let\u0026rsquo;s start with a trivial Protobuf schema that defines ExampleType: Copied! schema.proto Copy code Copied! message ExampleType { string aString = 1; int32 anInt = 2; float aFloat = 3; bool aBool = 4; } Let\u0026rsquo;s include a JSON Schema file that adds some constraints to a couple of ExampleType\u0026rsquo;s fields: Copied! schema.json Copy code Copied! { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema#\u0026#34;, \u0026#34;definitions\u0026#34;: { \u0026#34;ExampleType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;aString\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^Multiplication\u0026#34; }, \u0026#34;anInt\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;minimum\u0026#34;: 5, \u0026#34;maximum\u0026#34;: 100, \u0026#34;exclusiveMaximum\u0026#34;: true } } } } } And let\u0026rsquo;s add some CUE policy that constrains ExampleType\u0026rsquo;s fields in ways that the other formats can\u0026rsquo;t express: Copied! policy.cue Copy code Copied! import \u0026#34;strings\u0026#34; #ExampleType: { // aString is a required field, and its value must contain // the interpolated string result of squaring anInt. aString!: strings.Contains(\u0026#34;\\(anInt*anInt)\u0026#34;) // anInt must be strictly greater than aFloat. anInt?: \u0026gt;aFloat // The final two fields are left unconstrained. aFloat?: _ aBool?: _ } We\u0026rsquo;ll carefully construct some data such that it violates constraints from each of these schema and policy files: Copied! data.yml Copy code Copied! aString: \u0026#34;Doesn\u0026#39;t start with \u0026#39;Multiplication\u0026#39;, and doesn\u0026#39;t contain the square of anInt\u0026#34; anInt: 5 aFloat: 99.0 aBool: \u0026#34;this is not a boolean value\u0026#34; The cue vet command unifies all the constraints, showing us the full extent of our data validation problem: TERMINAL Copy code Copied! $ cue vet -c policy.cue schema.proto schema.json data.yml -d \u0026#39;#ExampleType\u0026#39; aBool: conflicting values \u0026#34;this is not a boolean value\u0026#34; and bool (mismatched types string and bool): ./data.yml:4:8 ./schema.proto:5:3 aString: invalid value \u0026#34;Doesn\u0026#39;t start with \u0026#39;Multiplication\u0026#39;, and doesn\u0026#39;t contain the square of anInt\u0026#34; (does not satisfy strings.Contains(\u0026#34;25\u0026#34;)): ./policy.cue:6:12 ./data.yml:1:10 ./policy.cue:6:29 ./schema.json:9:21 ./schema.proto:2:3 aString: invalid value \u0026#34;Doesn\u0026#39;t start with \u0026#39;Multiplication\u0026#39;, and doesn\u0026#39;t contain the square of anInt\u0026#34; (out of bound =~\u0026#34;^Multiplication\u0026#34;): ./schema.json:9:21 ./data.yml:1:10 ./policy.cue:6:12 ./schema.proto:2:3 anInt: incompatible integer bounds \u0026gt;99.0 and \u0026lt;100: ./schema.json:14:21 ./policy.cue:9:10 However, if we update and fix the data, then the same cue vet command is silent - indicating that the data validated succesfully against the unified set of constraints: Copied! data.yml Copy code Copied! aString: Multiplication - 5 x 5 == 25 anInt: 5 aFloat: 4.0 aBool: false TERMINAL Copy code Copied! $ cue vet -c policy.cue schema.proto schema.json data.yml -d \u0026#39;#ExampleType\u0026#39; The range of formats and encodings that CUE supports is outlined in cue help filetypes. The cue command can also process its standard input stream in any of the formats it understands, as described in cue help inputs. Future plans You\u0026rsquo;ve seen how CUE enables simple data validation, letting you start small by checking the most important data using a succinct and easy-to-grasp format that intuitively mirrors your underlying data. You watched CUE\u0026rsquo;s powerful data validation being used to combine the requirements imposed by multiple teams expressed through its rich set of primitive constraints and its standard library. You saw how the range of formats that CUE supports can deliver flexible data validation that combines existing data, schema, and policy assets with newer, more powerful CUE constraints. This",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2b36f35ef16e6d6cf8dc722496dee3b8_3",
        "title": "How CUE enables data validation",
        "link": "/docs/concept/how-cue-enables-data-validation/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE is designed to make data validation \u003cstrong\u003esimple\u003c/strong\u003e, \u003cstrong\u003epowerful\u003c/strong\u003e, and \u003cstrong\u003eflexible\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTo achieve this, the project publishes the \u003ccode\u003ecue\u003c/code\u003e\n\u003ca href=\"/docs/introduction/installation/#install-cue-from-official-release-binaries\"\u003ecommand line tool\u003c/a\u003e,\nwhich allows a wide range of data validation tasks to be completed without\nwriting any code.\nFor more complex validation scenarios, CUE\u0026rsquo;s\n\u003ca href=\"/docs/concept/how-cue-works-with-go/#using-cues-go-api\"\u003epowerful Go APIs\u003c/a\u003e\ndeliver fine grained control.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates some of the data validation capabilities of the \u003ccode\u003ecue\u003c/code\u003e command.\u003c/p\u003e",
        "content": "is all possible, today, using CUE, but one of the project\u0026rsquo;s goals is to act as an interlingua: a bidirectional bridge between all the formats that CUE speaks, linking constraints with data sources of truth - no matter where they exist. This will allow constraints from any source to be translated into formats suitable for systems that don\u0026rsquo;t yet understand CUE (such as document databases that only understand JSON Schema) so that they can passively benefit from the language\u0026rsquo;s advanced capabilities. Next steps Interested in learning more about CUE? Here\u0026rsquo;s what you could try next: Test out CUE in your browser in the CUE playground Take a tour through the CUE language with the language tour Read about the technologies that CUE directly integrates with, such as: Concept Guide: How CUE works with JSON Concept Guide: How CUE works with YAML Concept Guide: How CUE works with JSON Schema Concept Guide: How CUE works with Protocol Buffers Concept Guide: How CUE works with OpenAPI Reference: cue help filetypes \u0026ndash; how to control which formats the cue command processes Reference: cue help inputs \u0026ndash; how the cue command assembles its inputs, including its standard input stream",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["validation"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4f7bca25150d2f3ce6c866934302893b_1",
        "title": "How CUE works with Go",
        "link": "/docs/concept/how-cue-works-with-go/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE is designed to complement and work with the Go programming language.\nIt offers a powerful API that enables Go code to take advantage of CUE\u0026rsquo;s\nadvanced capabilites.\nAdditionally, CUE makes it easy to use Go as your source of truth by using the\n\u003ccode\u003ecue\u003c/code\u003e command to convert Go types to CUE.\u003c/p\u003e\n\u003cp\u003eIn this guide we\u0026rsquo;ll demonstrate importing some Kubernetes API code to generate\nCUE schemas. We\u0026rsquo;ll also use the API to convert both CUE and non-CUE data to\nnative Go values, and validate some Go data natively with CUE.\u003c/p\u003e",
        "content": "CUE is designed to complement and work with the Go programming language. It offers a powerful API that enables Go code to take advantage of CUE\u0026rsquo;s advanced capabilites. Additionally, CUE makes it easy to use Go as your source of truth by using the cue command to convert Go types to CUE. In this guide we\u0026rsquo;ll demonstrate importing some Kubernetes API code to generate CUE schemas. We\u0026rsquo;ll also use the API to convert both CUE and non-CUE data to native Go values, and validate some Go data natively with CUE. Converting Go types to CUE If you\u0026rsquo;ve already invested time in developing Go types, you might need them to be the source of truth in your system whilst also wanting to validate data that matches those types against the more detailed constraints that CUE allows. The cue command can help you achieve this as it can convert arbitrary Go types to CUE. To demonstrate this, we\u0026rsquo;re going to fetch some Go source code published by the Kubernetes project, import some types it defines, and use some of the CUE that gets produced. Let\u0026rsquo;s start by downloading a specific version of the k8s.io/api module: TERMINAL Copy code Copied! $ go get k8s.io/api/apps/v1@v0.29.3 ... We use cue get go to generate CUE definitions from the Go types in the k8s.io/api/apps/v1 package: TERMINAL Copy code Copied! $ cue get go k8s.io/api/apps/v1 This generates some CUE packages, placing them alongside our main CUE module: TERMINAL Copy code Copied! $ tree -d cue.mod/gen/k8s.io cue.mod/gen/k8s.io |-- api | |-- apps | | `-- v1 | `-- core | `-- v1 `-- apimachinery `-- pkg |-- api | `-- resource |-- apis | `-- meta | `-- v1 ... cue get go also has a --local option that generates CUE alongside Go in a main module. Within our main module, we can import and refer to the CUE definitions generated from the Go types: Copied! config.cue Copy code Copied! package config import ( core \u0026#34;k8s.io/api/core/v1\u0026#34; apps \u0026#34;k8s.io/api/apps/v1\u0026#34; ) service: [string]: core.#Service deployment: [string]: apps.#Deployment daemonSet: [string]: apps.#DaemonSet statefulSet: [string]: apps.#StatefulSet Our configuration is currently empty - but any services, deployments, daemonSets, or statefulSets that we add will be checked against the schema of the associated Kubernetes type: TERMINAL Copy code Copied! $ cue eval service: {} deployment: {} daemonSet: {} statefulSet: {} A more in-depth example demonstrating how to drive Kubernetes configuration using CUE can be found in CUE By Example, in Controlling Kubernetes with CUE. The example above relies on generating CUE within the cue.mod/gen directory of the CUE module that holds a configuration, but we are working on a system for providing schemas for well-known services at a well-known location. This will remove the need to generate such CUE locally \u0026ndash; see discussion #2939 for more details. Using CUE\u0026rsquo;s Go API The Go API injects the power and expressiveness of CUE into your Go programs, allowing them to load and validate both CUE and non-CUE data (such as JSON or YAML), and to check data marshalled by Go, wherever it comes from. Loading CUE data In this example, we load some data from the following CUE file and display it: Copied! file.cue Copy code Copied! package example l: [1, 2, 3] v: \u0026#34;hello\u0026#34; message: (v): \u0026#34;world!\u0026#34; The cuelang.org/go/cue/load package provides a similar interface to the cue command for loading CUE. Here, we use load.Instances() to load the package in the current directory: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; ) func main() { ctx := cuecontext.New() insts := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) v := ctx.BuildInstance(insts[0]) fmt.Printf(\u0026#34;%v\\n\u0026#34;, v) } Before running, we add a dependency on the cuelang.org/go module and tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... Finally, running the Go program displays the CUE data: TERMINAL Copy code Copied! $ go run . { l: [1, 2, 3] v: \u0026#34;hello\u0026#34; message: { hello: \u0026#34;world!\u0026#34; } } CUE values have a default formatter that renders them sensibly. Loading non-CUE data The API also makes it easy to validate data held in YAML and JSON files. This example loads a CUE schema that\u0026rsquo;s embedded in code, then a YAML data file, and then validates the data against the schema. Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/encoding/yaml\u0026#34; ) const cueSource = ` #Schema: { name?: string age?: int } ` func main() { ctx := cuecontext.New() schema := ctx.CompileString(cueSource).LookupPath(cue.ParsePath(\u0026#34;#Schema\u0026#34;)) yamlFile, err := yaml.Extract(\u0026#34;data.yml\u0026#34;, nil) if err != nil { log.Fatal(err) } yamlAsCUE := ctx.BuildFile(yamlFile) unified := schema.Unify(yamlAsCUE) if err := unified.Validate(); err != nil { fmt.Println(\u0026#34; YAML: NOT ok\u0026#34;) log.Fatal(err) } fmt.Println(\u0026#34; YAML: ok\u0026#34;) } Here\u0026rsquo;s the data we\u0026rsquo;ll check against #Schema: Copied! data.yml Copy code Copied! name: Charlie Cartwright age: 99 We finish by adding a dependency on the cuelang.org/go module, tidying, and running the program: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... $ go run .  YAML: ok Checking Go data with CUE schema CUE can also validate data that\u0026rsquo;s only available inside Go. Perhaps it\u0026rsquo;s only fetched at runtime, from some file; or from some remote service over the network. This time we place our schema in a separate CUE file: Copied! schema.cue Copy code Copied! package example #Person: { name?: string age?: int \u0026amp; \u0026lt;=150 } We embed the schema file using Go embedding, and load it via a string. Then we use the #Person schema to validate a Go Person, either logging a fatal error or reporting a successful validation. Copied! main.go Copy code Copied! package main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } //go:embed schema.cue var schemaFile string func main() { ctx := cuecontext.New() schema := ctx.CompileString(schemaFile).LookupPath(cue.ParsePath(\u0026#34;#Person\u0026#34;)) person := Person{ Name: \u0026#34;Charlie Cartwright\u0026#34;, Age: 999, } personAsCUE := ctx.Encode(person) unified := schema.Unify(personAsCUE) if err := unified.Validate(); err != nil { fmt.Println(\u0026#34; Person: NOT ok\u0026#34;) log.Fatal(err) } fmt.Println(\u0026#34; Person: ok\u0026#34;) } This time we",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","go api"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "4f7bca25150d2f3ce6c866934302893b_2",
        "title": "How CUE works with Go",
        "link": "/docs/concept/how-cue-works-with-go/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE is designed to complement and work with the Go programming language.\nIt offers a powerful API that enables Go code to take advantage of CUE\u0026rsquo;s\nadvanced capabilites.\nAdditionally, CUE makes it easy to use Go as your source of truth by using the\n\u003ccode\u003ecue\u003c/code\u003e command to convert Go types to CUE.\u003c/p\u003e\n\u003cp\u003eIn this guide we\u0026rsquo;ll demonstrate importing some Kubernetes API code to generate\nCUE schemas. We\u0026rsquo;ll also use the API to convert both CUE and non-CUE data to\nnative Go values, and validate some Go data natively with CUE.\u003c/p\u003e",
        "content": "see that CUE correctly caught a problem in our data: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... $ go run .  Person: NOT ok #Person.age: invalid value 999 (out of bound \u0026lt;=150) exit status 1 Future plans The CUE project believes that its role can be one of interlingua: a bidirectional bridge between all the formats that CUE speaks, linking sources of truth with data - wherever they exist. On the way towards that goal, the project has plans to extend CUE to directly generate code in Go (and other languages), beginning with the ability to declare native types that mirror CUE counterparts. Looking further forward, the project plans to expand CUE\u0026rsquo;s generation capabilities to include producing native code that implements CUE constraints, which will enable non-CUE languages to gain highly efficient implementations of CUE features such as data validation, policy enforcement, and more. Related content Reference: cue help get go Go API: cue | cue/load | cue/cuecontext | encoding/yaml | encoding/json CUE By Example: Controlling Kubernetes with CUE Discussion #2939: Modules and package management proposal",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","go api"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "fed8ec9ba3004a6e8b6fdb6ebd10c1a5_1",
        "title": "How CUE works with JSON",
        "link": "/docs/concept/how-cue-works-with-json/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"reading-and-writing-json\"\u003e\n    \u003ca href=\"#reading-and-writing-json\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eReading and writing JSON\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/docs/tour/basics/json-superset/\"\u003eCUE is a superset of JSON\u003c/a\u003e.\nIn other words: \u003cem\u003eall valid JSON is CUE\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e tool natively supports reading and writing JSON files. In fact, JSON\nis its default output format.\u003c/p\u003e\n\u003cp\u003eThis allows JSON files to be processed by CUE\u0026rsquo;s wide range of data, schema, and\npolicy validation capabilities, and to convert input formats to JSON - as\ndemonstrated here by\n\u003ca href=\"/docs/reference/command/cue-help-export/\"\u003e\u003ccode\u003ecue export\u003c/code\u003e\u003c/a\u003e\n\u003cem\u003eunifying\u003c/em\u003e all its JSON, YAML, and CUE input files as JSON:\u003c/p\u003e\n\u003c!-- TODO: add links for capabilities --\u003e\n\u003c!-- TODO: add link to unification concept guide --\u003e",
        "content": "Reading and writing JSON CUE is a superset of JSON. In other words: all valid JSON is CUE. The cue tool natively supports reading and writing JSON files. In fact, JSON is its default output format. This allows JSON files to be processed by CUE\u0026rsquo;s wide range of data, schema, and policy validation capabilities, and to convert input formats to JSON - as demonstrated here by cue export unifying all its JSON, YAML, and CUE input files as JSON: Copied! data.json Copied! data.yml Copied! data.cue Copy code Copied! { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;three\u0026#34;, \u0026#34;d\u0026#34;: 4.4 } Copy code Copied! e: 5 f: \u0026#34;6\u0026#34; Copy code Copied! g: \u0026#34;seven\u0026#34; h: 4.4 * 2 TERMINAL Copy code Copied! $ cue export data.json data.yml data.cue { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;three\u0026#34;, \u0026#34;d\u0026#34;: 4.4, \u0026#34;e\u0026#34;: 5, \u0026#34;f\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;g\u0026#34;: \u0026#34;seven\u0026#34;, \u0026#34;h\u0026#34;: 8.8 } In addition to JSON, cue can read and write a range of other formats. Validating JSON files against a schema CUE is often used to make systems safer without having to teach the underlying system components about CUE. Because the cue tool can validate JSON files using CUE\u0026rsquo;s powerful and compact constraint syntax, it\u0026rsquo;s easy to add \u0026ldquo;pre-flight\u0026rdquo; checks to existing processes with CUE. In this example, cue vet is used to check that a hypothetical system\u0026rsquo;s JSON input files are valid - and catches a problematic deployment early in the process: Copied! schema.cue Copy code Copied! import \u0026#34;strings\u0026#34; #Config: { cluster!: strings.MaxRunes(16) region!: #Region repository!: =~#\u0026#34;^source\\.company\\.example/\u0026#34;# tags?: [...#Tags] } #Region: \u0026#34;APAC\u0026#34; | \u0026#34;IMEA\u0026#34; #Tags: \u0026#34;prod\u0026#34; | \u0026#34;stage\u0026#34; | \u0026#34;qa\u0026#34; | \u0026#34;test\u0026#34; | \u0026#34;dev\u0026#34; Copied! config-a.json Copied! config-b.json Copied! config-c.json Copy code Copied! { \u0026#34;cluster\u0026#34;: \u0026#34;live05\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;IMEA\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;source.company.example/alpha\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;prod\u0026#34; ] } Copy code Copied! { \u0026#34;cluster\u0026#34;: \u0026#34;live03333333333333\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;github.com/Alex_Personal_Account/alpha-fork\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;UK\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;dev\u0026#34; ] } Copy code Copied! { \u0026#34;cluster\u0026#34;: \u0026#34;live05\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;APAC\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;source.company.example/alpha\u0026#34; } TERMINAL Copy code Copied! $ cue vet -c schema.cue -d \u0026#39;#Config\u0026#39; config-a.json config-b.json config-c.json region: 2 errors in empty disjunction: region: conflicting values \u0026#34;APAC\u0026#34; and \u0026#34;UK\u0026#34;: ./config-b.json:4:15 ./schema.cue:9:10 region: conflicting values \u0026#34;IMEA\u0026#34; and \u0026#34;UK\u0026#34;: ./config-b.json:4:15 ./schema.cue:9:19 cluster: invalid value \u0026#34;live03333333333333\u0026#34; (does not satisfy strings.MaxRunes(16)): ./schema.cue:4:15 ./config-b.json:2:16 ./schema.cue:4:32 repository: invalid value \u0026#34;github.com/Alex_Personal_Account/alpha-fork\u0026#34; (out of bound =~\u0026#34;^source\\\\.company\\\\.example/\u0026#34;): ./schema.cue:6:15 ./config-b.json:3:19 Learn more in the How-to guide Validating JSON using CUE. Processing and transforming JSON files The cue tool can read and transform JSON files, producing output data in any shape that\u0026rsquo;s required. For example: Copied! transform.cue Copy code Copied! a: int b: int c: 1 + a*b Copied! data.json Copy code Copied! { \u0026#34;a\u0026#34;: 5, \u0026#34;b\u0026#34;: 4 } TERMINAL Copy code Copied! $ cue export data.json transform.cue { \u0026#34;a\u0026#34;: 5, \u0026#34;b\u0026#34;: 4, \u0026#34;c\u0026#34;: 21 } Learn more about transforming data with CUE in these How-to guides: Transforming JSON with CUE Combining multiple JSON files into a list Combining multiple JSON files by using file metadata Encoding JSON inside CUE CUE is frequently used to generate configuration files. Some systems allow their configuration files to contain JSON encoded in string fields, irrespective of the file\u0026rsquo;s main data format. CUE\u0026rsquo;s standard library provides a built-in json package containing functions that generate, parse, validate, and format JSON from within CUE - some of which are shown here. Generating encoded JSON In this example a Kubernetes ConfigMap contains a JSON file encoded as a single string field, in a YAML document. This is enabled by the json.Marshal function: Copied! config.cue Copy code Copied! import \u0026#34;encoding/json\u0026#34; configMap: data: \u0026#34;point.json\u0026#34;: json.Marshal({ x: 1.2 y: 3.45 }) TERMINAL Copy code Copied! $ cue export config.cue --out yaml configMap: data: point.json: \u0026#39;{\u0026#34;x\u0026#34;:1.2,\u0026#34;y\u0026#34;:3.45}\u0026#39; Parsing encoded JSON The json.Unmarshal function performs the reverse operation to json.Marshal: it turns a string containing JSON into the structure represented by the encoded data. Here, some encoded JSON data (a JSON Web Token) is emitted as YAML: Copied! token.cue Copy code Copied! import \u0026#34;encoding/json\u0026#34; _jwt: { header: #\u0026#34;{\u0026#34;alg\u0026#34;:\u0026#34;HS256\u0026#34;,\u0026#34;typ\u0026#34;:\u0026#34;JWT\u0026#34;}\u0026#34;# payload: \u0026#34;\u0026#34;\u0026#34; { \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;iat\u0026#34;: 1516239022 } \u0026#34;\u0026#34;\u0026#34; } output: header: json.Unmarshal(_jwt.header) output: payload: json.Unmarshal(_jwt.payload) TERMINAL Copy code Copied! $ cue export token.cue --out yaml output: header: alg: HS256 typ: JWT payload: sub: \u0026#34;1234567890\u0026#34; name: John Doe iat: 1516239022 Validating encoded JSON The json.Validate function allows encoded JSON to be validated against native CUE schema constraints. Here, each member of the item map is checked against the #Dimensions schema. The cue tool correctly catches and flags up two problems with the data: Copied! furniture.cue Copy code Copied! import \u0026#34;encoding/json\u0026#34; #Dimensions: { width: number depth: number height: number } // Validate each member of the map against a schema. item: [string]: json.Validate(#Dimensions) // bed is correctly specified. item: bed: #\u0026#34;{ \u0026#34;width\u0026#34;: 2, \u0026#34;height\u0026#34;: 0.1, \u0026#34;depth\u0026#34;: 2 }\u0026#34;# // table\u0026#39;s width is incorrectly specified as a string. item: table: #\u0026#34;{ \u0026#34;width\u0026#34;: \u0026#34;34\u0026#34;, \u0026#34;height\u0026#34;: 23, \u0026#34;depth\u0026#34;: 0.2 }\u0026#34;# // painting\u0026#39;s height field name is incorrectly upper-cased. item: painting: #\u0026#34;{ \u0026#34;width\u0026#34;: 34, \u0026#34;HEIGHT\u0026#34;: 12, \u0026#34;depth\u0026#34;: 0.2 }\u0026#34;# TERMINAL Copy code Copied! $ cue vet -c furniture.cue item.painting: invalid value \u0026#34;{ \\\u0026#34;width\\\u0026#34;: 34, \\\u0026#34;HEIGHT\\\u0026#34;: 12, \\\u0026#34;depth\\\u0026#34;: 0.2 }\u0026#34; (does not satisfy encoding/json.Validate): error in call to encoding/json.Validate: field not allowed: ./furniture.cue:10:17 ./furniture.cue:17:17 json.Validate:1:16 item.table: invalid value \u0026#34;{ \\\u0026#34;width\\\u0026#34;: \\\u0026#34;34\\\u0026#34;, \\\u0026#34;height\\\u0026#34;: 23, \\\u0026#34;depth\\\u0026#34;: 0.2 }\u0026#34; (does not satisfy encoding/json.Validate): error in call to encoding/json.Validate: conflicting values \u0026#34;34\u0026#34; and number (mismatched types string and number): ./furniture.cue:10:17 ./furniture.cue:4:10 ./furniture.cue:15:14 json.Validate:1:12 Other json functions The json package contains other useful functions, including those that format JSON specifically for humans to read, or for machines to consume. These functions are demonstrated in guides that you can discover through the site\u0026rsquo;s search page:  search for how-to guides mentioning \u0026ldquo;encoding/json\u0026rdquo; Converting JSON files to CUE Because every valid JSON file is also a CUE file, one very easy way to convert JSON files to CUE is simply to rename them from .json to .cue! In more complex situations cue import can create a CUE file for each JSON file it\u0026rsquo;s given, and can even recognise encoded YAML and JSON fields, and convert those structures recursively. Examples of this command being used can be",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "fed8ec9ba3004a6e8b6fdb6ebd10c1a5_2",
        "title": "How CUE works with JSON",
        "link": "/docs/concept/how-cue-works-with-json/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"reading-and-writing-json\"\u003e\n    \u003ca href=\"#reading-and-writing-json\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eReading and writing JSON\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/docs/tour/basics/json-superset/\"\u003eCUE is a superset of JSON\u003c/a\u003e.\nIn other words: \u003cem\u003eall valid JSON is CUE\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e tool natively supports reading and writing JSON files. In fact, JSON\nis its default output format.\u003c/p\u003e\n\u003cp\u003eThis allows JSON files to be processed by CUE\u0026rsquo;s wide range of data, schema, and\npolicy validation capabilities, and to convert input formats to JSON - as\ndemonstrated here by\n\u003ca href=\"/docs/reference/command/cue-help-export/\"\u003e\u003ccode\u003ecue export\u003c/code\u003e\u003c/a\u003e\n\u003cem\u003eunifying\u003c/em\u003e all its JSON, YAML, and CUE input files as JSON:\u003c/p\u003e\n\u003c!-- TODO: add links for capabilities --\u003e\n\u003c!-- TODO: add link to unification concept guide --\u003e",
        "content": "found in the cue import CLI reference documentation. Related content Concept Guide: How CUE works with YAML",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "403cbc200cf00e917dd03dfc08f544ec_1",
        "title": "How CUE works with JSON Schema",
        "link": "/docs/concept/how-cue-works-with-json-schema/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE has first class support for \u003ca href=\"https://json-schema.org/\"\u003eJSON Schema\u003c/a\u003e:\nboth the \u003ccode\u003ecue\u003c/code\u003e command and the Go API understand the format.\u003c/p\u003e\n\u003cp\u003eConstraints stored as JSON Schema are available for \u003ccode\u003ecue\u003c/code\u003e commands to use as if\nthey were expressed in CUE.\nThis allows you to work with JSON Schema constraints directly, using them to\nvalidate data, and to represent them natively in CUE\u0026rsquo;s more succinct and\nexpressive form.\u003c/p\u003e",
        "content": "CUE has first class support for JSON Schema: both the cue command and the Go API understand the format. Constraints stored as JSON Schema are available for cue commands to use as if they were expressed in CUE. This allows you to work with JSON Schema constraints directly, using them to validate data, and to represent them natively in CUE\u0026rsquo;s more succinct and expressive form. In this guide we\u0026rsquo;ll see: cue import converting a JSON Schema to CUE, cue vet using JSON Schema constraints directly, and the encoding/jsonschema Go API validating data against a JSON Schema. The ability to export CUE constraints as JSON Schema is tracked in issue #929. Using JSON Schema with the cue command The cue import command can produce CUE from JSON Schema. Let\u0026rsquo;s start with this JSON Schema: Copied! schema.json Copy code Copied! { \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Main Person schema.\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This schema defines a person.\u0026#34;, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;What is this person called?\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;minLength\u0026#34;: 1 }, \u0026#34;address\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Where does this person live?\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;minLength\u0026#34;: 1, \u0026#34;maxLength\u0026#34;: 200 }, \u0026#34;children\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;This is a very long comment for some reason, which will keep going and going past the point where it should probably have stopped.\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;default\u0026#34;: null }, \u0026#34;home phone\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;deprecated\u0026#34;: true } } } We use cue import to convert the JSON Schema to CUE: TERMINAL Copy code Copied! $ cue import -l \u0026#39;#Person:\u0026#39; schema.json cue import recognises JSON Schema from its signature fields, and uses the schema\u0026rsquo;s constraints to create a shorter, more readable CUE representation. Our -l parameter tells cue to place the constraints inside the #Person definition: Copied! schema.cue Copy code Copied! // Main Person schema. // // This schema defines a person. import \u0026#34;strings\u0026#34; #Person: { @jsonschema(schema=\u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;) // What is this person called? name!: strings.MinRunes(1) // Where does this person live? address?: strings.MinRunes(1) \u0026amp; strings.MaxRunes(200) // This is a very long comment for some reason, which will keep // going and going past the point where it should probably have // stopped. children?: [...string] \u0026#34;home phone\u0026#34;?: string @deprecated() ... } We use the imported schema to validate some known-good data (good.json) and known-bad data (bad.json): Copied! good.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;Ripon, North Yorkshire\u0026#34; } Copied! bad.json Copy code Copied! { \u0026#34;name\u0026#34;: [ \u0026#34;Charlie\u0026#34;, \u0026#34;Cartwright\u0026#34; ], \u0026#34;address\u0026#34;: \u0026#34;Ripon, North Yorkshire\u0026#34; } The cue vet command validates our data against the #Person constraint: TERMINAL Copy code Copied! $ cue vet -c -d \u0026#39;#Person\u0026#39; schema.cue good.json bad.json name: conflicting values [\u0026#34;Charlie\u0026#34;,\u0026#34;Cartwright\u0026#34;] and strings.MinRunes(1) (mismatched types list and string): ./bad.json:2:13 ./schema.cue:11:9 The cue vet command can also validate the data using the JSON Schema directly: TERMINAL Copy code Copied! $ cue vet -c schema.json good.json bad.json name: conflicting values [\u0026#34;Charlie\u0026#34;,\u0026#34;Cartwright\u0026#34;] and strings.MinRunes(1) (mismatched types list and string): ./bad.json:2:13 ./schema.json:13:13 The cue command normally recognises JSON Schema\u0026rsquo;s signature fields and treats the contents of JSON Schema as data constraints - not just additional data. A qualifier can be used to change this behaviour, as outlined in cue help filetypes: TERMINAL Copy code Copied! $ cue def json: schema.json $schema: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34; type: \u0026#34;object\u0026#34; title: \u0026#34;Main Person schema.\u0026#34; description: \u0026#34;This schema defines a person.\u0026#34; ... Using JSON Schema with the Go API The encoding/jsonschema API allows you to work with JSON Schema in Go code. As with the cue command examples shown above, the API can be used to convert JSON Schema to CUE. However, in this next example, we\u0026rsquo;ll use the API in a more fully-formed context: controlling data validation at a lower level. This Go program validates a JSON data file against a JSON Schema: Copied! main.go Copy code Copied! package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/errors\u0026#34; \u0026#34;cuelang.org/go/encoding/json\u0026#34; \u0026#34;cuelang.org/go/encoding/jsonschema\u0026#34; ) func main() { log.SetFlags(0) flag.Parse() args := flag.Args() // A cue.Context is used for building/compiling CUE at a low-level. // It replaces cue.Runtime. ctx := cuecontext.New() if len(args) != 2 { log.Fatalf(\u0026#34;usage:\\n\\t%s SCHEMA.json DATA.json\\n\u0026#34;, os.Args[0]) } // Load the schema file JSON schemaFile, err := os.ReadFile(args[0]) if err != nil { log.Fatal(err) } schemaJsonAst, err := json.Extract(args[0], schemaFile) if err != nil { log.Fatal(err) } schemaJson := ctx.BuildExpr(schemaJsonAst) // Extract JSON Schema from the JSON schemaAst, err := jsonschema.Extract(schemaJson, \u0026amp;jsonschema.Config{ Strict: true, }) if err != nil { log.Fatal(err) } // Build a cue.Value of the schema schema := ctx.BuildFile(schemaAst) // Load the data file JSON dataFile, err := os.ReadFile(args[1]) if err != nil { log.Fatal(err) } dataAst, err := json.Extract(args[1], dataFile) if err != nil { log.Fatal(err) } // Build a cue.Value of the data data := ctx.BuildExpr(dataAst) // Unify the schema and data res := schema.Unify(data) // Validate whether the combined (unified) result has errors or not. if err := res.Validate(cue.Concrete(true)); err != nil { // If errors, report them and fail. log.Fatal(errors.Details(err, nil)) } // If no errors, print the data value fmt.Printf(\u0026#34;%v\\n\u0026#34;, res) } Running the command validates the data file in the second argument against the JSON schema in the first argument - printing the data if it\u0026rsquo;s valid and displaying a validation error otherwise. Here we use it to validate the same good.json and bad.json files from above: TERMINAL Copy code Copied! $ go run . schema.json good.json { name: \u0026#34;Dorothy Cartwright\u0026#34; address: \u0026#34;Ripon, North Yorkshire\u0026#34; } $ go run . schema.json bad.json name: conflicting values [\u0026#34;Charlie\u0026#34;,\u0026#34;Cartwright\u0026#34;] and strings.MinRunes(1) (mismatched types list and string): bad.json:2:13 schema.json:13:13 exit status 1 Future plans One of CUE\u0026rsquo;s goals is to act as an interlingua: a bidirectional bridge between all the formats that CUE speaks, linking constraints and data sources of truth, no matter where they exist. To meet this goal, CUE will gain the ability to export native CUE constraints as JSON Schema, enabling their use by tools that aren\u0026rsquo;t aware of CUE. This is tracked in issue #929. Related content Reference: cue help import The encoding/jsonschema Go API Reference: cue help vet Reference: cue help filetypes Issue #929",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command","go api"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "403cbc200cf00e917dd03dfc08f544ec_2",
        "title": "How CUE works with JSON Schema",
        "link": "/docs/concept/how-cue-works-with-json-schema/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE has first class support for \u003ca href=\"https://json-schema.org/\"\u003eJSON Schema\u003c/a\u003e:\nboth the \u003ccode\u003ecue\u003c/code\u003e command and the Go API understand the format.\u003c/p\u003e\n\u003cp\u003eConstraints stored as JSON Schema are available for \u003ccode\u003ecue\u003c/code\u003e commands to use as if\nthey were expressed in CUE.\nThis allows you to work with JSON Schema constraints directly, using them to\nvalidate data, and to represent them natively in CUE\u0026rsquo;s more succinct and\nexpressive form.\u003c/p\u003e",
        "content": "tracks the conversion of CUE to JSON Schema",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command","go api"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "e7ebe91955934390919fc844056c3731_1",
        "title": "How CUE works with OpenAPI",
        "link": "/docs/concept/how-cue-works-with-openapi/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE has first class support for OpenAPI data schemas: the \u003ccode\u003ecue\u003c/code\u003e command\nautomatically recognises OpenAPI by its signature fields, and the Go API has\npackages dedicated to the format.\nSpecifically, CUE supports the\n\u003ca href=\"https://github.com/OAI/OpenAPI-Specification/tree/3.0.0\"\u003eOpenAPI 3.0.0 standard\u003c/a\u003e\nthrough its \u003ccode\u003ecomponents.schemas\u003c/code\u003e namespace for data schemas.\u003c/p\u003e\n\u003cp\u003eConstraints stored as OpenAPI data schemas are available for \u003ccode\u003ecue\u003c/code\u003e commands to\nuse as if they were expressed in CUE. This allows you to work with these\nconstraints directly, using them to validate data, and to represent them\nnatively in CUEs significantly more concise form.\u003c/p\u003e",
        "content": "CUE has first class support for OpenAPI data schemas: the cue command automatically recognises OpenAPI by its signature fields, and the Go API has packages dedicated to the format. Specifically, CUE supports the OpenAPI 3.0.0 standard through its components.schemas namespace for data schemas. Constraints stored as OpenAPI data schemas are available for cue commands to use as if they were expressed in CUE. This allows you to work with these constraints directly, using them to validate data, and to represent them natively in CUEs significantly more concise form. In this guide, we\u0026rsquo;ll see: cue def generating an OpenAPI data schema from a CUE definition, cue import turning the generated OpenAPI back into CUE, cue vet using an OpenAPI data schema directly, to validate some data, and the encoding/openapi API generating OpenAPI in Go code. Using OpenAPI with the cue command The cue command can use OpenAPI constraints in various ways, through its different subcommands. Let\u0026rsquo;s start with a simple CUE schema: Copied! schema.cue Copy code Copied! // A schema for the pet API. package api $version: \u0026#34;v1.2.3\u0026#34; // A Pet is a pet that we handle. #Pet: { // A pet has a name. name!: string // We only handle certain kinds of pets. kind!: #Kind // Centenarian pets are not handled. age?: uint \u0026amp; \u0026lt;100 // TODO: increase limit if the tortoise proposal is accepted. ... } // Kind encodes the different pets we handle. #Kind: \u0026#34;cat\u0026#34; | \u0026#34;dog\u0026#34; | \u0026#34;goldfish\u0026#34; The cue def command can express CUE constraints as OpenAPI data schemas, in OpenAPI\u0026rsquo;s components.schemas namespace - but only so long as all the top-level constraints are specified using CUE definitions. The OpenAPI info.title field is extracted from the top-level CUE comment unless the field is specified explicitly. The same goes for OpenAPI\u0026rsquo;s info.version field, which is extracted from CUE\u0026rsquo;s top-level $version field if info.version isn\u0026rsquo;t present in the CUE. Running cue def normalizes our CUE constraints, converting them into the format specified by the --out parameter. Be aware of just how long an equivalent OpenAPI definition can become - not all formats possess CUE\u0026rsquo;s succinctness and economy of expression! TERMINAL Copy code Copied! $ cue def schema.cue -o api.pet.yaml --out openapi+yaml The cue def command creates the api.pet.yaml OpenAPI document: Copied! api.pet.yaml Copy code Copied! openapi: 3.0.0 info: title: A schema for the pet API. version: v1.2.3 paths: {} components: schemas: Kind: description: Kind encodes the different pets we handle. type: string enum: - cat - dog - goldfish Pet: description: A Pet is a pet that we handle. type: object required: - name - kind properties: name: description: A pet has a name. type: string kind: $ref: \u0026#39;#/components/schemas/Kind\u0026#39; age: description: Centenarian pets are not handled. type: integer minimum: 0 maximum: 100 exclusiveMaximum: true Because CUE is more expressive than OpenAPI, it isn\u0026rsquo;t possible to generate a precise OpenAPI equivalent for every CUE constraint. CUE does the best conversion it can, limited by what OpenAPI\u0026rsquo;s data schemas can represent. The cue import command can take constraints found in OpenAPI data schemas and express them as CUE. Here we take the definition produced by cue def, above, and convert it back to CUE: TERMINAL Copy code Copied! $ cue import -p api api.pet.yaml This produces the following CUE, which is as close to the original schema.cue as OpenAPI currently permits: Copied! api.pet.cue Copy code Copied! // A schema for the pet API. package api info: { title: *\u0026#34;A schema for the pet API.\u0026#34; | string version: *\u0026#34;v1.2.3\u0026#34; | string } // Kind encodes the different pets we handle. #Kind: \u0026#34;cat\u0026#34; | \u0026#34;dog\u0026#34; | \u0026#34;goldfish\u0026#34; // A Pet is a pet that we handle. #Pet: { // A pet has a name. name!: string kind!: #Kind // Centenarian pets are not handled. age?: int \u0026amp; \u0026gt;=0 \u0026amp; \u0026lt;100 ... } The cue vet command can directly use constraints from OpenAPI data schemas to validate data. Let\u0026rsquo;s check the details of a well-known animal, Jonathan the tortoise: Copied! jonathan.yml Copy code Copied! name: Jonathan kind: tortoise website: https://en.wikipedia.org/wiki/Jonathan_(tortoise) Let\u0026rsquo;s validate Jonathan against the contents of our OpenAPI document, api.pet.yaml. CUE automatically recognises the constraints in the components.schemas namespace, making them available as the #Pet schema: TERMINAL Copy code Copied! $ cue vet -c api.pet.yaml jonathan.yml -d \u0026#39;#Pet\u0026#39; kind: 2 errors in empty disjunction: kind: conflicting values \u0026#34;cat\u0026#34; and \u0026#34;tortoise\u0026#34;: ./api.pet.yaml:11:7 ./jonathan.yml:2:7 kind: conflicting values \u0026#34;dog\u0026#34; and \u0026#34;tortoise\u0026#34;: ./jonathan.yml:2:7 Perhaps our #Pet schema should be updated to handle more animal types! Using OpenAPI with the Go API CUE can also access and generate OpenAPI through its encoding/openapi Go API. Generating an OpenAPI definition can be as simple as this: Copied! main.go Copy code Copied! package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; \u0026#34;cuelang.org/go/encoding/openapi\u0026#34; ) func main() { ctx := cuecontext.New() insts := load.Instances([]string{\u0026#34;schema.cue\u0026#34;}, nil) v := ctx.BuildInstance(insts[0]) // Generate the OpenAPI schema from the value loaded from schema.cue b, err := openapi.Gen(v, nil) if err != nil { log.Fatal(err) } // Render as indented JSON var out bytes.Buffer if err := json.Indent(\u0026amp;out, b, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, out.Bytes()) } Running this code successfully expresses the constraints in our original schema.cue file as an OpenAPI document: TERMINAL Copy code Copied! $ go run . { \u0026#34;openapi\u0026#34;: \u0026#34;3.0.0\u0026#34;, \u0026#34;info\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;A schema for the pet API.\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;v1.2.3\u0026#34; }, \u0026#34;paths\u0026#34;: {}, \u0026#34;components\u0026#34;: { \u0026#34;schemas\u0026#34;: { \u0026#34;Kind\u0026#34;: { ... The encoding/openapi package provides options to make a definition self-contained, to filter constraints, and so on. The expanding references option enables the \u0026ldquo;Structural OpenAPI\u0026rdquo; form required by CRDs targeting Kubernetes version 1.15 and later. Future plans One of CUE\u0026rsquo;s goals is to act as an interlingua: a bidirectional bridge between all the formats that CUE speaks, linking constraints with data sources of truth, no matter where they exist. For now, only OpenAPI\u0026rsquo;s data schemas, in the components.schemas namespace, are handled by CUE. More complete support is tracked in issue #3133. Related content Reference: cue help def Reference: cue help import Reference: cue help vet The encoding/openapi",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "e7ebe91955934390919fc844056c3731_2",
        "title": "How CUE works with OpenAPI",
        "link": "/docs/concept/how-cue-works-with-openapi/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE has first class support for OpenAPI data schemas: the \u003ccode\u003ecue\u003c/code\u003e command\nautomatically recognises OpenAPI by its signature fields, and the Go API has\npackages dedicated to the format.\nSpecifically, CUE supports the\n\u003ca href=\"https://github.com/OAI/OpenAPI-Specification/tree/3.0.0\"\u003eOpenAPI 3.0.0 standard\u003c/a\u003e\nthrough its \u003ccode\u003ecomponents.schemas\u003c/code\u003e namespace for data schemas.\u003c/p\u003e\n\u003cp\u003eConstraints stored as OpenAPI data schemas are available for \u003ccode\u003ecue\u003c/code\u003e commands to\nuse as if they were expressed in CUE. This allows you to work with these\nconstraints directly, using them to validate data, and to represent them\nnatively in CUEs significantly more concise form.\u003c/p\u003e",
        "content": "package Issue #3133 tracks the support of other namespaces defined by the OpenAPI standard",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "059cdcc44d9ba67b00cadcfdb1058fb8_1",
        "title": "How CUE works with Protocol Buffers",
        "link": "/docs/concept/how-cue-works-with-protocol-buffers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003e\u003ca href=\"https://protobuf.dev/\"\u003eProtocol Buffers\u003c/a\u003e, also known as \u003cem\u003eProtobuf\u003c/em\u003e, is a\nlanguage-neutral, platform-neutral, and extensible mechanism for serializing\nstructured data, initially developed and released by Google.\u003c/p\u003e\n\u003cp\u003eProtobuf definitions can be converted to CUE by the \u003ccode\u003ecue\u003c/code\u003e command and CUE\u0026rsquo;s Go\nAPI, promoting any CUE validation code placed in Protobuf options to\nfirst-class CUE value constraints.\u003c/p\u003e",
        "content": "Protocol Buffers, also known as Protobuf, is a language-neutral, platform-neutral, and extensible mechanism for serializing structured data, initially developed and released by Google. Protobuf definitions can be converted to CUE by the cue command and CUE\u0026rsquo;s Go API, promoting any CUE validation code placed in Protobuf options to first-class CUE value constraints. Using the cue command Let\u0026rsquo;s start by converting Protobuf to CUE using the cue command. We\u0026rsquo;ll begin with this Protobuf file, basic.proto: Copied! basic.proto Copy code Copied! syntax = \u0026#34;proto3\u0026#34;; // Package basic is rather basic. package cuelang.examples.basic; import \u0026#34;cue/cue.proto\u0026#34;; option go_package = \u0026#34;cuelang.org/encoding/protobuf/examples/basic\u0026#34;; // This is my type. message MyType { string string_value = 1; // Some string value // A method must start with a capital letter. repeated string method = 2 [(cue.val) = \u0026#39;[...=~\u0026#34;^[A-Z]\u0026#34;]\u0026#39;]; } The cue import command converts Protobuf to CUE. It indicates success by displaying no output: TERMINAL Copy code Copied! $ cue import basic.proto The command creates this CUE file: Copied! basic.cue Copy code Copied! // Package basic is rather basic. package basic // This is my type. #MyType: { stringValue?: string @protobuf(1,string,name=string_value) // Some string value // A method must start with a capital letter. method?: [...string] @protobuf(2,string) method?: [...=~\u0026#34;^[A-Z]\u0026#34;] } Do you notice how the method field\u0026rsquo;s type and constraints are split over two lines? That\u0026rsquo;s exactly as expected, because CUE\u0026rsquo;s core operation is to automatically unify each field\u0026rsquo;s right-hand-side. The behaviour of the cue import command can be affected by the flags outlined in the proto mode section of the command\u0026rsquo;s help text. Using the Go API CUE\u0026rsquo;s Go API can achieve the same result as the cue import command, converting Protobuf definitions to CUE, but with more customization and flexibility. This simple Go code takes the basic.proto file shown above, and prints the equivalent CUE: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue/format\u0026#34; \u0026#34;cuelang.org/go/encoding/protobuf\u0026#34; ) func main() { file, err := protobuf.Extract(\u0026#34;basic.proto\u0026#34;, nil, \u0026amp;protobuf.Config{ Paths: []string{ /* paths to proto includes */ }, }) if err != nil { log.Fatal(err) } b, _ := format.Node(file) fmt.Println(string(b)) } Here\u0026rsquo;s the program\u0026rsquo;s output: TERMINAL Copy code Copied! $ go run main.go // Package basic is rather basic. package basic // This is my type. #MyType: { stringValue?: string @protobuf(1,string,name=string_value) // Some string value // A method must start with a capital letter. method?: [...string] @protobuf(2,string) method?: [...=~\u0026#34;^[A-Z]\u0026#34;] } Notice that the ouput is identical to the CUE produced previously by cue import. Extracting CUE from several Protobuf files In some environments it might be necessary to import multiple Protobuf files that map to different CUE packages within the same module. If several .proto files import each other, and other centralized schema definitions, then things can get hairy! In these situations, CUE\u0026rsquo;s Go API and the cue command have you covered. Both cue import and the encoding/protobuf package can be configured to handle custom import paths but, by default, when they encounter \u0026hellip; .proto files that have a go_package directive: CUE uses this path files that map to a package within the CUE module: CUE uses the package\u0026rsquo;s directory any other import path: CUE maps to a location in the cue.mod/pkg directory. Experimental APIs CUE initially publishes APIs and packages marked as \u0026ldquo;experimental\u0026rdquo;, in order to gather feedback on their use and structure before comitting the project to their long-term support. CUE\u0026rsquo;s Protobuf APIs include two experimental packages: encoding/protobuf/textproto and encoding/protobuf/jsonpb. textproto converts text Protobuf message files to and from CUE, and jsonpb rewrites a CUE expression based on the Protobuf interpretation of JSON. Your feedback on their utility and structure is invaluable - please join the CUE community on Slack and GitHub, and let us know how you\u0026rsquo;re using these APIs! Protobuf mappings The mappings between Protobuf and CUE types are outlined in the encoding/protobuf package documentation. Future plans CUE\u0026rsquo;s support for Protobuf is only going to expand, with plans including the conversion of CUE definitions to binary Protobuf definitions, and for bidirectional conversion of binary and JSON Protobuf messages to and from CUE. Related content Reference: cue help import Reference: cue help filetypes Go API: encoding/protobuf Go API: encoding/protobuf/textproto Go API: encoding/protobuf/jsonpb",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","go api"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "a223762b005d410824c22bf9a43b3e0a_1",
        "title": "How CUE works with YAML",
        "link": "/docs/concept/how-cue-works-with-yaml/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"reading-and-writing-yaml\"\u003e\n    \u003ca href=\"#reading-and-writing-yaml\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eReading and writing YAML\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e tool natively supports reading and writing YAML files, including\nthose containing multiple documents.\u003c/p\u003e\n\u003cp\u003eThis allows YAML files to be processed by CUE\u0026rsquo;s wide range of data, schema, and\npolicy validation capabilities, and to convert input formats to YAML - as\ndemonstrated here by\n\u003ca href=\"/docs/reference/command/cue-help-export/\"\u003e\u003ccode\u003ecue export\u003c/code\u003e\u003c/a\u003e\n\u003cem\u003eunifying\u003c/em\u003e all its YAML, JSON, and CUE input files as YAML:\u003c/p\u003e\n\u003c!-- TODO: add links for capabilities --\u003e\n\u003c!-- TODO: add link to unification concept guide --\u003e",
        "content": "Reading and writing YAML The cue tool natively supports reading and writing YAML files, including those containing multiple documents. This allows YAML files to be processed by CUE\u0026rsquo;s wide range of data, schema, and policy validation capabilities, and to convert input formats to YAML - as demonstrated here by cue export unifying all its YAML, JSON, and CUE input files as YAML: Copied! data.yml Copied! data.json Copied! data.cue Copy code Copied! a: 1 b: \u0026#34;2\u0026#34; c: \u0026#34;three\u0026#34; d: 4.4 Copy code Copied! { \u0026#34;e\u0026#34;: 5, \u0026#34;f\u0026#34;: \u0026#34;6\u0026#34; } Copy code Copied! g: \u0026#34;seven\u0026#34; h: 4.4 * 2 TERMINAL Copy code Copied! $ cue export --out yaml data.yml data.json data.cue a: 1 b: \u0026#34;2\u0026#34; c: three d: 4.4 e: 5 \u0026#34;f\u0026#34;: \u0026#34;6\u0026#34; g: seven h: 8.8 In addition to YAML, cue can read and write a range of other formats. Validating YAML files against a schema CUE is often used to make systems safer without having to teach the underlying system components about CUE. Because the cue tool can validate YAML files using CUE\u0026rsquo;s powerful and compact constraint syntax, it\u0026rsquo;s easy to add \u0026ldquo;pre-flight\u0026rdquo; checks to existing processes with CUE. In this example, cue vet is used to check that a hypothetical system\u0026rsquo;s YAML input files are valid - and catches a problematic deployment early in the process: Copied! schema.cue Copy code Copied! import \u0026#34;strings\u0026#34; #Config: { cluster!: strings.MaxRunes(16) region!: #Region repository!: =~#\u0026#34;^source\\.company\\.example/\u0026#34;# tags?: [...#Tags] } #Region: \u0026#34;APAC\u0026#34; | \u0026#34;IMEA\u0026#34; #Tags: \u0026#34;prod\u0026#34; | \u0026#34;stage\u0026#34; | \u0026#34;qa\u0026#34; | \u0026#34;test\u0026#34; | \u0026#34;dev\u0026#34; Copied! config-a.yaml Copied! config-b.yaml Copied! config-c.yaml Copy code Copied! cluster: live05 region: IMEA repository: source.company.example/alpha tags: - prod Copy code Copied! cluster: live03333333333333 repository: github.com/Alex_Personal_Account/alpha-fork region: UK tags: - dev Copy code Copied! cluster: live05 region: APAC repository: source.company.example/alpha TERMINAL Copy code Copied! $ cue vet -c schema.cue -d \u0026#39;#Config\u0026#39; config-a.yaml config-b.yaml config-c.yaml region: 2 errors in empty disjunction: region: conflicting values \u0026#34;APAC\u0026#34; and \u0026#34;UK\u0026#34;: ./config-b.yaml:3:9 ./schema.cue:9:10 region: conflicting values \u0026#34;IMEA\u0026#34; and \u0026#34;UK\u0026#34;: ./config-b.yaml:3:9 ./schema.cue:9:19 cluster: invalid value \u0026#34;live03333333333333\u0026#34; (does not satisfy strings.MaxRunes(16)): ./schema.cue:4:15 ./config-b.yaml:1:10 ./schema.cue:4:32 repository: invalid value \u0026#34;github.com/Alex_Personal_Account/alpha-fork\u0026#34; (out of bound =~\u0026#34;^source\\\\.company\\\\.example/\u0026#34;): ./schema.cue:6:15 ./config-b.yaml:2:13 Learn more in the How-to guide Validating YAML using CUE. Processing and transforming YAML files The cue tool can read and transform YAML files, producing output data in any shape that\u0026rsquo;s required. For example: Copied! transform.cue Copy code Copied! a: int b: int c: 1 + a*b Copied! data.yaml Copy code Copied! a: 5 b: 4 TERMINAL Copy code Copied! $ cue export --out yaml data.yaml transform.cue a: 5 b: 4 c: 21 Learn more about transforming data with CUE in these How-to guides: Transforming YAML with CUE Combining multiple YAML files into a list Combining multiple YAML files by using file metadata Encoding YAML inside CUE CUE is frequently used to generate configuration files. Some systems allow their configuration files to contain YAML encoded in string fields, irrespective of the file\u0026rsquo;s main data format. CUE\u0026rsquo;s standard library provides a built-in yaml package containing functions that generate, parse, and validate YAML from within CUE - some of which are shown here. Generating encoded YAML In this example a Kubernetes ConfigMap contains a YAML file encoded as a single string field, in a JSON file. This is enabled by the yaml.Marshal function: Copied! config.cue Copy code Copied! import \u0026#34;encoding/yaml\u0026#34; configMap: data: \u0026#34;point.yaml\u0026#34;: yaml.Marshal({ x: 1.2 y: 3.45 }) TERMINAL Copy code Copied! $ cue export config.cue --out json { \u0026#34;configMap\u0026#34;: { \u0026#34;data\u0026#34;: { \u0026#34;point.yaml\u0026#34;: \u0026#34;x: 1.2\\n\\\u0026#34;y\\\u0026#34;: 3.45\\n\u0026#34; } } } Parsing encoded YAML The yaml.Unmarshal function performs the reverse operation to yaml.Marshal: it turns a string containing YAML into the structure represented by the encoded data. Here, some encoded YAML data is emitted as JSON: Copied! file.cue Copy code Copied! import \u0026#34;encoding/yaml\u0026#34; output: yaml.Unmarshal(data) data: \u0026#34;\u0026#34;\u0026#34; user: charlie name: Charlie Cartwright colour: orange species: cat address: - 42 Lancashire Road - Ripon - North Yorkshire \u0026#34;\u0026#34;\u0026#34; TERMINAL Copy code Copied! $ cue export file.cue -e output { \u0026#34;user\u0026#34;: \u0026#34;charlie\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Charlie Cartwright\u0026#34;, \u0026#34;colour\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;species\u0026#34;: \u0026#34;cat\u0026#34;, \u0026#34;address\u0026#34;: [ \u0026#34;42 Lancashire Road\u0026#34;, \u0026#34;Ripon\u0026#34;, \u0026#34;North Yorkshire\u0026#34; ] } Validating encoded YAML The yaml.Validate and yaml.ValidatePartial functions allow encoded YAML to be validated against native CUE schema constraints. Here, each member of the item map is checked against the #Dimensions schema. The cue tool correctly catches and flags up two problems with the data: Copied! furniture.cue Copy code Copied! import \u0026#34;encoding/yaml\u0026#34; #Dimensions: { width: number depth: number height: number } // Validate each member of the map against a schema. item: [string]: yaml.Validate(#Dimensions) // bed is correctly specified. item: bed: \u0026#34;\u0026#34;\u0026#34; width: 2 height: 0.1 depth: 2 \u0026#34;\u0026#34;\u0026#34; // table\u0026#39;s width is incorrectly specified as a string. item: table: \u0026#34;\u0026#34;\u0026#34; width: \u0026#34;34\u0026#34; height: 23 depth: 0.2 \u0026#34;\u0026#34;\u0026#34; // painting\u0026#39;s height field name is incorrectly upper-cased. item: painting: \u0026#34;\u0026#34;\u0026#34; width: 34 HEIGHT: 12 depth: 0.2 \u0026#34;\u0026#34;\u0026#34; TERMINAL Copy code Copied! $ cue vet -c furniture.cue item.painting: invalid value \u0026#34;width: 34\\nHEIGHT: 12\\ndepth: 0.2\u0026#34; (does not satisfy encoding/yaml.Validate): error in call to encoding/yaml.Validate: field not allowed: ./furniture.cue:10:17 ./furniture.cue:25:17 yaml.Validate:2:1 item.table: invalid value \u0026#34;width: \\\u0026#34;34\\\u0026#34;\\nheight: 23\\ndepth: 0.2\u0026#34; (does not satisfy encoding/yaml.Validate): error in call to encoding/yaml.Validate: conflicting values \u0026#34;34\u0026#34; and number (mismatched types string and number): ./furniture.cue:10:17 ./furniture.cue:4:10 ./furniture.cue:19:14 yaml.Validate:1:8 Other yaml functions The yaml package contains other useful functions which are demonstrated in guides that you can discover through the site\u0026rsquo;s search page:  search for how-to guides mentioning \u0026ldquo;encoding/yaml\u0026rdquo; Converting YAML files to CUE cue import can create a CUE file for each YAML file it\u0026rsquo;s given, and can even recognise encoded YAML and JSON fields, and convert those structures recursively. Examples of this command being used can be found in the cue import CLI reference documentation. Related content Concept Guide: How CUE works with JSON",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["encodings","cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "752672271c944c7d349c9aff0c73bfb5_1",
        "title": "Influencing the order of tasks in a workflow command",
        "link": "/docs/howto/influence-workflow-command-task-order/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use dependencies to influence the order of execution of\ntasks in a workflow command.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use dependencies to influence the order of execution of tasks in a workflow command. Copied! some_tool.cue Copied! input.txt Copy code Copied! package example import ( \u0026#34;strings\u0026#34; \u0026#34;tool/cli\u0026#34; \u0026#34;tool/file\u0026#34; ) command: doStuff: { // The readFile task reads a greeting from a file. readFile: file.Read \u0026amp; { filename: \u0026#34;input.txt\u0026#34; contents: string } // The echoGreeting task prints the greeting read by readFile. echoGreeting: cli.Print \u0026amp; { text: \u0026#34;We read: \\(strings.TrimSpace(readFile.contents))\u0026#34; } // The thankUser task prints a message after both readFile and echoGreeting are finished. thankUser: cli.Print \u0026amp; { $after: [readFile, echoGreeting] text: \u0026#34;Thank you\u0026#34; } } Copy code Copied! Hello, world! TERMINAL Copy code Copied! $ cue cmd doStuff We read: Hello, world! Thank you Related content How-to Guide: Using your first CUE workflow command \u0026ndash; getting started with workflow commands Reference: cue help commands Reference: cue help cmd",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["workflow command"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "14940ea72afbfdac8c87fed560bf16b8_1",
        "title": "Injecting a value into an evaluation using a tag attribute",
        "link": "/docs/howto/inject-value-into-evaluation-using-tag-attribute/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use tag attributes to inject arbitrary values\ninto CUE evaluations. A separate guide details\n\u003ca href=\"/docs/howto/inject-system-information-into-evaluation-using-tag-variable/\"\u003ehow to inject system information\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOne of CUE\u0026rsquo;s core concepts is that evaluations should be \u003cem\u003erepeatable:\u003c/em\u003e given\nthe same input, the same output should be produced.\nHowever, sometimes it can be necessary to introduce context or other information\ninto an evaluation that might cause the output to vary. As described in the\n\u003ca href=\"/docs/reference/command/cue-help-injection/\"\u003e\u003ccode\u003ecue help injection\u003c/code\u003e\u003c/a\u003e\nreference, CUE allows information to be introduced, or \u003cem\u003einjected\u003c/em\u003e, by using tag\nattributes and tag variables. This guide demonstrates tag attributes.\u003c/p\u003e\n\u003c!-- TODO(jcm): include a cue-cmd in the set of commands demonstrated on this page --\u003e",
        "content": "This guide demonstrates how to use tag attributes to inject arbitrary values into CUE evaluations. A separate guide details how to inject system information. One of CUE\u0026rsquo;s core concepts is that evaluations should be repeatable: given the same input, the same output should be produced. However, sometimes it can be necessary to introduce context or other information into an evaluation that might cause the output to vary. As described in the cue help injection reference, CUE allows information to be introduced, or injected, by using tag attributes and tag variables. This guide demonstrates tag attributes. Injecting a value Copied! string.cue Copy code Copied! package example // A tag\u0026#39;s value is treated as a string unless // an alternative type is specified (see below). A: string @tag(a) // A default provides a value if the related key // is not specified for the cue command. B: *\u0026#34;bar\u0026#34; | string @tag(b) C: string @tag(name) TERMINAL Copy code Copied! $ cue export -t a=foo -t name=$USER { \u0026#34;A\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;robin\u0026#34; } Environment variables can be injected explicitly by the shell, as shown here with the value of the name tag being set by the USER variable. Issue #3811 tracks a proposal to simplify the injection of multiple environment variables \u0026ndash; please do provide your feedback on that issue. Injecting a numeric value Copied! number.cue Copy code Copied! package example A: int @tag(a,type=int) // The number field type is compatible with both // integers and floating point numbers. B: number @tag(b,type=number) // To treat an injected value exclusively as a // float, use a tag with a number type and a field // of type float. C: float @tag(b,type=number) TERMINAL Copy code Copied! $ cue eval -t a=42 -t b=4.2 A: 42 B: 4.2 C: 4.2 Both the B and C fields refer to the same tag attribute, b. Injecting a single value can affect multiple fields. Injecting a boolean value Copied! boolean.cue Copy code Copied! package example A: bool @tag(a,type=bool) // This constraint causes the evaluation to fail. A: false TERMINAL Copy code Copied! $ cue vet -c -t a=true A: conflicting values false and true: ./boolean.cue:6:4 Injecting lists of values Copied! list.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; asString: string @tag(a) // Using a disjunction with the empty list ensures // that an evaluation can succeed even if no value // is provided for the tag value. asList: *json.Unmarshal(asString) | [] A: [ for e in asList {\u0026#34;\\(e)-with-suffix\u0026#34;}, ] TERMINAL Copy code Copied! $ cue eval -t a=\u0026#39;[\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;]\u0026#39; asString: \u0026#34;[\\\u0026#34;foo\\\u0026#34;, \\\u0026#34;bar\\\u0026#34;]\u0026#34; asList: [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] A: [\u0026#34;foo-with-suffix\u0026#34;, \u0026#34;bar-with-suffix\u0026#34;] Related content How-to Guide: Injecting system information into an evaluation using a tag variable Reference: cue help injection \u0026ndash; the cue command\u0026rsquo;s help text for value and file injection How-to Guide: Conditionally including CUE files using build attributes \u0026ndash; shorthand tag attributes can also be used as build attributes, which affect which CUE files are included in an evaluation Issue #3811 tracks a proposal to simplify the injection of multiple environment variables",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "a34dccf3ed324c45e362de808339591a_1",
        "title": "Injecting system information into an evaluation using a tag variable",
        "link": "/docs/howto/inject-system-information-into-evaluation-using-tag-variable/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use tag variables to inject system information\ninto CUE evaluations. A separate guide details\n\u003ca href=\"/docs/howto/inject-value-into-evaluation-using-tag-attribute/\"\u003ehow to inject arbitrary information\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOne of CUE\u0026rsquo;s core concepts is that evaluations should be \u003cem\u003erepeatable:\u003c/em\u003e given\nthe same input, the same output should be produced.\nHowever, sometimes it can be necessary to introduce context or other information\ninto an evaluation that might cause the output to vary. As described in the\n\u003ca href=\"/docs/reference/command/cue-help-injection/\"\u003e\u003ccode\u003ecue help injection\u003c/code\u003e\u003c/a\u003e\nreference, CUE allows information to be introduced, or \u003cem\u003einjected\u003c/em\u003e, by using tag\nattributes and tag variables. This guide demonstrates tag variables.\u003c/p\u003e",
        "content": "This guide demonstrates how to use tag variables to inject system information into CUE evaluations. A separate guide details how to inject arbitrary information. One of CUE\u0026rsquo;s core concepts is that evaluations should be repeatable: given the same input, the same output should be produced. However, sometimes it can be necessary to introduce context or other information into an evaluation that might cause the output to vary. As described in the cue help injection reference, CUE allows information to be introduced, or injected, by using tag attributes and tag variables. This guide demonstrates tag variables. Injecting system information Use system information in CUE by including one or more tag variables: Copied! tag-variables.cue Copy code Copied! package example directory: string @tag(a,var=cwd) operatingSystem: string @tag(b,var=os) cpuArchitecture: string @tag(c,var=arch) currentUsername: string @tag(d,var=username) currentHostname: string @tag(e,var=hostname) randomnessA: int @tag(f,var=rand,type=int) randomnessB: int @tag(g,var=rand,type=int) currentTimeA: string @tag(h,var=now) currentTimeB: string @tag(i,var=now) Make system information available to an evaluation by including the -T flag when invoking a supported cue command: TERMINAL Copy code Copied! $ cue export -T --out cue | sort cpuArchitecture: \u0026#34;arm64\u0026#34; currentHostname: \u0026#34;7c8be7f9b8ee\u0026#34; currentTimeA: \u0026#34;2024-11-21T12:24:01.928819957Z\u0026#34; currentTimeB: \u0026#34;2024-11-21T12:24:01.928819957Z\u0026#34; currentUsername: \u0026#34;root\u0026#34; directory: \u0026#34;/home/runner\u0026#34; operatingSystem: \u0026#34;linux\u0026#34; randomnessA: 48143939811130088532707076255718137665 randomnessB: 48143939811130088532707076255718137665 In the CUE source, notice that the rand and now tag variables were repeated, and contributed to the values of more than one field. Any tag variable may be repeated, and each repeated use injects the same value inside a single CUE evaluation. Some variables, such as username and hostname, can be expected to remain stable across CUE evaluations by the same user on the same host. In contrast, the now and rand variables are completely unstable, as demonstrated here by their values being different to the values shown above: TERMINAL Copy code Copied! $ cue eval -T | grep -e ^currentTime -e ^random randomnessA: 256474124597080097645628343043781257633 randomnessB: 256474124597080097645628343043781257633 currentTimeA: \u0026#34;2024-11-21T12:24:03.630382379Z\u0026#34; currentTimeB: \u0026#34;2024-11-21T12:24:03.630382379Z\u0026#34; Overridding system information Tag variables are specified in combination with a tag key. For example, as shown above, the randomnessA field is declared to have a relationship with both the rand tag variable and the f tag key: TERMINAL Copy code Copied! $ grep ^random tag-variables.cue randomnessA: int @tag(f,var=rand,type=int) randomnessB: int @tag(g,var=rand,type=int) If a tag key is specified for a cue command then it overrides the system information for fields associated with the tag: TERMINAL Copy code Copied! $ cue eval -Tt f=123123123000 | grep ^random randomnessA: 123123123000 randomnessB: 154463835233876152095912350456117094604 Related content How-to Guide: Injecting a value into an evaluation using a tag attribute Reference: cue help injection \u0026ndash; the cue command\u0026rsquo;s help text for value and file injection How-to Guide: Conditionally including CUE files using build attributes \u0026ndash; shorthand tag attributes can also be used as build attributes, which affect which CUE files are included in an evaluation",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "7549e894863884c0a9e4e904cdae4905_1",
        "title": "Loading CUE via the Go API",
        "link": "/docs/tutorial/loading-cue-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis tutorial demonstrates how to get started with \u003ca href=\"https://pkg.go.dev/cuelang.org/go\"\u003eCUE\u0026rsquo;s Go\nAPI\u003c/a\u003e, and write a Go program to load and\nevaluate some CUE.\u003c/p\u003e",
        "content": "This tutorial demonstrates how to get started with CUE\u0026rsquo;s Go API, and write a Go program to load and evaluate some CUE. Prerequisites A tool to edit text files. Any text editor you have will be fine, for example VSCode. A command terminal. cue works on all platforms, so any terminal on Linux or macOS, and on PowerShell, cmd.exe or WSL in Windows. An installed go binary (installation details) An installed cue binary (installation details) Some awareness of CUE schemata (Constraints and Definitions in the CUE tour) This tutorial is written using the following versions of go and cue: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... $ go version go version go1.24.0 linux/amd64 Create a CUE module 1Initialize a CUE module to hold our configuration: TERMINAL Copy code Copied! $ cue mod init company.example/configuration 2Write some CUE code: Copied! some.cue Copy code Copied! package example output: \u0026#34;Hello \\(name)\u0026#34; name: \u0026#34;Joe\u0026#34; 3Verify that the configuration successfully evaluates: TERMINAL Copy code Copied! $ cue export { \u0026#34;output\u0026#34;: \u0026#34;Hello Joe\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Joe\u0026#34; } Create a Go module and program 4Initialize a Go module to contain your program: TERMINAL Copy code Copied! $ go mod init company.example/configuration ... 5Write a Go program to load the CUE and print a message based on the output field: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; ) func main() { ctx := cuecontext.New() // Load the package \u0026#34;example\u0026#34; from the current directory. // We don\u0026#39;t need to specify a config in this example. insts := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) // The current directory just has one file without any build tags, // and that file belongs to the example package. // So we get a single instance as a result. v := ctx.BuildInstance(insts[0]) if err := v.Err(); err != nil { log.Fatal(err) } // Lookup the \u0026#39;output\u0026#39; field and print it out output := v.LookupPath(cue.ParsePath(\u0026#34;output\u0026#34;)) fmt.Println(output) } 6Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... You can use @latest in place of a specified version. Run the Go program 7Run the Go program: TERMINAL Copy code Copied! $ go run . \u0026#34;Hello Joe\u0026#34; Congratulations! Well done - you\u0026rsquo;ve successfully written your first Go program to load and evaluate CUE. Related content cuelang.org/go API docs",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["go api"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "d12ebd8b8b057bd310e5d3fd62a42f47_1",
        "title": "Logging statistics from the CUE evaluator",
        "link": "/docs/howto/log-statistics-from-the-cue-evaluator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e command can log various summary statistics about each evaluation it\nperforms, in order to assist with the diagnosis of performance-related and\nother issues. The command logs statistics when the \u003ccode\u003eCUE_STATS_FILE\u003c/code\u003e environment\nvariable is set to a filename.\u003c/p\u003e\n\u003cp\u003eThe filename is interpreted through the same rules that \u003ccode\u003ecue export\u003c/code\u003e applies to\nits \u003ccode\u003e--outfile\u003c/code\u003e argument, which are explained in\n\u003ca href=\"/docs/reference/command/cue-help-filetypes/\"\u003e\u003ccode\u003ecue help filetypes\u003c/code\u003e\u003c/a\u003e.\nStatistics for each evaluation are written into the named file using the file\u0026rsquo;s\nimplied data format.\nThe file is overwritten on each \u003ccode\u003ecue\u003c/code\u003e invocation, without confirmation.\u003c/p\u003e",
        "content": "The cue command can log various summary statistics about each evaluation it performs, in order to assist with the diagnosis of performance-related and other issues. The command logs statistics when the CUE_STATS_FILE environment variable is set to a filename. The filename is interpreted through the same rules that cue export applies to its --outfile argument, which are explained in cue help filetypes. Statistics for each evaluation are written into the named file using the file\u0026rsquo;s implied data format. The file is overwritten on each cue invocation, without confirmation. TERMINAL Copy code Copied! $ export CUE_STATS_FILE=stats.cue $ cue vet -c someFile.cue $ cat stats.cue CUE: { EvalVersion: 3 Unifications: 4 Disjuncts: 0 Conjuncts: 4 CloseIDElems: 0 NumCloseIDs: 0 Freed: 0 Reused: 0 Allocs: 4 Retained: 0 } Go: { AllocBytes: 1697648 AllocObjects: 12722 } Specifying the filename - causes cue to log statistics to its standard error stream as JSON. A different format may be selected using a qualifier prefix as outlined in cue help filetypes. For example: to emit YAML, specify yaml:-. Related content Issue #2856 tracks enhancements to the set of statistics captured by cue Reference: cue help filetypes",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["tooling","cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "d91f65d2ce78744b3947def4c1247a44_1",
        "title": "Marking a field as optional",
        "link": "/docs/howto/mark-a-field-as-optional/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates using an \u003cstrong\u003eoptional field\u003c/strong\u003e marker to constrain a field\u0026rsquo;s value -\n\u003cem\u003ebut only if it is present\u003c/em\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates using an optional field marker to constrain a field\u0026rsquo;s value - but only if it is present. Copied! schema.cue Copy code Copied! package example // CUE indicates optional fields with a question // mark: \u0026#34;?\u0026#34; // f1 is optional. If it is present it can be any // value f1?: _ // f-2 is optional. If it is present it must be a // string \u0026#34;f-2\u0026#34;?: string // s1 is a regular field containing a struct // which will be present no matter what the input // data contains s1: { // f3 is optional. If it is present it // must be an integer less than 10 f3?: int \u0026amp; \u0026lt;10 } Copied! data.yml Copy code Copied! # f1 is a nested struct f1: f1.1: f1.2: some string # f-2 is floating point number, not a string f-2: 42.137 # s1 only contains the field x, not f3. s1: x: some other string TERMINAL Copy code Copied! $ cue vet -c .:example data.yml \u0026#34;f-2\u0026#34;: conflicting values 42.137 and string (mismatched types float and string): ./data.yml:7:6 ./schema.cue:12:9 Related content Optional field constraints Commented CUE guides",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "faa04cd1079f48cf79f9dfd5747bfa21_1",
        "title": "Marking a field as required",
        "link": "/docs/howto/mark-a-field-as-required/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates using the \u003cstrong\u003erequired field\u003c/strong\u003e marker in a schema to make sure that a\nfield is present in data.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates using the required field marker in a schema to make sure that a field is present in data. Copied! schema.cue Copy code Copied! package example // CUE indicates required fields with an // exclamation mark: \u0026#34;!\u0026#34; // f1 is required, and can be any value f1!: _ // f-2 is required, and must be a string \u0026#34;f-2\u0026#34;!: string s1: { // f3 is required. It must be an integer // less than 10 f3!: int \u0026amp; \u0026lt;10 } Copied! data.yml Copy code Copied! f1: \u0026#34;some string value\u0026#34; # f-2: field is missing s1: f3: 7 TERMINAL Copy code Copied! $ cue vet -c .:example data.yml \u0026#34;f-2\u0026#34;: field is required but not present: ./schema.cue:10:1 Related content Required field constraints",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "99580537dc22380882493996abb46c5b_1",
        "title": "Mirroring modules between registries",
        "link": "/docs/howto/mirror-modules-between-registries/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cspan class=\"sidenote\"\u003eRequires CUE v0.13.0 or later\u003c/span\u003e\n\n\u003cp\u003eThis guide demonstrates how to use the\n\u003ca href=\"/docs/reference/command/cue-help-mod-mirror/\"\u003e\u003ccode\u003ecue mod mirror\u003c/code\u003e\u003c/a\u003e\ncommand to copy\n\u003ca href=\"/docs/reference/modules/\"\u003eCUE modules\u003c/a\u003e\nbetween registries.\u003c/p\u003e",
        "content": "Requires CUE v0.13.0 or later This guide demonstrates how to use the cue mod mirror command to copy CUE modules between registries. The cue mod mirror command is available in CUE v0.13.0 and later. It can be used to mirror modules between any pair of registries for which you have appropriate access permissions. The example shown here mirrors modules from the CUE Central Registry to a local, in-memory registry. The contents of this local registry are ephemeral: they disappear when it shuts down \u0026ndash; so don\u0026rsquo;t use this registry to store your important modules! 1Login to the Central Registry: TERMINAL Copy code Copied! $ cue login Our example uses the Central Registry as the source for modules to mirror, and it requires authentication. If you are mirroring modules from the Central Registry you need to login before continuing. 2Start the in-memory registry running in the background, listening on localhost port 55443: TERMINAL Copy code Copied! $ cue mod registry 127.0.0.1:55443 Every module mirrored to this ephemeral registry will disappear when you stop it. 3Copy the k8s.io curated module from the Central Registry to the local registry: TERMINAL Copy code Copied! $ cue mod mirror --to 127.0.0.1:55443 github.com/cue-tmp/jsonschema-pub/exp3/k8s.io mirroring github.com/cue-tmp/jsonschema-pub/exp3/k8s.io@v0.1.0 The cue mod mirror command copies each module from and to the appropriate registry for its module path \u0026ndash; which is usually the Central Registry, but can be configured differently (see cue help registryconfig for more information). In this example we overrode the configured destination registry using the --to flag. The --from flag can also be used to override the configured source registry. By default, cue mod mirror copies the latest version of each module specified, along with that version\u0026rsquo;s dependencies and all their transitive dependencies. This behaviour can be varied, as described by cue help mod mirror. Related content Reference: cue help mod mirror Reference: cue help registryconfig Reference: CUE Modules The CUE Central Registry",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["modules"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "b0437f625d2c519b8ce719107175f9a9_1",
        "title": "Modules, Packages, and Instances",
        "link": "/docs/concept/modules-packages-instances/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003cp\u003eThis guide describes \u0026ldquo;new\u0026rdquo; modules, which are the current implementation of\ndependencies in CUE.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/docs/concept/old-modules-packages-instances/\"\u003eThe previous version of this guide\u003c/a\u003e\ncovers \u0026ldquo;old\u0026rdquo; modules, which were the previous way to manage CUE dependencies,\nand is preserved for reference by folks using older versions of CUE.\nThe FAQ \u0026ldquo;\u003ca href=\"/docs/concept/faq/new-modules-vs-old-modules/\"\u003eNew modules vs old modules\u003c/a\u003e\u0026rdquo;\nexplains their differences.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"overview\"\u003e\n    \u003ca href=\"#overview\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eOverview\u003c/h2\u003e\n\u003cp\u003eCUE heavily relies on its order independence for package organization.\nDefinitions and constraints can be split across files within a package,\nand even organized across directories.\u003c/p\u003e\n\u003cp\u003eAnother key aspect of CUE\u0026rsquo;s package management is reproducibility.\nA module, the largest unit of organization, has a fixed location\nof all files and dependencies.\nThere are no paths to configure.\nWith configuration, reproducibility is key.\u003c/p\u003e\n\u003cp\u003eWithin a module, CUE organizes files grouped by package.\nA package can be defined within the module or externally.\nIn the latter case, CUE maintains a copy of the package within the module\nin a dedicated location.\u003c/p\u003e",
        "content": "This guide describes \u0026ldquo;new\u0026rdquo; modules, which are the current implementation of dependencies in CUE. The previous version of this guide covers \u0026ldquo;old\u0026rdquo; modules, which were the previous way to manage CUE dependencies, and is preserved for reference by folks using older versions of CUE. The FAQ \u0026ldquo;New modules vs old modules\u0026rdquo; explains their differences. Overview CUE heavily relies on its order independence for package organization. Definitions and constraints can be split across files within a package, and even organized across directories. Another key aspect of CUE\u0026rsquo;s package management is reproducibility. A module, the largest unit of organization, has a fixed location of all files and dependencies. There are no paths to configure. With configuration, reproducibility is key. Within a module, CUE organizes files grouped by package. A package can be defined within the module or externally. In the latter case, CUE maintains a copy of the package within the module in a dedicated location. For those familiar with Go packages CUE\u0026rsquo;s definitions of packages and modules are modeled after Go\u0026rsquo;s. Here is how they differ: The package clause is optional: such files do not belong to a package and cannot be imported. A package is identified by its import path and its package name, separated by a :. If its name is equal to the base of this path it may be omitted. There can be more than one package per directory. All files within a module with the same package name belong to the same package; an instance of such a package for a given directory contains all its files from that directory up till the module root. Modules A module contains a configuration laid out in a directory hierarchy. It contains everything that is needed to deterministically calculate the outcome of a CUE configuration. The root of this directory is marked by containing a cue.mod directory. The contents of this directory are mostly managed by the cue tool. In that sense, cue.mod is analogous to the .git directory marking the root directory of a repo, but where its contents are mostly managed by the git tool. The use of a module is optional, but required if one wants to import files. Creating a module A module can be created by running the following command within the module root: TERMINAL Copy code Copied! $ cue mod init A module path may be specified, but if it is omitted then a default value is used (currently cue.example). The module path is specified as an argument to the command: TERMINAL Copy code Copied! $ cue mod init some.module.prefix/with/optional/path/components@v0 The module path must be used in CUE code if a package within the module needs to import another package defined within the module. Module paths start with a fully-qualified domain name, continue with optional forward-slash-separated path components, and end with an optional major version suffix. If the optional major version suffix is omitted then the resulting module is treated as if the major version suffix @v0 were present. Ideally, the domain name and path components in a module path would map to a resource that\u0026rsquo;s controlled by the CUE user (e.g. a website, a version control repository, or similar), but this is not looked up or enforced by the cue command. A module can also be created by setting up the cue.mod directory and module.cue file manually. This is not recommended. The cue.mod directory The module directory has the following contents: Copy code Copied! cue.mod |-- module.cue // The module file |-- pkg // copies of external packages [DEPRECATED] |-- gen // files generated from external sources [DEPRECATED] |-- usr // user-defined constraints [DEPRECATED] This directory is predominantly managed by the cue tool. The module.cue file defines settings such as the module path, which allows packages defined within the module to be imported from within the module itself. It also holds version information of imported packages to determine the precise origin of imported files. The modules reference documentation fully specifies the contents of module.cue. Deprecated directories The pkg, gen and usr directories inside the cue.mod directory can hold packages that are facsimiles, derivatives, or augmentations of external packages. Use of these directories is deprecated as they interact poorly with shared dependencies (those managed by the cue mod command), and are not accessible if their containing module is used as a dependency. (To demonstrate this inaccessibility, consider the example situation where module A depends on module B; module B depends on module C; and module C is stored in module B\u0026rsquo;s pkg directory. Because module B uses this deprecated method for storing its dependency, module A cannot use any packages from module B\u0026rsquo;s copy of module C without independently declaring its own dependency on module C through cue mod, or its own pkg/usr/gen directories. If module B had instead declared the dependency using the cue mod command and the module.cue file, then module C would be accessible to module A through the shared module cache.) If a dependency is managed by the cue mod command but is also found in any of the pkg/gen/usr directories then an error occurs. These directories are still supported as they can be useful in a limited set of circumstances, but only when CUE\u0026rsquo;s current modules can\u0026rsquo;t handle a particular use-case. They are intended to be used for the following: pkg: manually managed and imported external packages gen: CUE generated from external definitions, such as protobuf or Go usr: user-defined constraints for external packages Read the FAQ \u0026ldquo;New modules vs old modules\u0026rdquo; to learn about the differences between these two types of CUE module. Please help the CUE project by providing your feedback in issue #2865 whenever you find yourself needing to use these deprecated directories - this will help guide and shape the future of the modules implementation. These three directories split files from the same package across different parallel hierarchies based on the origin of the content. But for all intent and purposes they should be seen as a single directory hierarchy. The usr directory is",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "b0437f625d2c519b8ce719107175f9a9_2",
        "title": "Modules, Packages, and Instances",
        "link": "/docs/concept/modules-packages-instances/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003cp\u003eThis guide describes \u0026ldquo;new\u0026rdquo; modules, which are the current implementation of\ndependencies in CUE.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/docs/concept/old-modules-packages-instances/\"\u003eThe previous version of this guide\u003c/a\u003e\ncovers \u0026ldquo;old\u0026rdquo; modules, which were the previous way to manage CUE dependencies,\nand is preserved for reference by folks using older versions of CUE.\nThe FAQ \u0026ldquo;\u003ca href=\"/docs/concept/faq/new-modules-vs-old-modules/\"\u003eNew modules vs old modules\u003c/a\u003e\u0026rdquo;\nexplains their differences.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"overview\"\u003e\n    \u003ca href=\"#overview\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eOverview\u003c/h2\u003e\n\u003cp\u003eCUE heavily relies on its order independence for package organization.\nDefinitions and constraints can be split across files within a package,\nand even organized across directories.\u003c/p\u003e\n\u003cp\u003eAnother key aspect of CUE\u0026rsquo;s package management is reproducibility.\nA module, the largest unit of organization, has a fixed location\nof all files and dependencies.\nThere are no paths to configure.\nWith configuration, reproducibility is key.\u003c/p\u003e\n\u003cp\u003eWithin a module, CUE organizes files grouped by package.\nA package can be defined within the module or externally.\nIn the latter case, CUE maintains a copy of the package within the module\nin a dedicated location.\u003c/p\u003e",
        "content": "a bit special here. The gen directory is populated by the cue tool and the pkg directory, whilst deprecated, can hold 3rd-party or external constraints. The usr directory, on the other hand, holds user-defined constraints for the packages defined in the other directories. User-defined constraints can be used to fill gaps in generated constraints; as generation is not always a sure thing. They can also be used to enforce constraints on imported packages, for instance to enforce that a certain API feature is still provided or of the desired form. The usr directory allows for a cleaner organization compared to storing such user-defined constraints directly in the cue-managed directories. Packages Files belonging to a package CUE files may define a package name at the top of their file. CUE uses this to determine which files belong together. If the cue tool is told to load the files for a specific directory, for instance: Copy code Copied! cue eval ./mypkg it will only look files with such a clause and ignore files without it. If the package name within the directory is not unique, cue needs to know the name of the package as well Copy code Copied! cue eval ./mypkg:packageName If no module is defined then the cue command will only load the files in the current directory. If a module is defined then it will also load all files with the same package name in its ancestor directories up to the module root. As we will see below, this strategy allows for defining organization-wide schemas and policies. Import path Each package is identified by a globally unique name, called its import path. The import path consists of a unique location identifier followed by a colon (:) and its package name. Copy code Copied! k8s.io/api/core/v1:v1 If the basename of the path and the package name are the same, the latter can be omitted. Copy code Copied! k8s.io/api/core/v1 The unique location identifier consists of a domain name followed by a path. Modules themselves also have a unique location identifier. A package inside a module can import another package from this same module by using the following import path: Copy code Copied! \u0026lt;module identifier\u0026gt;/\u0026lt;relative position of package within module\u0026gt;:\u0026lt;package name\u0026gt; So suppose our module is identified as example.com/transport and a package located at schemas/trains and has the package name track, then other packages can import this packages as: Copy code Copied! import \u0026#34;example.com/transport/schemas/trains:track\u0026#34; Putting it all together: Copy code Copied! root // must contain: |-- cue.mod | |-- module.cue // module: \u0026#34;example.com/transport\u0026#34; |-- schemas | |-- trains | | |-- track.cue // package track ... |-- data.cue // import \u0026#34;example.com/transport/schemas/trains:track\u0026#34; The relative position may not be within the cue.mod directory. Location on disk CUE code can import a package by specifying its import path with the import statement. For instance, Copy code Copied! import ( \u0026#34;list\u0026#34; \u0026#34;example.com/path/to/package\u0026#34; ) Packages for which the first path component is not a fully qualified domain name are builtin packages and are not stored on disk, as with list in the example above. Any CUE code can import builtin packages, whether part of a module or not. In contrast, CUE code can only import non-builtin packages when that CUE code is part of a module. When a non-builtin package is imported, CUE determines its location on disk using several mechanisms in parallel: If the module path is a prefix of the import path, then that prefix is removed from the import path and the remainder of the import path is treated as a directory path. If a package exists in that directory, relative to the module root, then the package is located in that directory. If a dependency of the current module declares a module path that has the current module path as a prefix then: the dependency is fetched from the configured module registry if it\u0026rsquo;s not already present in the shared module cache; taking the dependency\u0026rsquo;s module path into account, the directory inside the dependency that matches the import path is examined; if that directory contains a package then the package is located in that directory. The package contents are looked up in the deprecated cue.mod/pkg, cue.mod/gen, and cue.mod/usr directories. If a package is found in any of these deprecated directories then the package content is unified from the relevant files across all of these directories. If only one of these three mechanisms discovers an appropriate directory location then that directory location (and its package content) is used. If more than one of these mechanisms discovers an appropriate directory location then an error occurs. If none of these mechanisms discovers an appropriate directory location then an error occurs. Builtin Packages CUE has a standard library of builtin packages that are compiled into the cue command. A list of these packages can be found at pkg.go.dev/cuelang/go/pkg. The intention is to have this documentation in CUE format, but for now we are piggybacking on the Go infrastructure to host and present the CUE standard library documentatation. To use a builtin package, import its path relative to cuelang.org/go/pkg and invoke the functions using its qualified identifier. For instance: Copied! stdlib.cue Copy code Copied! package example import \u0026#34;strings\u0026#34; A: \u0026#34;Hello, world!\u0026#34; B: strings.ToUpper(A) C: strings.HasPrefix(B, \u0026#34;HELLO\u0026#34;) TERMINAL Copy code Copied! $ cue eval A: \u0026#34;Hello, world!\u0026#34; B: \u0026#34;HELLO, WORLD!\u0026#34; C: true File Organization Instances Within a module, all .cue files with the same package name are part of the same package. A package is evaluated within the context of a certain directory. Within this context, only the files belonging to that package in that directory and its ancestor directories within the module are combined. We call that an instance of a package. Using this approach, the different kind of directories within a module can be ascribed the following roles: module root: schema medial directories: policy leaf directories: data The top of the hierarchy (the module root) defines constraints that apply across the organization. Leaf directories typically define concrete instances, inheriting all the constraints of ancestor directories. Directories between the",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "b0437f625d2c519b8ce719107175f9a9_3",
        "title": "Modules, Packages, and Instances",
        "link": "/docs/concept/modules-packages-instances/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003cp\u003eThis guide describes \u0026ldquo;new\u0026rdquo; modules, which are the current implementation of\ndependencies in CUE.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/docs/concept/old-modules-packages-instances/\"\u003eThe previous version of this guide\u003c/a\u003e\ncovers \u0026ldquo;old\u0026rdquo; modules, which were the previous way to manage CUE dependencies,\nand is preserved for reference by folks using older versions of CUE.\nThe FAQ \u0026ldquo;\u003ca href=\"/docs/concept/faq/new-modules-vs-old-modules/\"\u003eNew modules vs old modules\u003c/a\u003e\u0026rdquo;\nexplains their differences.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"overview\"\u003e\n    \u003ca href=\"#overview\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eOverview\u003c/h2\u003e\n\u003cp\u003eCUE heavily relies on its order independence for package organization.\nDefinitions and constraints can be split across files within a package,\nand even organized across directories.\u003c/p\u003e\n\u003cp\u003eAnother key aspect of CUE\u0026rsquo;s package management is reproducibility.\nA module, the largest unit of organization, has a fixed location\nof all files and dependencies.\nThere are no paths to configure.\nWith configuration, reproducibility is key.\u003c/p\u003e\n\u003cp\u003eWithin a module, CUE organizes files grouped by package.\nA package can be defined within the module or externally.\nIn the latter case, CUE maintains a copy of the package within the module\nin a dedicated location.\u003c/p\u003e",
        "content": "leaf and top directory define constraints, like policies, that only apply to its subdirectories. Because order of evaluation does not matter in CUE, leaf packages do not explicitly have to specify which parts of their parents they want to inherit from. Instead, parent directories can be seen to \u0026ldquo;push out\u0026rdquo; constraints to their subdirectories. In other words, parent directories define policies to which subdirectories must comply.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "e187d1a6e5f03faa0cb7fda176cdb194_1",
        "title": "Negating a disjunction",
        "link": "/docs/howto/negate-a-disjunction/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to negate a disjunction. This allows a field to be constrained\nsuch that evaluation is only successful if the field\u0026rsquo;s value would \u003cstrong\u003enot\u003c/strong\u003e be\npermitted by the disjunction.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to negate a disjunction. This allows a field to be constrained such that evaluation is only successful if the field\u0026rsquo;s value would not be permitted by the disjunction. Copied! example.cue Copy code Copied! package example // This disjunction permits a single value from a // small set of options. #OneTwoThree: \u0026#34;one\u0026#34; | \u0026#34;two\u0026#34; | \u0026#34;three\u0026#34; A: \u0026#34;three\u0026#34; B: \u0026#34;four\u0026#34; // These hidden fields ensure that the data fields // they reference do not contain values permitted // by the #OneTwoThree disjunction. _A_ok: true \u0026amp; ((A \u0026amp; #OneTwoThree) == _|_) _B_ok: true \u0026amp; ((B \u0026amp; #OneTwoThree) == _|_) TERMINAL Copy code Copied! $ cue vet -c _A_ok: conflicting values false and true: ./example.cue:13:8 ./example.cue:13:16 The method of negating a disjunction shown in this guide is likely to be replaced by a constraint using a more specific and precise builtin when issue #943 is implemented. The builtins mentioned in that issue are not yet available, but we mention them here to help guide the implementation choices you make in the interim.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["validation","commented cue"],
        "authors": ["hansbogert"]
    },
    
            {
        "objectID": "dfc6b6c0c468e60abb27fe7ab87b695f_1",
        "title": "New modules vs old modules",
        "link": "/docs/concept/faq/new-modules-vs-old-modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ca href=\"/releases/v0.9.0\"\u003ev0.9.0\u003c/a\u003e release of CUE\nmade \u0026ldquo;new\u0026rdquo; modules the default \u0026hellip; but\nwhat \u003cem\u003eare\u003c/em\u003e \u0026ldquo;new\u0026rdquo; modules, and\nwhat were \u0026ldquo;old\u0026rdquo; modules?\nWhat\u0026rsquo;s the difference between them, and\ncan we still use the \u0026ldquo;old\u0026rdquo; ones?\u003c/p\u003e\n\u003cp\u003eThis guide answers those frequently-asked questions,\nand includes extra information about CUE\u0026rsquo;s transition from \u0026ldquo;old\u0026rdquo; to \u0026ldquo;new\u0026rdquo;\nmodules \u0026ndash; and how the transition affects your CUE.\u003c/p\u003e",
        "content": "The v0.9.0 release of CUE made \u0026ldquo;new\u0026rdquo; modules the default \u0026hellip; but what are \u0026ldquo;new\u0026rdquo; modules, and what were \u0026ldquo;old\u0026rdquo; modules? What\u0026rsquo;s the difference between them, and can we still use the \u0026ldquo;old\u0026rdquo; ones? This guide answers those frequently-asked questions, and includes extra information about CUE\u0026rsquo;s transition from \u0026ldquo;old\u0026rdquo; to \u0026ldquo;new\u0026rdquo; modules \u0026ndash; and how the transition affects your CUE. What do you mean by \u0026ldquo;old\u0026rdquo; and \u0026ldquo;new\u0026rdquo; modules? The concept of a module has existed since the early days of CUE, but its initial support for modules was very primitive. Dependencies needed to be downloaded manually and then copied, by hand, into the cue.mod/{gen,pkg,usr} directories. There was no native tooling for fetching modules from a remote store, or for publishing them in the first place. Native module support within the CUE toolchain and APIs was missing, and everything was very minimal and extremely manual. We refer to this original behaviour as the \u0026ldquo;old\u0026rdquo; modules implementation. To address the shortcomings of the old modules implementation, we went through a number of design and proposal iterations. These culminated in the modules proposal v3, which was accompanied by an experimental implementation in pre-releases of the v0.8.x series from version v0.8.0-alpha.1 in February 2024. Old modules remained the default behaviour at this time, but the experimental implementation could be enabled by setting the environment variable CUE_EXPERIMENT=modules. In May 2024, after extensive testing and feedback from users, the modules proposal v3 was accepted. At this time we started referring to the experimental implementation that supported the v3 proposal as \u0026ldquo;new\u0026rdquo; modules, to reflect the change away from it being an experiment. The default behaviour was still that of old modules, with \u0026ldquo;new\u0026rdquo; modules being enabled using the same CUE_EXPERIMENT=modules environment variable as before. At the start of June 2024 CUE v0.9.0 was released. It changed CUE\u0026rsquo;s default behaviour - new modules were now enabled out of the box. This removed the need to enable them manually, but folks needing old modules in CUE v0.9.x or v0.10.x could set CUE_EXPERIMENT=modules=0 to revert to the old behaviour. The first pre-release for v0.11.0 dropped support for old modules: setting CUE_EXPERIMENT=modules=0 causes an error with all CUE versions starting from v0.11.0-alpha.1. Modules? Where do I get started? Working with modules and the Central Registry and Working with a custom module registry present an easy-to-digest introduction to modules. The modules tag lists other modules-related content. The CUE Modules reference is the definitive document that details how modules work. What is the Central Registry? The Central Registry at registry.cue.works is currently in beta testing, and will be a well-known place for schemas for well-known services and projects. We will share more details about the Central Registry in the future. For now, we are looking to get early feedback - please come and discuss it in the #modules channel on Slack or on Discord. Why do I need to run cue mod fix? v0.9.0 requires that language.version is declared in the cue.mod/module.cue file. Running cue mod fix does this automatically for you. It also moves unrecognized top-level fields to a custom.legacy field. If you already have a language.version field, then cue mod fix is a no-op in this regard. Why is language.version now required? With v0.9.0, CUE requires that a language version be declared in a cue.mod/module.cue file: Copied! cue.mod/module.cue Copy code Copied! module: \u0026#34;mod.example/hello@v0\u0026#34; language: version: \u0026#34;v0.9.0\u0026#34; When running cue mod init to create a new module, this line is added automatically. Where a language.version field is missing, CUE will error and suggest that you use cue mod fix to add it. This transition started with v0.8.0 when the field was introduced and started being added by cue mod init. By now requiring a language version, CUE is more closely following an approach like Go when it comes to forwards compatibility. This means that modules depending on any upcoming language changes or changes in semantics can declare a minimum version of CUE required to evaluate that code. Similarly, evaluating an older CUE module can be done with the knowledge that it was written against an older version of the CUE language spec and semantics. See the Modules reference document for an explanation of the various fields in a cue.mod/module.cue file. What about old modules that don\u0026rsquo;t have a language.version field? In some cases, the above suggestion to use cue mod fix to migrate the module.cue file might not be possible. This might happen, for example, if you are using the CUE Go API and need to interpret older CUE code. There is now an AcceptLegacyModules field in the cue/load.Config struct that can direct the loader to fix the main module\u0026rsquo;s module.cue file automatically without the need to change it on disk. Why do I need to specify a source to publish a module? cue mod publish needs to determine what files to include in a published module. Rather than rely on implicit heuristics such as whether a VCS exists or is installed,to determine whether the file list should be determined from the files on disk, or from the contents of a Git commit, we require the module author to be explicit. How do I configure which OCI registry is used for publishing/fetching modules? As explained by cue help environment, the CUE_REGISTRY environment variable determines the configuration to use when downloading and publishing modules. See cue help registryconfig for details. Where can I find out more about modules commands? See cue help mod. What about tag injection? Tag injection remains similar in the new module implementation, with the notable exception of @if attributes. Specifically: tags are injected only into packages explicitly mentioned on the command line or as explicit packages to cue/load.Instances. (This behavior has not changed from versions of CUE before v0.9) @if attributes only process tags when they are in files inside the main module. In any external module, all tags are considered to be false. This is a change from earlier versions, when there was no distinction between the main module and external modules. Can I use \u0026ldquo;cue.mod/usr\u0026rdquo;",
        "breadcrumb": ["Documentation","Concept Guides","Frequently Asked Questions"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "dfc6b6c0c468e60abb27fe7ab87b695f_2",
        "title": "New modules vs old modules",
        "link": "/docs/concept/faq/new-modules-vs-old-modules/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ca href=\"/releases/v0.9.0\"\u003ev0.9.0\u003c/a\u003e release of CUE\nmade \u0026ldquo;new\u0026rdquo; modules the default \u0026hellip; but\nwhat \u003cem\u003eare\u003c/em\u003e \u0026ldquo;new\u0026rdquo; modules, and\nwhat were \u0026ldquo;old\u0026rdquo; modules?\nWhat\u0026rsquo;s the difference between them, and\ncan we still use the \u0026ldquo;old\u0026rdquo; ones?\u003c/p\u003e\n\u003cp\u003eThis guide answers those frequently-asked questions,\nand includes extra information about CUE\u0026rsquo;s transition from \u0026ldquo;old\u0026rdquo; to \u0026ldquo;new\u0026rdquo;\nmodules \u0026ndash; and how the transition affects your CUE.\u003c/p\u003e",
        "content": "with new modules? Technically, yes: you can. However, there\u0026rsquo;s one very important caveat that you need to be aware of: if a module dependency is declared in your cue.mod/module.cue file (in the deps field), then packages from the module that CUE needs to resolve cannot exist in any of the cue.mod/{pkg,gen,usr} directories. If you try to declare and define a package in both \u0026ldquo;old\u0026rdquo; and \u0026ldquo;new\u0026rdquo; locations then an error will ocurr: Copy code Copied! mod.example@v0: import failed: cannot find package \u0026#34;github.com/cue-labs/examples/frostyconfig@v0\u0026#34;: ambiguous import: found package github.com/cue-labs/examples/frostyconfig@v0 in multiple modules: github.com/cue-labs/examples/frostyconfig@v0 v0.0.1 (.) local (cue.mod/usr/github.com/cue-labs/examples/frostyconfig): Essentially, in this scenario, the CUE loader is unable to determine which package definition \u0026ldquo;wins\u0026rdquo;. Because of this, old and new modules are mutually exclusive at the individual package level. We continue to support cue.mod/{pkg,gen,usr} for now, as we continue our efforts to improve the CUE module ecosystem. In particular, we are looking to better understand how to support: generated CUE modules (old modules: cue.mod/gen); and user augmentations for dependencies/generated CUE modules (old modules: cue.mod/usr). Work on the Central Registry is a key part of these goals. We welcome and encourage you to share your experiences and use cases for either of these features in issue #2865.",
        "breadcrumb": ["Documentation","Concept Guides","Frequently Asked Questions"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "c19a7255ff940b9fa0719f3b962a2629_1",
        "title": "Old Modules, Packages, and Instances",
        "link": "/docs/concept/old-modules-packages-instances/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--caution\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003cp\u003eThis guide describes \u0026ldquo;old\u0026rdquo; modules, which were the previous implementation of\ndependencies in CUE. It\u0026rsquo;s preserved here for folks using previous versions of\nCUE, but \u003cstrong\u003eif you are using CUE v0.9.0 or later\u003c/strong\u003e then you are probably using\n\u0026ldquo;new\u0026rdquo; modules and \u003cstrong\u003eyou don\u0026rsquo;t need to read this page\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eThe current version of this guide\u003c/a\u003e\ncovers \u0026ldquo;new\u0026rdquo; modules, which are the current and recommended way to manage CUE\ndependencies.\nThe FAQ \u0026ldquo;\u003ca href=\"/docs/concept/faq/new-modules-vs-old-modules/\"\u003eNew modules vs old modules\u003c/a\u003e\u0026rdquo;\nexplains their differences.\u003c/p\u003e\n\u003cp\u003eWe suggest you start by reading the\n\u003ca href=\"/docs/concept/modules/\"\u003emodules concept guide\u003c/a\u003e to learn more about modules.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
        "content": "This guide describes \u0026ldquo;old\u0026rdquo; modules, which were the previous implementation of dependencies in CUE. It\u0026rsquo;s preserved here for folks using previous versions of CUE, but if you are using CUE v0.9.0 or later then you are probably using \u0026ldquo;new\u0026rdquo; modules and you don\u0026rsquo;t need to read this page. The current version of this guide covers \u0026ldquo;new\u0026rdquo; modules, which are the current and recommended way to manage CUE dependencies. The FAQ \u0026ldquo;New modules vs old modules\u0026rdquo; explains their differences. We suggest you start by reading the modules concept guide to learn more about modules. Overview CUE heavily relies on its order independence for package organization. Definitions and constraints can be split across files within a package, and even organized across directories. Another key aspect of CUE\u0026rsquo;s package management is reproducibility. A module, the largest unit of organization, has a fixed location of all files and dependencies. There are no paths to configure. With configuration, reproducibility is key. Within a module, CUE organizes files grouped by package. A package can be defined within the module or externally. In the latter case, CUE maintains a copy of the package within the module in a dedicated location. For those familiar with Go packages CUE\u0026rsquo;s definitions of packages and modules are modeled after Go\u0026rsquo;s. Here is how they differ: The package clause is optional: such files do not belong to a package and cannot be imported. A package is identified by its import path and its package name, separated by a :. If its name is equal to the base of this path it may be omitted. There can be more than one package per directory. All files within a module with the same package name belong to the same package; an instance of such a package for a given directory contains all its files from that directory up till the module root. Modules A module contains a configuration layed out in a directory hierarchy. It contains everything that is needed to deterministically determine the outcome of a CUE configuration. The root of this directory is marked by containing a cue.mod directory. The contents of this directory are mostly managed by the cue tool. In that sense, cue.mod is analogous to the .git directory marking the root directory of a repo, but where its contents are mostly managed by the git tool. The use of a module is optional, but required if one wants to import files. Creating a module A module can be created by running the following command within the module root: Copy code Copied! cue mod init [module name] The module name is required if a package within the module needs to import another package within the module. A module can also be created by setting up the cue.mod directory and module.cue file manually. The cue.mod directory The module directory has the following contents: Copy code Copied! cue.mod |-- module.cue // The module file |-- pkg // copies of external packages |-- gen // files generated from external sources |-- usr // user-defined constraints Aside from an occasional addition to the usr subdirectory or tweak to module.cue, this directory is predominantly managed by the cue tool. The module.cue file defines settings such as globally unique module identifier (more on this in the Import Path section). This information allows packages defined within the module to be importable within the module itself. In the future, it may hold version information of imported packages to determine the precise origin of imported files. The other directories hold packages that are facsimiles, derivatives, or augmentations of external packages: pkg: an imported external CUE package, gen: CUE generated from external definitions, such as protobuf or Go, usr: user-defined constraints for the above two directories. These directories split files from the same package across different parallel hierarchies based on the origin of the content. But for all intent and purposes they should be seen as a single directory hierarchy. The cue.mod/usr directory is a bit special here. The cue.mod/pkg and cue.mod/gen directories are populated by the cue tool. The cue.mod/usr directory, on the other hand, holds user-defined constraints for the packages defined in the other directories. User-defined constraints can be used to fill gaps in generated constraints; as generation is not always a sure thing. They can also be used to enforce constraints on imported packages, for instance to enforce that a certain API feature is still provided or of the desired form. The usr directory allows for a cleaner organization compared to storing such user-defined constraints directly in the cue-managed directories. Packages Files belonging to a package CUE files may define a package name at the top of their file. CUE uses this to determine which files belong together. If the cue tool is told to load the files for a specific directory, for instance: Copy code Copied! cue eval ./mypkg it will only look files with such a clause and ignore files without it. If the package name within the directory is not unique, cue needs to know the name of the package as well Copy code Copied! cue eval ./mypkg:pkgname If no module is defined, it will just load the files in this directory. If a module is defined, it will also load all files with the same package name in its ancestor directories up till the module root. As we will see below, this strategy allows for defining organization-wide schemas and policies. Import path Each package is identified by a globally unique name, called its import path. The import path consists of a unique location identifier followed by a colon (:) and its package name. Copy code Copied! k8s.io/api/core/v1:v1 If the basename of the path and the package name are the same, the latter can be omitted. Copy code Copied! k8s.io/api/core/v1 The unique location identifier consists of a domain name followed by a path. Modules themselves also have a unique location identifier. A package inside a module can import another package from this same module by using the following import path: Copy code Copied! \u0026lt;module",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "c19a7255ff940b9fa0719f3b962a2629_2",
        "title": "Old Modules, Packages, and Instances",
        "link": "/docs/concept/old-modules-packages-instances/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--caution\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003cp\u003eThis guide describes \u0026ldquo;old\u0026rdquo; modules, which were the previous implementation of\ndependencies in CUE. It\u0026rsquo;s preserved here for folks using previous versions of\nCUE, but \u003cstrong\u003eif you are using CUE v0.9.0 or later\u003c/strong\u003e then you are probably using\n\u0026ldquo;new\u0026rdquo; modules and \u003cstrong\u003eyou don\u0026rsquo;t need to read this page\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/docs/concept/modules-packages-instances/\"\u003eThe current version of this guide\u003c/a\u003e\ncovers \u0026ldquo;new\u0026rdquo; modules, which are the current and recommended way to manage CUE\ndependencies.\nThe FAQ \u0026ldquo;\u003ca href=\"/docs/concept/faq/new-modules-vs-old-modules/\"\u003eNew modules vs old modules\u003c/a\u003e\u0026rdquo;\nexplains their differences.\u003c/p\u003e\n\u003cp\u003eWe suggest you start by reading the\n\u003ca href=\"/docs/concept/modules/\"\u003emodules concept guide\u003c/a\u003e to learn more about modules.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
        "content": "identifier\u0026gt;/\u0026lt;relative position of package within module\u0026gt;:\u0026lt;package name\u0026gt; So suppose our module is identified as example.com/transport and a package located at schemas/trains and has the package name track, then other packages can import this packages as: Copy code Copied! import \u0026#34;example.com/transport/schemas/trains:track\u0026#34; Putting it all together: Copy code Copied! root // must contain: |-- cue.mod | |-- module.cue // module: \u0026#34;example.com/transport\u0026#34; |-- schemas | |-- trains | | |-- track.cue // package track ... |-- data.cue // import \u0026#34;example.com/transport/schemas/trains:track\u0026#34; The relative position may not be within the cue.mod directory. Location on disk A .cue file can import a package by specifying its import path with the import statement. For instance, Copy code Copied! import ( \u0026#34;list\u0026#34; \u0026#34;example.com/path/to/package\u0026#34; ) Packages for which the first path component is not a fully qualified domain name are builtin packages and are not stored on disk. For other packages, CUE determines the location on disk as follows: If a module identifier is defined and is a prefix of the import path, the package is located at the corresponding location relative to the module root. Otherwise, the package contents looked up in the cue.mod/pkg, cue.mod/gen, and cue.mod/usr subdirectores. In Step 2, an import path may match more than one directory. In that case, the contents of all matched directories are used to build the package. Virtually, these directories should be seen as a single directory tree. Builtin Packages CUE has a collection of builtin packages that are compiled into the .cue binary. A list of these packages form can be found here https://pkg.go.dev/cuelang.org/go/pkg. The intention is to have this documentation in CUE format, but for now we are piggybacking on the Go infrastructure to host and present the CUE packages. To use a builtin package, import its path relative to cuelang.org/go/pkg and invoke the functions using its qualified identifier. For instance: Copied! regexp.cue Copy code Copied! import \u0026#34;regexp\u0026#34; matches: regexp.FindSubmatch(#\u0026#34;^([^:]*):(\\d+)$\u0026#34;#, \u0026#34;localhost:443\u0026#34;) TERMINAL Copy code Copied! $ cue eval regexp.cue matches: [\u0026#34;localhost:443\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;443\u0026#34;] File Organization Instances Within a module, all .cue files with the same package name are part of the same package. A package is evaluated within the context of a certain directory. Within this context, only the files belonging to that package in that directory and its ancestor directories within the module are combined. We call that an instance of a package. Using this approach, the different kind of directories within a module can be ascribed the following roles: module root: schema medial directories: policy leaf directories: data The top of the hierarchy (the module root) defines constraints that apply across the organization. Leaf directories typically define concrete instances, inheriting all the constraints of ancestor directories. Directories between the leaf and top directory define constraints, like policies, that only apply to its subdirectories. Because order of evaluation does not matter in CUE, leaf packages do not explicitly have to specify which parts of their parents they want to inherit from. Instead, parent directories can be seen to \u0026ldquo;push out\u0026rdquo; constraints to their subdirectories. In other words, parent directories define policies to which subdirectories must comply.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["modules"],
        "authors": ""
    },
    
            {
        "objectID": "fc8481f6e198b5600de9c873ad251f21_1",
        "title": "Placing data files at different locations using file embedding",
        "link": "/docs/howto/place-data-files-different-locations-file-embedding/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE v0.12.0 introduced\n\u003ca href=\"/docs/reference/command/cue-help-embed/\"\u003efile embedding\u003c/a\u003e,\nwhich enables a powerful way for CUE configurations to consume data files.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates how to use file embedding as a flexible alternative to the\n\u003ca href=\"/docs/concept/using-the-cue-export-command/inputs/#non-cue-data-location\"\u003e\u003ccode\u003e--path\u003c/code\u003e/\u003ccode\u003e-l\u003c/code\u003e flag\u003c/a\u003e\nwhen handling multiple data files:\nallowing their contents to be placed at arbitrary locations in an evaluation;\nto be validated by different constraints;\nand to have their data used elsewhere in the configuration.\u003c/p\u003e",
        "content": "CUE v0.12.0 introduced file embedding, which enables a powerful way for CUE configurations to consume data files. This guide demonstrates how to use file embedding as a flexible alternative to the --path/-l flag when handling multiple data files: allowing their contents to be placed at arbitrary locations in an evaluation; to be validated by different constraints; and to have their data used elsewhere in the configuration. Copied! file.cue Copy code Copied! @extern(embed) package example // Embed the contents of the data files. _places: _ @embed(file=addresses.yml) _dates: _ @embed(file=birthdays.json) // Validate the contents of the data files. _places: [_]: [string, ...string] _dates: [_]: =~#\u0026#34;^\\d{4}-\\d{2}-\\d{2}$\u0026#34;# // Emit the selected data. jamie: { address: _places.jamie birthday: _dates.jamie } Copied! addresses.yml Copied! birthdays.json Copy code Copied! jamie: - 1 Main Street - Townsville - West Fooshire alex: - 42 The Parade - Village-on-the-Wold - Countyshire Copy code Copied! { \u0026#34;alex\u0026#34;: \u0026#34;1984-02-29\u0026#34;, \u0026#34;jamie\u0026#34;: \u0026#34;2000-01-01\u0026#34;, \u0026#34;charlie\u0026#34;: \u0026#34;1950-06-26\u0026#34; } TERMINAL Copy code Copied! $ cue export --out yaml jamie: address: - 1 Main Street - Townsville - West Fooshire birthday: \u0026#34;2000-01-01\u0026#34; Related content Reference: cue help embed How-to Guide: Embedding files in a CUE evaluation",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "f02b093966392ca0756d3794b1ad043d_1",
        "title": "Placing data using the Go API",
        "link": "/docs/howto/place-data-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ccode\u003ecue\u003c/code\u003e command allows non-CUE data to be \u0026ldquo;placed\u0026rdquo; at a specific location in\nits evaluation with the \u003ccode\u003e--path\u003c/code\u003e/\u003ccode\u003e-l\u003c/code\u003e flag.\nThis guide demonstrates how to achieve the same result using the Go API.\u003c/p\u003e",
        "content": "The cue command allows non-CUE data to be \u0026ldquo;placed\u0026rdquo; at a specific location in its evaluation with the --path/-l flag. This guide demonstrates how to achieve the same result using the Go API. Set up the environment 1If you don\u0026rsquo;t already have CUE or Go modules, initialize them: TERMINAL Copy code Copied! $ cue mod init cue.example $ go mod init go.example ... Create some data files 2Write some CUE code and JSON data (if you don\u0026rsquo;t already have some code that you want to update and use): Copied! some.cue Copy code Copied! package example // The data will be placed at this location. input: { name!: string location: *\u0026#34;your part of the world\u0026#34; | string } output: \u0026#34;\u0026#34;\u0026#34; Hello, \\(input.name)! How\u0026#39;s the weather in \\(input.location)? \u0026#34;\u0026#34;\u0026#34; Copied! input.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Charlie\u0026#34; } 3Check that the data file can be combined successfully with the CUE: TERMINAL Copy code Copied! $ cue export . input.json --path input: -e output --out text Hello, Charlie! How\u0026#39;s the weather in your part of the world? Write some Go 4Write a Go program that places the data in the input.json file at a specific location within its CUE evaluation (or adapt your existing code to do the same): Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; \u0026#34;cuelang.org/go/encoding/json\u0026#34; ) func main() { ctx := cuecontext.New() // Load the package in the current directory. bis := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) v := ctx.BuildInstance(bis[0]) // Load the input data. jsonBytes, err := os.ReadFile(\u0026#34;input.json\u0026#34;) if err != nil { log.Fatal(err) } // Parse the input data to a CUE expression. jsonData, err := json.Extract(\u0026#34;input.json\u0026#34;, jsonBytes) if err != nil { log.Fatal(err) } // Place the parsed data as the value of the \u0026#34;input\u0026#34; field. complete := v.FillPath(cue.ParsePath(\u0026#34;input\u0026#34;), jsonData) // Extract the string value of the \u0026#34;output\u0026#34; field and print it. output := complete.LookupPath(cue.ParsePath(\u0026#34;output\u0026#34;)) msg, _ := output.String() // We know that \u0026#34;output\u0026#34; is a string type. fmt.Printf(\u0026#34;%v\\n\u0026#34;, msg) } Run the program 5Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... 6Run the program, printing the same multi-line string value that cue produced earlier: TERMINAL Copy code Copied! $ go run . Hello, Charlie! How\u0026#39;s the weather in your part of the world? Related content Concept Guide: How CUE works with Go All pages tagged with go api",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["go api"],
        "authors": ["myitcv","jpluscplusm"]
    },
    {
        "objectID": "8654ef41de81deef0cd862602895912d_1",
        "title": "Privacy policy",
        "link": "/privacy-policy/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe protection of your privacy and the confidentiality of your personal data are\nof particular concern to us. We therefore explain to you below which of your\ndata we process, for which purpose and what rights you have in this context.\u003c/p\u003e\n\u003cp\u003eWe comply with the applicable data protection laws, in particular the Swiss Data\nProtection Act (FADP; revised as of September 1, 2023) and the associated Data\nProtection Ordinance (FODP). Where applicable, we also comply with the\nrequirements of the European General Data Protection Regulation (GDPR).\u003c/p\u003e",
        "content": "The protection of your privacy and the confidentiality of your personal data are of particular concern to us. We therefore explain to you below which of your data we process, for which purpose and what rights you have in this context. We comply with the applicable data protection laws, in particular the Swiss Data Protection Act (FADP; revised as of September 1, 2023) and the associated Data Protection Ordinance (FODP). Where applicable, we also comply with the requirements of the European General Data Protection Regulation (GDPR). 1 Data controller and contact The data controller responsible for the processing of the personal data according to this privacy policy is: CUE Labs Ltd, Gotthardstrasse 28, 6300 Zug, Switzerland. If you have any questions or concerns in connection with this privacy policy, the following person can be contacted: CUE Labs Ltd, Gotthardstrasse 28, 6300 Zug, contact@cue.dev 2 Processing activities This privacy policy applies to the following processing activities: Visiting our websites which display or link to this privacy policy (Websites); Registering for and using our services and products (e.g. CUE Unity, Central Registry, consulting and/or support contracts) (Services); Interacting with the CUE open-source project and community e.g. via GitHub, Slack, Discord and social media channels; Signing up to communications and receiving communications from us, including emails or texts; Registering for and participating in our events, including community calls and office hours. Our Websites and Services may contain links to other websites, applications and services maintained by third parties. The information practices of such other services are governed by their respective third-party privacy policy, which we encourage you to review to understand those third parties privacy practices. 3 Receipt and categories of personal data, nature, and purpose of processing 3.1 Receipt of personal data We primarily process personal data that we receive from you, business partners and other people involved in the context of our business relationship with them, and we process the data in order to carry out our business activities. 3.2 Categories of personal data We process the following categories of personal data: From users and customers of our Services: name, email, role, company name, location, user data (e.g. IP address, GitHub name), usage of our Services (e.g. content and code you upload or download, how you interact with the Services), payment, transaction, and billing information/history, communications and interactions you have with us. From business partners: name, email, role, company name, location, payment, transaction, and billing information/history, communications and interactions you have with us. From visitors of our website cuelang.org: No personal data is collected. From visitors of our Websites except cuelang.org: Visitor data like IP address, location data, operating system, device data, previously visited website, and general Website usage data, like sites you visit on our Websites, time you spend on sites, navigation paths, search queries, information you provide in forms, user behavior etc. while for not technical necessary information we only process such data if the corresponding consent has been given (see chapter 5 for more details) As part of your interaction with the CUE GitHub project under github.com/cue-lang: user information like your GitHub username and public activity (e.g. issues raised, pull requests) As part of your interactions with our community platforms (Slack, Discord) and social media channels (X, YouTube, Bluesky, LinkedIn): Username, public posts, reactions or comments, and interactions and communications with us. If applicable, company name, role, department, usual business contact details. 3.3 Type and purpose of personal data processing We process personal data in the following way: collection, storage, analysis, deletion of personal data. The purpose of the processing is: For users and customers of our Services: providing our Services to users and customers, and customer support. For other business partners: managing of the business relationship. For our Websites: ensuring delivery and functions of our Websites, providing security and safety of our Websites. For interactions with CUE GitHub project: providing our Services to users and customers, and customer support via GitHub. For the interactions via our community platforms and social media channels: providing of our Services to users, customers and community members, and customer support. 3.4 Legal basis for personal data processing Insofar as the GDPR is applicable, the legal basis for the processing is as follows: For users and customers of our Services : Art. 6 para. 1 lit. b GDPR. For our business partners: Art. 6 para. 1 lit. b GDPR. When operating the Websites and regarding the interactions via GitHub and community platforms and social media channels: Art. 6 para. 1 lit. f GDPR, whereby the legitimate interest is to ensure functionality and business continuity. For analysis and marketing purposes through our Websites (except cuelang.org): Art. 6 para. 1 lit. a GDPR. Insofar as you have given us consent to process your personal data for specific purposes, we will process your personal data within the scope of and based on this consent, unless we have another legal basis and require one. 3.5 Storage period of personal data Personal data is stored until the statutory retention periods have expired (generally 10 years for accounting and other records) and then deleted. Without a statutory retention requirement, personal data is deleted as soon as we no longer need it to achieve its purpose. 3.6 Not directed at children Our Websites are not directed at children. We do not knowingly collect personal data from children under the age of 16. If you are a parent or guardian and believe your child has provided us with personal data without your consent, please contact us and we will take steps to delete such personal data from our systems. 4 Transfer of personal data Your personal data will only be transferred to external recipients for the purposes stated above. Your data will be transferred to the following categories of recipients: User and Customer data of our Services: Transfer of your data to our trusted external service providers, such as IT service providers and other vendors that assist us in operating and supporting our business activities. Transmission of your payment data to",
        "breadcrumb": [],
        "contentType": "Privacy policy",
        "tags": "",
        "authors": ""
    },
    {
        "objectID": "8654ef41de81deef0cd862602895912d_2",
        "title": "Privacy policy",
        "link": "/privacy-policy/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe protection of your privacy and the confidentiality of your personal data are\nof particular concern to us. We therefore explain to you below which of your\ndata we process, for which purpose and what rights you have in this context.\u003c/p\u003e\n\u003cp\u003eWe comply with the applicable data protection laws, in particular the Swiss Data\nProtection Act (FADP; revised as of September 1, 2023) and the associated Data\nProtection Ordinance (FODP). Where applicable, we also comply with the\nrequirements of the European General Data Protection Regulation (GDPR).\u003c/p\u003e",
        "content": "our payment service provider. Data of business partners: Transfer of your data to our trusted external service providers, such as IT service providers and other vendors that assist us in operating and supporting our business activities. Data related to our Websites and interactions via GitHub and Social Media: Transfer of your data to our trusted external service providers, such as IT service providers and other vendors that assist us in operating and supporting our business activities. The recipients may only process the personal data passed on to them for the purposes stated above. Your personal data will generally be processed and transmitted in Switzerland, the European Union or a country with an adequate level of data protection in accordance with Art. 16 para. 1 FADP and Art. 45 GDPR. If a transfer to another third country takes place, we ensure that a guarantee is in place in accordance with Art. 16 para. 2 FADP or Art. 46 ff. GDPR. If the GDPR is applicable, we will provide a copy of the guarantee on request. In this context, we would like to point out that we use the customary services of various common provider of software tools to carry out our business activities. These providers sometimes store the data in global data centers. In certain cases, processing from third countries that do not offer an adequate level of data protection cannot be ruled out. In this case, we ensure that the measure is in line with the applicable data protection law in accordance with Art. 16 Para. 2 FADP and Art. 46 ff. GDPR). 5 Processing in the context of our Websites especially We typically use cookies and similar techniques on our Websites (except cuelang.org) that can be used to identify your browser or device. A cookie is a small file that is sent to your computer or automatically stored by the web browser you are using on your computer or mobile device when you visit our website. If you visit this website again, we can recognize you even if we do not know who you are. In addition to cookies that are only used during a session and deleted after your visit to the website (session cookies), cookies can also be used to store user settings and other information for a certain period of time (e.g. two years) (permanent cookies). You can set your browser to reject cookies, to only store them for one session or to delete them prematurely. Most browsers are set to accept cookies by default. If you block cookies, certain functionalities of the website(s) may no longer work. In our marketing e-mails, we sometimes also include visible and invisible image elements, to the extent permitted, which allow us to determine whether and when you have opened the e-mail, so that we can measure and better understand how you use our offers and how we can tailor them to you. You can block this in your email program; most are set up to do this by default. By using our websites and consenting to receive newsletters and other marketing emails, you consent to the use of these technologies. If you do not want this, you must set your browser or email client accordingly, provided that this cannot be customized via the settings. 6 Rights of the data subjects Data subjects have the rights applicable to them under the applicable data protection law (in particular the right of access, the right to rectification, the right to erasure, the right to restriction of processing, the right to object, the right to data portability, the right to lodge a complaint with a supervisory authority). To exercise your rights, you can contact the data controller named at the beginning of this privacy policy at any time. 7 Security We take precautions including organizational, technical, and physical measures, to help safeguard against accidental or unlawful destruction, loss, alteration, unauthorized disclosure of, or access to, the personal data we process or use. While we follow generally accepted standards to protect personal data, no method of storage or transmission is 100% secure. You are solely responsible for protecting your password, limiting access to your devices, and signing out of websites after your sessions. If you have any questions about the security of our websites, please contact us via the e-mail address linked in section 1. 8 Changes to the privacy policy We may amend this privacy policy at any time without notice. The current version published on our website applies. Last updated: 01.04.2025",
        "breadcrumb": [],
        "contentType": "Privacy policy",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "23305981ffc185214c6656f3587dec9e_1",
        "title": "Producing a set of strings from a list",
        "link": "/docs/howto/produce-string-set-from-list/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to produce a list of unique strings from a list of\nstrings that might include duplicate values.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to produce a list of unique strings from a list of strings that might include duplicate values. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; stringList: [\u0026#34;d\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;] stringSet: { let map = {for v in stringList {(v): _}} list.SortStrings([for k, _ in map {k}]) } TERMINAL Copy code Copied! $ cue eval stringList: [\u0026#34;d\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;] stringSet: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;] It is not strictly necessary to sort the elements of the set. We do this to ensure a deterministic output. Related content Language Tour: Field Comprehensions Language Tour: List Comprehensions Language Specification: Embedding",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["noamtd"]
    },
    
            {
        "objectID": "dbbca40d46248b46d6895e1e21e71de7_1",
        "title": "Publishing modules to the Central Registry",
        "link": "/docs/tutorial/publishing-modules-to-the-central-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003c!-- vim_ syntax highlighting hack --\u003e\n\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will publish a module to the Central Registry and then\ncreate a second module that depends on the first.\u003c/p\u003e",
        "content": "Introduction In this tutorial you will publish a module to the Central Registry and then create a second module that depends on the first. Prerequisites A GitHub account \u0026ndash; this will let you authenticate to the Central Registry A GitHub repository called frostyconfig \u0026ndash; create it under your personal GitHub account (it doesn\u0026rsquo;t matter if it is public or private) A Central Registry account The cue binary \u0026ndash; follow the installation instructions if you don\u0026rsquo;t already use cue A tool to edit text files \u0026ndash; any text editor you have will be fine, such as VSCode, Notepad, or Vim A command terminal \u0026ndash; cue works on all platforms, so you can use any Linux or macOS terminal, or a Windows terminal such as PowerShell, cmd, or WSL to run commands. Some awareness of CUE schemata \u0026ndash; the language tour\u0026rsquo;s pages on Constraints and Definitions are a good refresher This tutorial is written using the following version of cue: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Create the module for the schema code In this tutorial we will focus on an imaginary application called FrostyApp, which consumes its configuration in YAML format. You will define the configuration in CUE and use a CUE schema to validate it. We would like to be able to share the schema between several consumers, so we will publish it to the Central Registry. 1Create a directory to hold the schema code: TERMINAL Copy code Copied! $ mkdir frostyconfig $ cd frostyconfig You need to adapt the command shown in the next step. Don\u0026rsquo;t simply paste the command into your terminal and run it. Before running the command, replace the example username, cueckoo, with the lower-cased form of YOUR GitHub username. For example: if your GitHub username is _TomHanks then you would replace cueckoo with _tomhanks. You need to make this replacement everywhere you see the username cueckoo in this tutorial. 2Initialize the directory as a git repository and a CUE module: TERMINAL Copy code Copied! $ git init -q # Replace \u0026#34;cueckoo\u0026#34; with *your* GitHub username, lower-cased. $ cue mod init --source=git github.com/cueckoo/frostyconfig@v0 The --source=git flag tells cue to use the same file-inclusion rules as git, when publishing this module. The GitHub user cueckoo controls all the repositories under github.com/cueckoo/, so they can publish modules to the Central Registry inside that namespace. The same is true for your GitHub username. 3Create the configuration schema: Copied! frostyconfig/config.cue Copy code Copied! package frostyconfig // #Config defines the schema for the FrostyApp configuration. #Config: { // appName defines the name of the application. appName!: string // port holds the port number the application listens on. port!: int // debug holds whether to enable debug mode. debug?: bool // features holds optional feature settings features?: { // logging enables or disables logging. logging?: bool // analytics enables or disables analytics. analytics?: bool } } 4As a one-off, login to the Central Registry: TERMINAL Copy code Copied! $ cue login The Central Registry is in beta testing - please give us your feedback about the service in the #modules channel on Slack or on Discord! 5Ensure the module.cue file is tidy: TERMINAL Copy code Copied! $ cue mod tidy 6If you haven\u0026rsquo;t already done so, create a repository called frostyconfig under your personal username at GitHub. It doesn\u0026rsquo;t matter if the repository is public or private. 7Create a git commit: TERMINAL Copy code Copied! $ git add -A $ git commit -q -m \u0026#39;Initial commit\u0026#39; Earlier, you initialized this module with --source=git, which told the cue command that it should publish only those files that git knows about. The git commit you just created leaves the directory in a \u0026ldquo;clean\u0026rdquo; state, which is necessary for cue to know exactly which files to include in the published module. 8Publish the first version of this module: TERMINAL Copy code Copied! $ cue mod publish v0.0.1 ... This command should mention your GitHub username, and should publish the module successfully. If the command fails with an error message that mentions your GitHub username then you probably haven\u0026rsquo;t created the frostyconfig repository under your GitHub username. Create it, and try the step again. If the command fails with an error message that mentions cueckoo/frostyconfig then you probably forgot to adapt the command in step 3, above. Don\u0026rsquo;t worry - this isn\u0026rsquo;t a serious problem! The easiest way to fix this is to delete your frostyconfig directory and restart the tutorial from step 1. Create a new frostyapp module that depends on the first module Define the FrostyApp configuration, constrained by the schema you just published. 9Create a directory for the new module and initalize it, changing cueckoo to your GitHub username, lower-cased: TERMINAL Copy code Copied! $ mkdir ../frostyapp $ cd ../frostyapp $ git init -q $ cue mod init --source=git github.com/cueckoo/frostyapp@v0 10Create the code for the new module: Copied! frostyapp/config.cue Copy code Copied! 1 2 3 4 5 6 7 8 9 10 package frostyapp // Adapt this line to your GitHub username, lower-cased. import \u0026#34;github.com/cueckoo/frostyconfig@v0\u0026#34; config: frostyconfig.#Config \u0026amp; { appName: \u0026#34;alpha\u0026#34; port: 80 features: logging: true } Remember to change cueckoo to your GitHub username, lower-cased, on line 4. 11Ensure the module is tidy, adding missing dependencies: TERMINAL Copy code Copied! $ cue mod tidy We can see that the dependencies have now been added to the cue.mod/module.cue file: TERMINAL Copy code Copied! $ cat cue.mod/module.cue module: \u0026#34;github.com/cueckoo/frostyapp@v0\u0026#34; language: { version: \u0026#34;v0.13.0\u0026#34; } source: { kind: \u0026#34;git\u0026#34; } deps: { \u0026#34;github.com/cueckoo/frostyconfig@v0\u0026#34;: { v: \u0026#34;v0.0.1\u0026#34; } } Evaluate the configuration 12Export the configuration as YAML: TERMINAL Copy code Copied! $ cue export --out yaml config: appName: alpha port: 80 features: logging: true We can use this new module code just like any other CUE code. Congratulations! That\u0026rsquo;s it! You have just created a module and published it to the Central Registry, and then used the newly published module to check a concrete configuration held in a different module. Related content Tutorial: Working with modules and the Central Registry Tutorial:",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "dbbca40d46248b46d6895e1e21e71de7_2",
        "title": "Publishing modules to the Central Registry",
        "link": "/docs/tutorial/publishing-modules-to-the-central-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003c!-- vim_ syntax highlighting hack --\u003e\n\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will publish a module to the Central Registry and then\ncreate a second module that depends on the first.\u003c/p\u003e",
        "content": "Working with a custom module registry Reference: CUE Modules",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "fceaa760a101394c739f85d5ecf75f35_1",
        "title": "Querying use case",
        "link": "/docs/concept/querying-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE orders all values in a value lattice.\nA value more at the top of a hierarchy is what programming languages would\nrefer to as a type.\nConcrete value or constraints on such a \u0026ldquo;type\u0026rdquo; are all instances of that type.\u003c/p\u003e\n\u003cp\u003eIn other words, CUE constraints can be used to find patterns in data.\n\u003ccode\u003ecue vet\u003c/code\u003e is a simple instance of this.\u003c/p\u003e",
        "content": "CUE orders all values in a value lattice. A value more at the top of a hierarchy is what programming languages would refer to as a type. Concrete value or constraints on such a \u0026ldquo;type\u0026rdquo; are all instances of that type. In other words, CUE constraints can be used to find patterns in data. cue vet is a simple instance of this. But more elaborate querying in the form of a find or query subcommand is certainly possible. We would love to hear about your envisioned use cases to plan out such a subcommand. Programmatic Querying In the mean time, you can query data programmatically using the CUE API. What you will need to do is load data and constraints using cuelang.org/go/cue.Runtime or cuelang.org/go/cue/load.Instances. Walk over data using cuelang.org/go/cue.Value\u0026rsquo;s Walk method or look up specific values. call pattern.Subsumes(value), where pattern and value are cue.Values to see if value is an instance of pattern.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "b265450eb45aedf7eee541451bf3c512_1",
        "title": "Refering to fields whose names are not valid identifiers",
        "link": "/docs/howto/refer-to-fields-whose-names-are-not-valid-identifiers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eSome fields have names that are not valid\n\u003ca href=\"/docs/reference/spec/#identifiers\"\u003eCUE identifiers\u003c/a\u003e.\nThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to refer to these fields, both at CUE\u0026rsquo;s top level and elsewhere.\u003c/p\u003e",
        "content": "Some fields have names that are not valid CUE identifiers. This Commented CUE demonstrates how to refer to these fields, both at CUE\u0026rsquo;s top level and elsewhere. Copied! data.cue Copy code Copied! package example // data.cue contains fields we want to refer to // in file.cue \u0026#34;top level field\u0026#34;: \u0026#34;a top-level value\u0026#34; aStruct: \u0026#34;nested field\u0026#34;: \u0026#34;a nested value\u0026#34; Copied! file.cue Copy code Copied! package example // Declare an alias X=\u0026#34;top level field\u0026#34;: _ output: { // Use the alias to refer to a top-level // field\u0026#39;s value topLevelField: X // Use index notation to refer to a // non-top-level field\u0026#39;s value nestedField: aStruct[\u0026#34;nested field\u0026#34;] } TERMINAL Copy code Copied! $ cue export -e output { \u0026#34;topLevelField\u0026#34;: \u0026#34;a top-level value\u0026#34;, \u0026#34;nestedField\u0026#34;: \u0026#34;a nested value\u0026#34; } Related content How-to Guide: Exporting fields whose names are not valid identifiers",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2efe8820814caf9faf09452ac449e7b7_1",
        "title": "Removing list arithmetic operators in CUE 0.11",
        "link": "/docs/concept/faq/removing-list-arithmetic-operators-v0.11/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide answers some questions about a language change that happened in CUE\nversion 0.11 \u0026ndash; including how to tell if the change affects your CUE, and how\nto update any CUE that\u0026rsquo;s affected.\u003c/p\u003e\n\u003ch2 id=\"whats-changed-and-how-can-i-tell-if-my-cue-is-affected\"\u003e\n    \u003ca href=\"#whats-changed-and-how-can-i-tell-if-my-cue-is-affected\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWhat\u0026rsquo;s changed, and how can I tell if my CUE is affected?\u003c/h2\u003e\n\u003cp\u003eFrom version 0.11 onwards, the list arithmetic operators \u003ccode\u003e*\u003c/code\u003e and \u003ccode\u003e+\u003c/code\u003e don\u0026rsquo;t work\nin CUE evaluated by the \u003ccode\u003ecue\u003c/code\u003e command and the Go API.\nYour CUE is not affected if a 0.11 version of \u003ccode\u003ecue vet\u003c/code\u003e evaluates it successfully.\u003c/p\u003e",
        "content": "This guide answers some questions about a language change that happened in CUE version 0.11 \u0026ndash; including how to tell if the change affects your CUE, and how to update any CUE that\u0026rsquo;s affected. What\u0026rsquo;s changed, and how can I tell if my CUE is affected? From version 0.11 onwards, the list arithmetic operators * and + don\u0026rsquo;t work in CUE evaluated by the cue command and the Go API. Your CUE is not affected if a 0.11 version of cue vet evaluates it successfully. This CUE no longer works, and must be updated as demonstrated below: Copied! list-arithmetic.cue Copy code Copied! A: [1, 2, 3] * 2 // Invalid CUE! B: [1, 2, 3] + [4, 5, 6] // Invalid CUE! The * and + operators continue to work as expected in all other situations, such as numeric arithmetic and string composition. They are only affected by this change if they are used with a list value on their left or right side. CUE versions 0.11 and later report the following errors when evaluating CUE that contains list arithmetic operators: TERMINAL Copy code Copied! $ cue vet -c list-arithmetic.cue A: Multiplication of lists is superseded by list.Repeat; see https://cuelang.org/e/v0.11-list-arithmetic: ./list-arithmetic.cue:1:4 B: Addition of lists is superseded by list.Concat; see https://cuelang.org/e/v0.11-list-arithmetic: ./list-arithmetic.cue:2:4 What changes are needed in my CUE? Wherever the * operator is used with a list: use list.Repeat instead. Wherever the + operator is used to combine lists: use either list.Concat or a nested for loop instead. Use cue fix to try and make the changes automatically. cue fix will make these changes for you in many cases, but only if you are using cue command version v0.11.0 or later. Here\u0026rsquo;s how to use cue fix: Start with some CUE that requires changes because it uses list arithmetic operators: Copied! changes-required.cue Copy code Copied! // \u0026#34;[1, 2, 3] * 2\u0026#34; is no longer valid CUE. A: [1, 2, 3] * 2 // \u0026#34;[1, 2, 3] + [4, 5, 6]\u0026#34; is no longer valid CUE. B: [1, 2, 3] + [4, 5, 6] // \u0026#34;[1, 2, 3] + [4, 5, 6]\u0026#34; can also be rewritten using a nested for loop: B: [for i in [1, 2, 3] {i}, for i in [4, 5, 6] {i}] // The operators can still be used, unchanged, to produce number, string, and bytes types. C: 1 + 2*3.3 D: 2*\u0026#34;O.\u0026#34; + 3*\u0026#34;X.\u0026#34; E: 2*\u0026#39;X.\u0026#39; + 3*\u0026#39;O.\u0026#39; Use cue fix to update files, packages, or entire modules. The command is silent unless it fails to process its inputs: TERMINAL Copy code Copied! $ cue fix changes-required.cue cue fix updates its inputs in place, rewriting files on disk: Copied! changes-required.cue Copy code Copied! import \u0026#34;list\u0026#34; // \u0026#34;[1, 2, 3] * 2\u0026#34; is no longer valid CUE. A: list.Repeat([1, 2, 3], 2) // \u0026#34;[1, 2, 3] + [4, 5, 6]\u0026#34; is no longer valid CUE. B: list.Concat([[1, 2, 3], [4, 5, 6]]) // \u0026#34;[1, 2, 3] + [4, 5, 6]\u0026#34; can also be rewritten using a nested for loop: B: [for i in [1, 2, 3] {i}, for i in [4, 5, 6] {i}] // The operators can still be used, unchanged, to produce number, string, and bytes types. C: 1 + 2*3.3 D: 2*\u0026#34;O.\u0026#34; + 3*\u0026#34;X.\u0026#34; E: 2*\u0026#39;X.\u0026#39; + 3*\u0026#39;O.\u0026#39; Why do I still get evaluation failures after running cue fix? cue fix can only update CUE where the list arithmetic operators are used with a literal list value (e.g. [1, 2, 3]). The command can\u0026rsquo;t detect when they are used with a list value via a reference \u0026ndash; you must update these uses manually, for the time being. The following CUE would not be updated by cue fix: Copied! references.cue Copy code Copied! // This file contains invalid CUE. x: [1, 2, 3] y: [4, 5, 6] A: x * 2 // Invalid use of the \u0026#34;*\u0026#34; operator with a list reference. B: x + y // Invalid use of the \u0026#34;+\u0026#34; operator with two list references. This file must be manually updated with the following CUE: Copied! references.cue Copy code Copied! import \u0026#34;list\u0026#34; x: [1, 2, 3] y: [4, 5, 6] A: list.Repeat(x, 2) B: list.Concat([x, y]) Why are list arithmetic operators being removed? Early versions of the CUE language allowed lists to be used with the arithmetic operators \u0026ldquo;+\u0026rdquo; and \u0026ldquo;*\u0026rdquo;. This feature was removed from the language specification some years ago, with the removal being completed in CUE version 0.11. The commit that removed them from the CUE language specification in 2021 explained the project\u0026rsquo;s rationale: Copy code Copied! List operators are confusing [and unnecessary]. For instance, is the result of [a, ...] + [b, ...] open or closed? What about [a] + [b, ...]? Why were list arithmetic operators supported until now? The CUE project takes its compatibility responsibilities to its users seriously. A capability that\u0026rsquo;s made available in a released version of CUE (as list arithmetic operators were) shouldn\u0026rsquo;t be removed the instant that it\u0026rsquo;s deprecated, even though CUE is still pre-version-1.0 and such an immediate removal might seem generally allowable under semantic versioning guidelines. Users might have written CUE that relied on list arithmetic operators, so the CUE tooling supported this feature up to and including version 0.10 \u0026ndash; which was released over 3 years after the feature stopped being mentioned. This breaking language change isn\u0026rsquo;t based on language.version from cue.mod/module.cue because a significant length of time has now passed without the feature being mentioned in the CUE language specification or official documentation. I have a question that isn\u0026rsquo;t answered here Please join the CUE community on GitHub, Slack, or Discord and ask the question there \u0026ndash; we\u0026rsquo;ll be happy to help! Related content Reference: cue help fix Reference: cue help vet Standard library: list.Repeat Standard library: list.Concat",
        "breadcrumb": ["Documentation","Concept Guides","Frequently Asked Questions"],
        "contentType": "Concept Guides",
        "tags": ["language"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3e0e87045ce8c34f7afe33a0b9995ba9_1",
        "title": "Schema Definition use case",
        "link": "/docs/concept/schema-definition-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA data definition language describes the structure of data.\nThe structure defined by such a language can, in turn, be used\nto verify implementations, validate inputs, or generate code.\u003c/p\u003e\n\u003cp\u003eMost modern dedicated data definition languages or standards allow\nmore than just describing whether a field is an integer or a string.\nStandards like OpenAPI and CDDL allow defining things like default\nvalues, ranges, and various other constraints.\nOpenAPI even allows for complex logical combinators.\u003c/p\u003e\n\u003cp\u003eA key difference, however, is that these standards do not unify schema\nand valuesthe thing that makes CUE so powerful.\nThere is no value lattice.\nThis limits these standards in various ways.\u003c/p\u003e\n\u003c!-- There is no or very limited possibility for boilerplate removal. --\u003e",
        "content": "A data definition language describes the structure of data. The structure defined by such a language can, in turn, be used to verify implementations, validate inputs, or generate code. Most modern dedicated data definition languages or standards allow more than just describing whether a field is an integer or a string. Standards like OpenAPI and CDDL allow defining things like default values, ranges, and various other constraints. OpenAPI even allows for complex logical combinators. A key difference, however, is that these standards do not unify schema and valuesthe thing that makes CUE so powerful. There is no value lattice. This limits these standards in various ways. Core issues addressed by CUE Validating backwards compatibility CUE\u0026rsquo;s model makes it easy to verify that newer versions of schema are backwards-compatible with older versions. Consider the following versions of the same API: Copied! schema.cue Copy code Copied! // Release notes: // - You can now specify your age and your hobby! #V1: { age: \u0026gt;=0 \u0026amp; \u0026lt;=100 hobby: string } // Release notes: // - People get to be older than 100, so we relaxed it. // - It seems not many people have a hobby, so we made it optional. #V2: { age: \u0026gt;=0 \u0026amp; \u0026lt;=150 // people get older now hobby?: string // some people don\u0026#39;t have a hobby } // Release notes: // - Actually no one seems to have a hobby nowadays anymore, so we dropped the field. #V3: { age: \u0026gt;=0 \u0026amp; \u0026lt;=150 } Declarations with a name starting with # are definitions. Definitions are not emitted when converting to data, for instance when exporting to JSON, and thus do not need to be concrete in such cases. Definitions assume the definition of closed structs, which means a user may only use fields that are explicitly defined. In CUE, an API is backwards compatible if it subsumes the older one, or if the old one is an instance of the new one. This can be computed using the API: Copied! main.go Copy code Copied! package main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; ) //go:embed schema.cue var schemaFile string func main() { ctx := cuecontext.New() rootValue := ctx.CompileString(schemaFile) v1 := rootValue.LookupPath(cue.ParsePath(\u0026#34;#V1\u0026#34;)) v2 := rootValue.LookupPath(cue.ParsePath(\u0026#34;#V2\u0026#34;)) v3 := rootValue.LookupPath(cue.ParsePath(\u0026#34;#V3\u0026#34;)) fmt.Println(\u0026#34;V2 is backwards compatible with V1:\u0026#34;, v2.Subsume(v1) == nil) fmt.Println(\u0026#34;V3 is backwards compatible with V2:\u0026#34;, v3.Subsume(v2) == nil) } TERMINAL Copy code Copied! $ go run . V2 is backwards compatible with V1: true V3 is backwards compatible with V2: false It is as simple as that. This is the kind of thing that is made possible by ordering all values in a lattice, like CUE does. For CUE, checking whether one API is an instance of another is like checking whether 3 is less than 4. Note that V2 strictly relaxed the API relative to V1. It allowed specifying a wider age range and made the hobby field optional. In V3 the hobby field is explicitly disallowed. This is not backwards compatibly as it breaks previous field that did contain a hobby field. The current API only reports a yea or nay. The plan is to give full actionable reports. Feedback welcome! Combining constraints from different sources Most data definition languages are often not explicitly defined for commutativity. For instance, CDDL, although much less expressive than CUE, introduces operators that break commutativity. The additive property obtained by commutativity is of great value for data definition. Constraints often come from many sources. For instance, one can have constraints from a base template, from code, policies provided by different departments and policies provided by a client. CUE\u0026rsquo;s additive nature of constraints allows piling up constraints, in any order, to obtain a new definition. Which leads us to the next topic. Normalization of data definitions Adding constraints from many sources can result in a lot of redundancy. Even worse, constraints can be specified in different logical forms, making their additive form verbose and unwieldy. This is fine if all a system does using these constraints is validate data. But this is problematic if the added constraints are to form the basis for, say, human consumption. CUE\u0026rsquo;s logical inference engine automatically reduces constraints. Its API makes it possible to compute and select between various normal forms to optimize for a certain representation. This is used in CUE\u0026rsquo;s OpenAPI generator, for instance. Comparisons JSON Schema / OpenAPI JSON Schema and OpenAPI are purely data-driven data definition standards. OpenAPI originates from Swagger. As of version 3, OpenAPI is more or less a subset of JSON Schema. OpenAPI is used to define Kubernetes Custom Resource Definitions. As of 1.15, this requires a variant of OpenAPI called Structural OpenAPI. We will collectively refer to these as OpenAPI henceforth. OpenAPI does not have any expressions or references. They have powerful logical operators, though, that make them remarkably expressive. On logical not OpenAPI defines a not operator. These get fuzzy when defined on structs, which OpenAPI allows. CUE doesn\u0026rsquo;t have such a construct, partly to avoid its logical pitfalls. However, it can get a good approximation by interpreting P as P. An advantage of OpenAPI is that it is purely defined in terms of data (JSON). This allows sending it over the wire. It is defined such that implementing an interpreter is fairly straightforward. One disadvantage is that it is very verbose. Compare the following two equivalent schema definitions: Copied! native.cue Copy code Copied! // Definitions. info: version: \u0026#34;v1beta1\u0026#34; // Info describes... #Info: { // Name of the adapter. name: string // Templates. templates?: [...string] // Max is the limit. max?: uint \u0026amp; \u0026lt;100 } Copied! openapi.json Copy code Copied! { \u0026#34;openapi\u0026#34;: \u0026#34;3.0.0\u0026#34;, \u0026#34;info\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;v1beta1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Generated by cue.\u0026#34; }, \u0026#34;paths\u0026#34;: {}, \u0026#34;components\u0026#34;: { \u0026#34;schemas\u0026#34;: { \u0026#34;Info\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Info describes...\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Name of the adapter.\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;templates\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Templates.\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;max\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Max is the limit.\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;minimum\u0026#34;: 0, \u0026#34;maximum\u0026#34;: 100, \u0026#34;exclusiveMaximum\u0026#34;: true } }",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["go api","validation"],
        "authors": ""
    },
    
            {
        "objectID": "3e0e87045ce8c34f7afe33a0b9995ba9_2",
        "title": "Schema Definition use case",
        "link": "/docs/concept/schema-definition-use-case/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eA data definition language describes the structure of data.\nThe structure defined by such a language can, in turn, be used\nto verify implementations, validate inputs, or generate code.\u003c/p\u003e\n\u003cp\u003eMost modern dedicated data definition languages or standards allow\nmore than just describing whether a field is an integer or a string.\nStandards like OpenAPI and CDDL allow defining things like default\nvalues, ranges, and various other constraints.\nOpenAPI even allows for complex logical combinators.\u003c/p\u003e\n\u003cp\u003eA key difference, however, is that these standards do not unify schema\nand valuesthe thing that makes CUE so powerful.\nThere is no value lattice.\nThis limits these standards in various ways.\u003c/p\u003e\n\u003c!-- There is no or very limited possibility for boilerplate removal. --\u003e",
        "content": "} } } } The difference gets more extreme as more constraints and logical combinators are used. OpenAPI and CUE both have their roles. The JSON format of OpenAPI makes it good interchange standard. CUE, on the other hand, can serve as an engine to generate and interpret OpenAPI constraints. Note that CUE is generally more expressive and many CUE constraints will not be encodeable in OpenAPI. OPA / Rego Although not designed as a data definition language, Rego, the language used for Open Policy Agent (OPA), also solves the issue of being able to add constraints from multiple sources. Rego, like CUE, has its roots in logic programming. It is based on Datalog, a restricted form of Prolog, whereas CUE is based on typed-feature structure or graph unification. Typed-feature structures were designed to deal with the shortcomings of Prolog for applications in encoding human languages. Using a Datalog variant for what is essentially a constraint validation task is somewhat curious. Datalog makes an excellent query language. But for constraint enforcement, it is a bit cumbersome as one effectively first needs to query values to which to apply the constraints. CUE collates the constraints with the location of the data to which they apply. As a result, CUE constraints look a lot like the data they constrain, unlike Rego which will be more reminiscent of a Datalog program. But more importantly, CUE\u0026rsquo;s approach is more amenable to finding normalized and simplified representations of constraints, which makes it more suitable for creating OpenAPI from them. CDDL The Concise Data Definition Language (CDDL) is used to define the structure of CBOR or JSON data. CDDL shares many of the same constructs from CUE, including disjunctions, embedding, optional fields, and definitions. CDDL, however, has no value lattice and does not define mathematical properties of its data. There several other aspects in CDDL that contradict the use of a value lattice or make it harder to do so. Overall this restricts the expressiveness of CDDL compared to CUE while complicating the ability to combine constraints on types from multiple sources. Unlike OpenAPI, CDDL is a domain-specific language (DSL). It needs a specific interpreter. It also has some non-trivial aspects to its evaluation, making it much harder than OpenAPI to implement.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["go api","validation"],
        "authors": ""
    },
    
            {
        "objectID": "a8dc644f7f41566ebf39cdae50e794e9_1",
        "title": "Searching for content on cuelang.org",
        "link": "/docs/howto/search-this-site/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThere are several ways to find the CUE documentation you\u0026rsquo;re looking for.\nThey can all be combined to help you find the page you need, fast!\u003c/p\u003e\n\u003cp\u003eThe full text of this site can be searched by selecting the search icon\n() at the top of any page. Use double quotes around any \u003cem\u003eprecise\u003c/em\u003e\nwords or phrases that you\u0026rsquo;re searching for, and use a leading dash (\u003ccode\u003e-\u003c/code\u003e) to\nrule out pages containing any unwanted words:\u003c/p\u003e",
        "content": "There are several ways to find the CUE documentation you\u0026rsquo;re looking for. They can all be combined to help you find the page you need, fast! The full text of this site can be searched by selecting the search icon () at the top of any page. Use double quotes around any precise words or phrases that you\u0026rsquo;re searching for, and use a leading dash (-) to rule out pages containing any unwanted words: Pages containing a specific word: json Pages containing multiple, independent words: json schema Pages containing a specific phrase (multiple words next to each other): \u0026quot;json schema\u0026quot; (NB quotation marks) Pages mentioning a specific phrase containing punctuation characters: \u0026quot;--with-context\u0026quot; (NB quotation marks) Pages containing a specific word that do not contain some other word: json -schema Each page on the site has a content type, such as \u0026ldquo;How-to Guide\u0026rdquo;, \u0026ldquo;Tutorial\u0026rdquo;, and \u0026ldquo;Concept Guide\u0026rdquo;. Pages with the same content type are gathered together in the related sections linked from the site\u0026rsquo;s navigation menu, and you can search for specific content types: How-to Guides: contentType:\u0026quot;How-to Guides\u0026quot; Tutorials: contentType:\u0026quot;Tutorials\u0026quot; Many pages have also been given one or more tags, such as modules and commented cue : Pages with a specific tag: tag:\u0026quot;commented cue\u0026quot; Pages with multiple tags: tag:\u0026quot;commented cue\u0026quot; tag:\u0026quot;encodings\u0026quot; Combine any of these search tools to pinpoint the documentation you need: Pages with a content type and tag: contentType:\u0026quot;How-to Guides\u0026quot; tag:\u0026quot;commented cue\u0026quot; Pages with a content type and a tag that also contain a specific phrase: \u0026quot;encoding/json\u0026quot; contentType:\u0026quot;How-to Guides\u0026quot; tag:\u0026quot;commented cue\u0026quot;",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "c029fe3063734734ffe90b2f867054d0_1",
        "title": "Specifying a default value for a field",
        "link": "/docs/howto/specify-a-default-value-for-a-field/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE allows fields to be given a value which is used only if \u003cstrong\u003eunification\u003c/strong\u003e\nresults in no other value being provided.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates CUE\u0026rsquo;s \u003cstrong\u003edefault value\u003c/strong\u003e syntax.\u003c/p\u003e",
        "content": "CUE allows fields to be given a value which is used only if unification results in no other value being provided. This guide demonstrates CUE\u0026rsquo;s default value syntax. Specifing defaults Specify a default by marking one element of a disjunction with an asterisk prefix: Copy code Copied! // field \u0026#39;a\u0026#39; has a default value of \u0026#34;A\u0026#34;. // it can also be set to any other value, // through unification a: *\u0026#34;A\u0026#34; | _ If a field\u0026rsquo;s value is not provided through unification then the default is used. If a regular field has a value provided elsewhere, through unification, then that value is used instead: Copied! policy.cue Copy code Copied! package example a: *\u0026#34;A\u0026#34; | _ b: *\u0026#34;B\u0026#34; | _ Copied! data.cue Copy code Copied! package example a: \u0026#34;some value\u0026#34; TERMINAL Copy code Copied! $ cue export .:example { \u0026#34;a\u0026#34;: \u0026#34;some value\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;B\u0026#34; } Both required fields and optional fields may include a default in a disjunction. Such a default will only have an effect if the field is also unified with a regular field. If this unification occurs, the default behaves as demonstrated in this guide. The purpose of the disjunction If a default is provided, it must take the form of a single element of a valid disjunction - that is, a disjunction containing at least 2 elements. If the field has a value provided elsewhere, through unification, then at least one of the disjunction\u0026rsquo;s elements must unify with the field\u0026rsquo;s concrete value. The concrete value provided through unification may be the same as the default value: Copied! policy.cue Copy code Copied! package example a: *\u0026#34;A\u0026#34; | string b: *5 | int Copied! data.cue Copy code Copied! package example a: \u0026#34;A\u0026#34; TERMINAL Copy code Copied! $ cue export .:example { \u0026#34;a\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;b\u0026#34;: 5 } If no element unifies with the value that has been provided, a disjunction resolution error results: Copied! policy.cue Copy code Copied! package example a: *\u0026#34;A\u0026#34; | string b: *5 | int Copied! data.cue Copy code Copied! package example b: \u0026#34;a string\u0026#34; Copied! stderr.txt Copy code Copied! b: 2 errors in empty disjunction: b: conflicting values \u0026#34;a string\u0026#34; and 5 (mismatched types string and int): ./data.cue:3:4 ./policy.cue:4:5 b: conflicting values \u0026#34;a string\u0026#34; and int (mismatched types string and int): ./data.cue:3:4 ./policy.cue:4:9 Defaults are usually specified as concrete values Defaults are used by the CUE evaluator when a field\u0026rsquo;s value needs to be used in a concrete context, but where no specific value has been provided elsewhere, through unification. Therefore, in order to be useful, defaults need to evaluate to a concrete value. If CUE needs to use a default but the value provided is not concrete, an error results: Copied! CUE Copy code Copied! package example a: *\u0026#34;A\u0026#34; | _ b: *string | _ ERR Copy code Copied! b: incomplete value string: ./in.cue:4:5 Defaults can include references Defaults are commonly specified as explicit concrete values, but if CUE can resolve a default to a concrete value via references then the result can be successfully used as a default: Copied! CUE Copy code Copied! package example a: 5 b: *( a + 10) | int c: \u0026#34;hello\u0026#34; d: *( c + \u0026#34;, world!\u0026#34;) | string JSON Copy code Copied! { \u0026#34;a\u0026#34;: 5, \u0026#34;b\u0026#34;: 15, \u0026#34;c\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;hello, world!\u0026#34; } Defaults can be complex values Defaults are often specified as primitive types (bool, string, number, int or float) but they can also take complex types. These values can either be provided inline, or by reference. In this example, both defaults for the field a are equivalent: Copied! CUE Copy code Copied! package example a: string | *_s a: string | *{ x: \u0026#34;value\u0026#34; y: [ \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, ] } _s: { x: \u0026#34;value\u0026#34; y: [ \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, ] } JSON Copy code Copied! { \u0026#34;a\u0026#34;: { \u0026#34;x\u0026#34;: \u0026#34;value\u0026#34;, \u0026#34;y\u0026#34;: [ \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34; ] } } Specifying multiple defaults is usually not useful A single field may have multiple defaults specified in parallel, provided that all the defaults unify successfully: Copied! CUE Copy code Copied! package example a: *\u0026#34;A\u0026#34; | _ a: *string | _ JSON Copy code Copied! { \u0026#34;a\u0026#34;: \u0026#34;A\u0026#34; } If multiple defaults are provided but they do not unify successfully, then CUE treats the field as if no defaults were provided. If unification then finishes without a concrete value being specified elsewhere, or without sufficient information being provided to resolve the disjunction, then the result is an error: Copied! CUE Copy code Copied! package example a: *\u0026#34;A\u0026#34; | _ a: *int | _ ERR Copy code Copied! a: incomplete value \u0026#34;A\u0026#34; | int | _ However, even if multiple defaults are provided and they unify successfully, doing so is usually not a useful technique. This is because in the case where CUE needs to use the unified default (because no concrete, regular value was discovered through unification) the result of unifying all the defaults must be concrete. Such concreteness can be derived from the unification of multiple non-concrete defaults - but as the following example demonstrates, this has a higher change of leading to unclear CUE that could confuse the reader: Copied! policy-upper-bound.cue Copied! policy-lower-bound.cue Copy code Copied! package example port_x: *\u0026lt;=8080 | string port_y: *\u0026lt;=8080 | string Copy code Copied! package example port_x: *\u0026gt;=8080 | string port_y: *\u0026gt;=8080 | string Copied! data.cue Copy code Copied! package example port_x: \u0026#34;a string, for some reason\u0026#34; TERMINAL Copy code Copied! $ cue export .:example { \u0026#34;port_x\u0026#34;: \u0026#34;a string, for some reason\u0026#34;, \u0026#34;port_y\u0026#34;: 8080 } The preceding example is not an example of clear and straightforward CUE, and the reader would be better served by having an explicit and concrete default specified (e.g. port_x: *8080 | string). Having specified such a concrete default, there is usually little point in also specifying non-concrete defaults in parallel. There are specific, nuanced, situations where this advice might not hold true. However, in general, using multiple defaults is unnecessary and risks confusing the reader. Defaults provide only a single preference layer As demonstrated above, if a field has multiple",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["level:user","language"],
        "authors": ""
    },
    
            {
        "objectID": "c029fe3063734734ffe90b2f867054d0_2",
        "title": "Specifying a default value for a field",
        "link": "/docs/howto/specify-a-default-value-for-a-field/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eCUE allows fields to be given a value which is used only if \u003cstrong\u003eunification\u003c/strong\u003e\nresults in no other value being provided.\u003c/p\u003e\n\u003cp\u003eThis guide demonstrates CUE\u0026rsquo;s \u003cstrong\u003edefault value\u003c/strong\u003e syntax.\u003c/p\u003e",
        "content": "defaults provided but they do not all unify successfully, then CUE behaves as if no default had been provided. For this reason, defaults cannot be used as a system of multi-layered, overriding values. See also Default values Disjunctions Field constraints",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["level:user","language"],
        "authors": ""
    },
    
            {
        "objectID": "dd15875c6f99d973454fa940a17fd945_1",
        "title": "Symbolic link support in CUE",
        "link": "/docs/concept/faq/symbolic-link-support/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eBoth the \u003ccode\u003ecue\u003c/code\u003e command and the CUE Go API support\n\u003ca href=\"https://en.wikipedia.org/wiki/Symbolic_link\"\u003esymbolic links\u003c/a\u003e\n(\u0026ldquo;symlinks\u0026rdquo;) on operating systems where the feature is available.\nHowever, symlinks are ignored when they are part of a CUE module published to\n(or fetched from) a module registry.\u003c/p\u003e\n\u003cp\u003eThis guide answers some questions about CUE\u0026rsquo;s support for symlinks.\u003c/p\u003e",
        "content": "Both the cue command and the CUE Go API support symbolic links (\u0026ldquo;symlinks\u0026rdquo;) on operating systems where the feature is available. However, symlinks are ignored when they are part of a CUE module published to (or fetched from) a module registry. This guide answers some questions about CUE\u0026rsquo;s support for symlinks. Can I use symlinks to help organise my CUE code? Yes. When writing your own CUE code you can rely on CUE to respect any filesystem symlinks you put in place. This includes creating symlinks that point to: CUE code (e.g. file.cue points to some.other.file) package directories (e.g. foo/ points to bar/) files included via the @embed() attribute Symlinks can point to targets anywhere on your computer\u0026rsquo;s filesystem and not only files inside your CUE module. Can I include symlinks when publishing a CUE module? No. When the cue mod publish command publishes a module to a registry, it silently ignores any symlinks contained in the module. Any symlinks are left in place locally (on the computer that publishes the module) but they will not be present in the published module. Can I depend on a CUE module that relies on symlinks? It depends. Your CUE code can have a dependency on any module that\u0026rsquo;s published and accessible, but when the cue command fetches and unpacks a module from a registry it doesn\u0026rsquo;t create any symlinks that it finds in the module. CUE\u0026rsquo;s behaviour when it finds symlinks in published modules is undefined, but will never result in a working symlink being created. This means that CUE packages in a published module that rely on the presence of symlinks to work correctly will not behave as expected, after being fetched from a registry. Therefore: if your CUE code uses any such package, then your CUE may not work as you expect.",
        "breadcrumb": ["Documentation","Concept Guides","Frequently Asked Questions"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ""
    },
    {
        "objectID": "4667e9caadca8e00167a936f8f32fa5a_1",
        "title": "Talks and Presentations by the CUE Team",
        "link": "/community/talks/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe CUE team regularly gives talks and presentations about CUE all across the\nworld, and online - here are links to recordings of some of them.\nYou can also check out the official CUE YouTube channel where we regularly\nupload our community calls, conference talks, and live streams:\n\u003ca href=\"https://www.youtube.com/@cuelang\"\u003eyoutube.com/@cuelang\u003c/a\u003e\u003c/p\u003e",
        "content": "The CUE team regularly gives talks and presentations about CUE all across the world, and online - here are links to recordings of some of them. You can also check out the official CUE YouTube channel where we regularly upload our community calls, conference talks, and live streams: youtube.com/@cuelang 2025 The CUE registry: Versioning Now and Beyond [ CfgMgmtCamp Ghent, February 2025 | Synopsis ] We show how the CUE registry allows reproducible sharing of configuration and how this registry serves as a platform for unified configuration management \u0026ndash; Marcel van Lohuizen and Roger Peppe 2023 Getting the Most out of your Policies with CUE [ Open Core Summit, San Francisco, December 2023 | Video ] Policy enforcement has been increasingly used to manage admission control, address security concerns, as well as a myriad of other applications. Policies typically contain information that is useful beyond the enforcement infrastructure and could be used, for instance, to prevent outages or improve documentation. But the typical siloed nature of such systems prevents such information from being used for these purposes. CUE takes a different angle to policy definitions that breaks these silos. We demonstrate several use cases by means of an example system. \u0026ndash; Marcel van Lohuizen Go \u0026lt;\u0026lt; CUE: Shifting Go left with CUE [ GoLab Conference, Florence, November 2023 | Video ] Where does your Go run? How do you tell it what to do? Configuration is a huge part of modern development but while we benefit from Go\u0026rsquo;s static type system to catch programming errors early, we don\u0026rsquo;t have the same for configuration data. This talk explains how the new CUE language integrates with Go, \u0026ldquo;shifting left\u0026rdquo; your Go types to earlier stages of deployment, reducing risk while bringing joy \u0026ndash; Roger Peppe CUE + Terraform [ Online, June 2023 | Video | Synopsis ] The CUE project has been experimenting using CUE to drive Terraform to configure our GitHub organisations and repositories. Jonathan and Paul will share progress from this experiment, beginning with a demo of the running system and followed by Q\u0026amp;A \u0026ndash; Paul Jolly and Jonathan Matthews CUE: A Type System for the Cloud [ Craft Conference, Budapest, May 2023 | Video ] CUE has an uncanny ability to act as an ad-hoc type checker that keeps things in check between loosely-coupled arbitrary systems that independently produce and consume data without knowing about each other. In this session we\u0026rsquo;ll do a full tour of CUE, its syntax, semantics, and features. Aram will show you how you can use CUE to increase your confidence in your systems while simultaneously increasing development velocity \u0026ndash; Aram Hvrneanu CUE: A glimpse into the future of configuration engineering [ CfgMgmtCamp Ghent, February 2023 | Video | Synopsis ] Configuration has become the number one complexity problem to solve. Every part of your tech stack \u0026ndash; databases, apps, schemas, services, workflows, policy, models, networking \u0026ndash; must be configured. We show how CUE can help unify these silos \u0026ndash; Marcel van Lohuizen 2022 Taming Configuration Complexity Made Fun With CUE [ QCon Plus, San Francisco, December 2022 | Video+Synopsis ] Marcel van Lohuizen discusses configuration at scale including the design of CUE, how configuration can go wrong, the need for testing and validation, and how CUE does holistic configuration \u0026ndash; Marcel van Lohuizen A Practical Guide To CUE: Patterns For Everyday Use [ FOSDEM 2022, Online, May 2022 | Video | Synopsis ] In this talk, Marcel van Lohuizen and Paul Jolly start with a quick overview of CUE the language, then move on to present practical examples of CUE in action, including common patterns for validation, policy, integration with existing non-CUE configuration and more. Because CUE is new, established patterns are still in the making, but at the very least it will be a reflection of the current thinking \u0026ndash; Marcel van Lohuizen and Paul Jolly Pulumi YAML and the CUE language [ PulumiTV, Online, May 2022 | Video ] Join us for this live Modern Infrastructure as David Flanagan and Paul Jolly show you how to use CUElang to describe your cloud infrastructure for Pulumi \u0026ndash; Paul Jolly and David Flanagan 2021 Using CUE with GitHub Actions [ Online, December 2021 | Video ] Paul Jolly welcomes guest Michael Gasch to demonstrate how to use CUE with GitHub Actions. We demonstrate how to set up your project to configure GitHub Actions with CUE, and avoid writing a single line of YAML! \u0026ndash; Paul Jolly Large-Scale Engineering of Configuration with Unification [ Splash 2021: Conflang, November 2021 | Video ] In this talk we introduce CUE: a new aspect-oriented, constraint-based configuration language that deploys a more formal approach to configuration aimed at solving many of the issues that persist with more conventional approaches. You will leave with an understanding of the CUE language, and an appreciation of how it can help mitigate the challenges associated with large-scale configurations. \u0026ndash; Marcel van Lohuizen CUE Town Hall #1 [ Online, October 2021 | Video ] The CUE project\u0026rsquo;s inaugural town hall event \u0026ndash; Paul Jolly and Marcel van Lohuizen Dev Tool Time with Paul Jolly: What CUE Can Do For You [ Dev Tool Time, Online, October 2021 | Video ] In this episode of Dev Tool Time, Paul Jolly (a CUE maintainer and creator of govim) walks us through what CUE can do for you \u0026ndash; Paul Jolly Hands-on Introduction to CUE [ Rawkode Live, Online, April 2021 | Video ] In this episode, Marcel and David will teach you everything you need to know to get started with CUE \u0026ndash; Marcel van Lohuizen and David Flanagan CUE: Configuration Superpowers for Everyone [ Go Time Podcast, Online, January 2021 | Audio+Synopsis ] \u0026ldquo;Go Time\u0026rdquo; Episode #163 \u0026ndash; Marcel van Lohuizen, Paul Jolly, and Roger Peppe 2020 Better APIs with Shareable Validation Logic [ GopherCon Europe, Online, July 2020 | Video ] Validating data at various points, like in clients and servers, is desirable. But keeping validation logic in sync between, say, Go code and",
        "breadcrumb": ["Community"],
        "contentType": "Community",
        "tags": "",
        "authors": ""
    },
    {
        "objectID": "4667e9caadca8e00167a936f8f32fa5a_2",
        "title": "Talks and Presentations by the CUE Team",
        "link": "/community/talks/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe CUE team regularly gives talks and presentations about CUE all across the\nworld, and online - here are links to recordings of some of them.\nYou can also check out the official CUE YouTube channel where we regularly\nupload our community calls, conference talks, and live streams:\n\u003ca href=\"https://www.youtube.com/@cuelang\"\u003eyoutube.com/@cuelang\u003c/a\u003e\u003c/p\u003e",
        "content": "OpenAPI is prone to errors and toil. CUE addresses this issue with the ability to convert and combine various formats. This allows for some cool and exciting rewriting capabilities, such as generating a single documented OpenAPI spec from various sources and automated compatibility checks. It addresses the issue that validation logic can often not be consolidated into one place or format \u0026ndash; Marcel van Lohuizen 2019 CUE: A Data Constraint Language and shoo-in for Go [ GopherCon Russia, 2019 | Video ] A configuration language needs to balance compactness with complexity. Most languages end up being too complex for the value they provide. We show that inheritance is the culprit and provide an alternative: constraints. CUE\u0026rsquo;s constraints describe configurations more compactly while at the same time validating them. As a separate thread throughout the talk, I\u0026rsquo;ll explain how the idea for CUE was conceived, and why it wasn\u0026rsquo;t implemented before \u0026ndash; Marcel van Lohuizen",
        "breadcrumb": ["Community"],
        "contentType": "Community",
        "tags": "",
        "authors": ""
    },
    
            {
        "objectID": "020b62e9f5c3924dd09ed4ade1fa8bbd_1",
        "title": "Transforming JSON with CUE",
        "link": "/docs/howto/transform-json-with-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to transform JSON by reshaping some input data into different\noutput.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to transform JSON by reshaping some input data into different output. Copied! file.cue Copy code Copied! package example // place the json input here with \u0026#34;-l\u0026#34; input: _ // validate the input against a schema input: #Schema #Schema: { owner?: { name!: string address?: string } pets?: [...#Pet] #Pet: { name!: string species!: string \u0026amp; or(#Species) breed?: string age?: int \u0026amp; \u0026lt;50 // years } } #Species: [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;goldfish\u0026#34;] // transform the input into the output output: location: *input.owner.address | \u0026#34;Unknown\u0026#34; output: petsBySpecies: { for s in #Species {(s): [ if input.pets != _|_ for pet in input.pets if pet.species == s {{ Name: pet.name if pet.age != _|_ { Age: pet.age DoB: 2023 - pet.age } if pet.breed != _|_ { Breed: pet.breed } Owner: input.owner.name }}, ]} } Copied! data.json Copy code Copied! { \u0026#34;owner\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;Ripon, North Yorkshire, England\u0026#34; }, \u0026#34;pets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Charlie\u0026#34;, \u0026#34;species\u0026#34;: \u0026#34;cat\u0026#34;, \u0026#34;age\u0026#34;: 15 }, { \u0026#34;name\u0026#34;: \u0026#34;Lola\u0026#34;, \u0026#34;species\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;breed\u0026#34;: \u0026#34;dachshund\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Fred\u0026#34;, \u0026#34;species\u0026#34;: \u0026#34;goldfish\u0026#34;, \u0026#34;age\u0026#34;: 8 }, { \u0026#34;name\u0026#34;: \u0026#34;George\u0026#34;, \u0026#34;species\u0026#34;: \u0026#34;cat\u0026#34;, \u0026#34;age\u0026#34;: 5 } ] } TERMINAL Copy code Copied! $ cue export .:example -l input: data.json -e output --out json { \u0026#34;location\u0026#34;: \u0026#34;Ripon, North Yorkshire, England\u0026#34;, \u0026#34;petsBySpecies\u0026#34;: { \u0026#34;cat\u0026#34;: [ { \u0026#34;Age\u0026#34;: 15, \u0026#34;DoB\u0026#34;: 2008, \u0026#34;Name\u0026#34;: \u0026#34;Charlie\u0026#34;, \u0026#34;Owner\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34; }, { \u0026#34;Age\u0026#34;: 5, \u0026#34;DoB\u0026#34;: 2018, \u0026#34;Name\u0026#34;: \u0026#34;George\u0026#34;, \u0026#34;Owner\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34; } ], \u0026#34;dog\u0026#34;: [ { \u0026#34;Breed\u0026#34;: \u0026#34;dachshund\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Lola\u0026#34;, \u0026#34;Owner\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34; } ], \u0026#34;goldfish\u0026#34;: [ { \u0026#34;Age\u0026#34;: 8, \u0026#34;DoB\u0026#34;: 2015, \u0026#34;Name\u0026#34;: \u0026#34;Fred\u0026#34;, \u0026#34;Owner\u0026#34;: \u0026#34;Dorothy Cartwright\u0026#34; } ] } }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "aafc0342d2e39984f8018a556ee471cf_1",
        "title": "Transforming YAML with CUE",
        "link": "/docs/howto/transform-yaml-with-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to transform YAML by reshaping some input data into different\noutput.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to transform YAML by reshaping some input data into different output. Copied! file.cue Copy code Copied! package example // place the yaml input here with \u0026#34;-l\u0026#34; input: _ // validate the input against a schema input: #Schema #Schema: { owner?: { name!: string address?: string } pets?: [...#Pet] #Pet: { name!: string species!: string \u0026amp; or(#Species) breed?: string age?: int \u0026amp; \u0026lt;50 // years } } #Species: [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;goldfish\u0026#34;] // transform the input into the output output: location: *input.owner.address | \u0026#34;Unknown\u0026#34; output: petsBySpecies: { for s in #Species {(s): [ if input.pets != _|_ for pet in input.pets if pet.species == s {{ Name: pet.name if pet.age != _|_ { Age: pet.age DoB: 2023 - pet.age } if pet.breed != _|_ { Breed: pet.breed } Owner: input.owner.name }}, ]} } Copied! data.yml Copy code Copied! owner: name: Dorothy Cartwright address: Ripon, North Yorkshire, England pets: - name: Charlie species: cat age: 15 - name: Lola species: dog breed: dachshund - name: Fred species: goldfish age: 8 - name: George species: cat age: 5 TERMINAL Copy code Copied! $ cue export .:example -l input: data.yml -e output --out yaml location: Ripon, North Yorkshire, England petsBySpecies: cat: - Age: 15 DoB: 2008 Name: Charlie Owner: Dorothy Cartwright - Age: 5 DoB: 2018 Name: George Owner: Dorothy Cartwright dog: - Breed: dachshund Name: Lola Owner: Dorothy Cartwright goldfish: - Age: 8 DoB: 2015 Name: Fred Owner: Dorothy Cartwright",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "484eb5ad9c7dbe0dfdf63f5b9db5e69c_1",
        "title": "Upgrading from evalv2 to evalv3",
        "link": "/docs/concept/faq/upgrading-from-evalv2-to-evalv3/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cdiv class=\"note note--warn\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003eevalv3\u003c/code\u003e is now \u003cstrong\u003eon\u003c/strong\u003e by default in\n\u003ca href=\"https://github.com/cue-lang/cue/releases/tag/v0.13.0\"\u003e\u003ccode\u003ev0.13.0\u003c/code\u003e\u003c/a\u003e\nand later versions!\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"what-is-evalv3\"\u003e\n    \u003ca href=\"#what-is-evalv3\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWhat is \u003ccode\u003eevalv3\u003c/code\u003e?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eevalv3\u003c/code\u003e is a new major version of the CUE evaluator which brings many enhancements,\nsuch as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea new disjunction algorithm\u003c/li\u003e\n\u003cli\u003ea new cycle detection algorithm\u003c/li\u003e\n\u003cli\u003ea new closedness algorithm, and\u003c/li\u003e\n\u003cli\u003ea new \u003ca href=\"/docs/reference/command/cue-help-trim/\"\u003e\u003ccode\u003ecue trim\u003c/code\u003e\u003c/a\u003e algorithm.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMost importantly, the new version unlocks many performance improvements which\ntarget larger CUE configurations.\u003c/p\u003e\n\u003cp\u003eThe old evaluator, \u003ccode\u003eevalv2\u003c/code\u003e, is affected by dozens of bugs which would have\nbeen very difficult to fix incrementally due to limitations in its design. Many\nof these bugs are already\n\u003ca href=\"https://github.com/cue-lang/cue/issues?q=is%3Aissue%20label%3Aevalv3-win\"\u003efixed in \u003ccode\u003eevalv3\u003c/code\u003e\u003c/a\u003e,\nwith more improvements still to come.\u003c/p\u003e",
        "content": "evalv3 is now on by default in v0.13.0 and later versions! What is evalv3? evalv3 is a new major version of the CUE evaluator which brings many enhancements, such as: a new disjunction algorithm a new cycle detection algorithm a new closedness algorithm, and a new cue trim algorithm. Most importantly, the new version unlocks many performance improvements which target larger CUE configurations. The old evaluator, evalv2, is affected by dozens of bugs which would have been very difficult to fix incrementally due to limitations in its design. Many of these bugs are already fixed in evalv3, with more improvements still to come. How can I switch to evalv3? The most reliable way to get started using evalv3 is to install or use the v0.13.0 release, where evalv3 is on by default. Simply ensure that the environment variable CUE_EXPERIMENT is empty to get the default behavior. You can also explicitly enable evalv3 by setting the CUE_EXPERIMENT=evalv3=1 environment variable. This variable affects invocations of the cue command (such as cue export) as well as Go programs using CUE\u0026rsquo;s Go API such as cue/load. Users of the Go API can also directly specify the evaluator version with a cuecontext option: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; ) func main() { ctx := cuecontext.New(cuecontext.EvaluatorVersion(cuecontext.EvalV3)) v := ctx.CompileString(\u0026#34;42\u0026#34;) fmt.Println(v) } Which CUE version do I need to use evalv3? Given that this new evaluator version is being actively developed, we encourage you to upgrade to the latest CUE version to use it: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... If you encounter any unexpected issues, we would also encourage you to try evalv3 on the development version of CUE, as your issue may have already been fixed since the latest release. What might break when I switch to evalv3? We expect the vast majority of users to be able to upgrade to evalv3 seamlessly, thanks to the continuous testing of third party projects provided by Unity. Add your project to the Unity corpus to ensure it is tested with future language and evaluator changes. If you encounter a new bug which still happens with the development version of CUE, and it\u0026rsquo;s not already tracked on GitHub, please file a new bug report with details. Related content Reference: cue help environment \u0026ndash; environment variables that affect CUE\u0026rsquo;s operation evalv2 bugs fixed in evalv3 Known evalv3 regressions Reference: cue help trim \u0026ndash; the built-in help text for the cue trim command",
        "breadcrumb": ["Documentation","Concept Guides","Frequently Asked Questions"],
        "contentType": "Concept Guides",
        "tags": "",
        "authors": ["mvdan","jpluscplusm"]
    },
    
            {
        "objectID": "16a5d73ef0d6f771a1577a418b239602_1",
        "title": "Using \"encoding/base64.Decode\"",
        "link": "/docs/howto/use-encoding-base64-decode/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/base64#Decode\"\u003e\u003ccode\u003eencoding/base64.Decode\u003c/code\u003e\u003c/a\u003e\nto decode data that is encoded as Base64.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/base64.Decode to decode data that is encoded as Base64. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/base64\u0026#34; // encoded contains some Base64-encoded data encoded: \u0026#34;c29tZSBCYXNlNjQtZW5jb2RlZCBkYXRh\u0026#34; // decoded contains the string interpolation of // the byte array returned by base64.Decode decoded: \u0026#34;\\(base64.Decode(null, encoded))\u0026#34; TERMINAL Copy code Copied! $ cue export { \u0026#34;encoded\u0026#34;: \u0026#34;c29tZSBCYXNlNjQtZW5jb2RlZCBkYXRh\u0026#34;, \u0026#34;decoded\u0026#34;: \u0026#34;some Base64-encoded data\u0026#34; } Related content The encoding/base64 built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4cbc620f6a1d83ab9c6deec0aa54b5cc_1",
        "title": "Using \"encoding/base64.Encode\"",
        "link": "/docs/howto/use-encoding-base64-encode/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/base64#Encode\"\u003e\u003ccode\u003eencoding/base64.Encode\u003c/code\u003e\u003c/a\u003e\nto encode a string as Base64.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/base64.Encode to encode a string as Base64. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/base64\u0026#34; decoded: \u0026#34;some string\u0026#34; encoded: base64.Encode(null, decoded) TERMINAL Copy code Copied! $ cue export { \u0026#34;decoded\u0026#34;: \u0026#34;some string\u0026#34;, \u0026#34;encoded\u0026#34;: \u0026#34;c29tZSBzdHJpbmc=\u0026#34; } Related content The encoding/base64 built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "86e96afd0ef22610ac538798aa7dc963_1",
        "title": "Using \"encoding/csv.Decode\" to access CSV data stored as a string",
        "link": "/docs/howto/use-encoding-csv-decode-to-access-csv-data-stored-as-a-string/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/csv#Decode\"\u003e\u003ccode\u003eencoding/csv.Decode\u003c/code\u003e\u003c/a\u003e\nto decode a string containing comma-separated values (CSV) into a list of\nlists.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/csv.Decode to decode a string containing comma-separated values (CSV) into a list of lists. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/csv\u0026#34; data: \u0026#34;\u0026#34;\u0026#34; Id,Name,Location,Species 1,Charlie,\u0026#34;Ripon, North Yorkshire\u0026#34;,cat 2,Fred,San Francisco,cat 3,Greyfriars Bobby,Edinburgh,dog 4,Nemo,???,fish \u0026#34;\u0026#34;\u0026#34; output: csv.Decode(data) TERMINAL Copy code Copied! $ cue export -e output [ [ \u0026#34;Id\u0026#34;, \u0026#34;Name\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Species\u0026#34; ], [ \u0026#34;1\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026#34;Ripon, North Yorkshire\u0026#34;, \u0026#34;cat\u0026#34; ], [ \u0026#34;2\u0026#34;, \u0026#34;Fred\u0026#34;, \u0026#34;San Francisco\u0026#34;, \u0026#34;cat\u0026#34; ], [ \u0026#34;3\u0026#34;, \u0026#34;Greyfriars Bobby\u0026#34;, \u0026#34;Edinburgh\u0026#34;, \u0026#34;dog\u0026#34; ], [ \u0026#34;4\u0026#34;, \u0026#34;Nemo\u0026#34;, \u0026#34;???\u0026#34;, \u0026#34;fish\u0026#34; ] ] Related content The encoding/csv built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "cc18847b6d943a4681e8d9c94d8a793c_1",
        "title": "Using \"encoding/csv.Decode\" to access data stored in a CSV file",
        "link": "/docs/howto/use-encoding-csv-decode-to-access-data-stored-in-a-csv-file/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/csv#Decode\"\u003e\u003ccode\u003eencoding/csv.Decode\u003c/code\u003e\u003c/a\u003e\nto decode a file containing comma-separated values (CSV) into a list of lists.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/csv.Decode to decode a file containing comma-separated values (CSV) into a list of lists. Copied! data.csv Copy code Copied! Id,Name,Location,Species 1,Charlie,\u0026#34;Ripon, North Yorkshire\u0026#34;,cat 2,Fred,San Francisco,cat 3,Greyfriars Bobby,Edinburgh,dog 4,Nemo,???,fish Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/csv\u0026#34; input: string output: csv.Decode(input) TERMINAL Copy code Copied! $ cue export file.cue -l input: text: data.csv -e output [ [ \u0026#34;Id\u0026#34;, \u0026#34;Name\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Species\u0026#34; ], [ \u0026#34;1\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026#34;Ripon, North Yorkshire\u0026#34;, \u0026#34;cat\u0026#34; ], [ \u0026#34;2\u0026#34;, \u0026#34;Fred\u0026#34;, \u0026#34;San Francisco\u0026#34;, \u0026#34;cat\u0026#34; ], [ \u0026#34;3\u0026#34;, \u0026#34;Greyfriars Bobby\u0026#34;, \u0026#34;Edinburgh\u0026#34;, \u0026#34;dog\u0026#34; ], [ \u0026#34;4\u0026#34;, \u0026#34;Nemo\u0026#34;, \u0026#34;???\u0026#34;, \u0026#34;fish\u0026#34; ] ] Related content The encoding/csv built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "dfd01f7da77102ad6b54b069bd32696d_1",
        "title": "Using \"encoding/csv.Encode\" to emit CSV data",
        "link": "/docs/howto/use-encoding-csv-encode-to-emit-csv-data/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/csv#Encode\"\u003e\u003ccode\u003eencoding/csv.Encode\u003c/code\u003e\u003c/a\u003e\nto encode a list of lists into a string as comma-separated values (CSV).\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/csv.Encode to encode a list of lists into a string as comma-separated values (CSV). Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/csv\u0026#34; data: [ [\u0026#34;Id\u0026#34;, \u0026#34;Name\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Species\u0026#34;], [\u0026#34;1\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026#34;Ripon, North Yorkshire\u0026#34;, \u0026#34;cat\u0026#34;], [\u0026#34;2\u0026#34;, \u0026#34;Fred\u0026#34;, \u0026#34;San Francisco\u0026#34;, \u0026#34;cat\u0026#34;], [\u0026#34;3\u0026#34;, \u0026#34;Greyfriars Bobby\u0026#34;, \u0026#34;Edinburgh\u0026#34;, \u0026#34;dog\u0026#34;], [\u0026#34;4\u0026#34;, \u0026#34;Nemo\u0026#34;, \u0026#34;???\u0026#34;, \u0026#34;fish\u0026#34;], ] output: csv.Encode(data) TERMINAL Copy code Copied! $ cue export -e output --out text Id,Name,Location,Species 1,Charlie,\u0026#34;Ripon, North Yorkshire\u0026#34;,cat 2,Fred,San Francisco,cat 3,Greyfriars Bobby,Edinburgh,dog 4,Nemo,???,fish Related content The encoding/csv built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "a8d84e88d34187410abb132e5b7d0c8e_1",
        "title": "Using \"encoding/json.Compact\" to produce single-line JSON from a file",
        "link": "/docs/howto/use-encoding-json-compact-to-produce-single-line-json-from-a-file/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Compact\"\u003e\u003ccode\u003eencoding/json.Compact\u003c/code\u003e\u003c/a\u003e\nto transform a JSON file into a single line of JSON with all insignificant\nwhitespace removed.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Compact to transform a JSON file into a single line of JSON with all insignificant whitespace removed. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; compact: json.Compact(json.Marshal(input)) // The contents of data.json is placed here by // the -l parameter. input: _ Copied! data.json Copy code Copied! { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;d\u0026#34;: 3.0 }, \u0026#34;e\u0026#34;: false, \u0026#34;f\u0026#34;: [ 4, 5.0, \u0026#34;A\\nMulti\\nLine\\nString\u0026#34; ] } TERMINAL Copy code Copied! $ cue export file.cue -l input: data.json -e compact --out text {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:{\u0026#34;c\u0026#34;:\u0026#34;two\u0026#34;,\u0026#34;d\u0026#34;:3.0},\u0026#34;e\u0026#34;:false,\u0026#34;f\u0026#34;:[4,5.0,\u0026#34;A\\nMulti\\nLine\\nString\u0026#34;]} Related content The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "c48ea2d6cebc5c6aa1ac799eda2dc5c0_1",
        "title": "Using \"encoding/json.Compact\" to produce single-line JSON from a string",
        "link": "/docs/howto/use-encoding-json-compact-to-produce-single-line-json-from-a-string/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Compact\"\u003e\u003ccode\u003eencoding/json.Compact\u003c/code\u003e\u003c/a\u003e\nto transform JSON held in a string into a single line of JSON with all\ninsignificant whitespace removed.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Compact to transform JSON held in a string into a single line of JSON with all insignificant whitespace removed. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; compact: json.Compact(jsonString) // jsonString contains insignificant whitespace, // split over several lines. jsonString: #\u0026#34;\u0026#34;\u0026#34; { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;d\u0026#34;: 3.0 }, \u0026#34;e\u0026#34;: false, \u0026#34;f\u0026#34;: [ 4, 5.0, \u0026#34;A\\nMulti\\nLine\\nString\u0026#34; ] } \u0026#34;\u0026#34;\u0026#34;# TERMINAL Copy code Copied! $ cue export -e compact --out text {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:{\u0026#34;c\u0026#34;:\u0026#34;two\u0026#34;,\u0026#34;d\u0026#34;:3.0},\u0026#34;e\u0026#34;:false,\u0026#34;f\u0026#34;:[4,5.0,\u0026#34;A\\nMulti\\nLine\\nString\u0026#34;]} Related content The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "f2f1eee56b8e99bbcb42a7277ddaf6f5_1",
        "title": "Using \"encoding/json.Compact\" to produce single-line JSON from CUE data",
        "link": "/docs/howto/use-encoding-json-compact-to-produce-single-line-json-from-cue-data/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Compact\"\u003e\u003ccode\u003eencoding/json.Compact\u003c/code\u003e\u003c/a\u003e\nto transform CUE data into a single line of JSON with all insignificant\nwhitespace removed.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Compact to transform CUE data into a single line of JSON with all insignificant whitespace removed. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; compact: json.Compact(json.Marshal(data)) data: { a: 1 b: { c: \u0026#34;two\u0026#34; d: 3.0 } e: false f: [ 4, 5.0, \u0026#34;\u0026#34;\u0026#34; A Multi Line String \u0026#34;\u0026#34;\u0026#34;, ] } TERMINAL Copy code Copied! $ cue export file.cue -e compact --out text {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:{\u0026#34;c\u0026#34;:\u0026#34;two\u0026#34;,\u0026#34;d\u0026#34;:3.0},\u0026#34;e\u0026#34;:false,\u0026#34;f\u0026#34;:[4,5.0,\u0026#34;A\\nMulti\\nLine\\nString\u0026#34;]} Related content The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "eeca03c3e1ef4a01c4b79a49af331bdb_1",
        "title": "Using \"encoding/json.Indent\" to produce human-readable JSON from a file",
        "link": "/docs/howto/use-encoding-json-indent-to-produce-human-readable-json-from-a-file/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Indent\"\u003e\u003ccode\u003eencoding/json.Indent\u003c/code\u003e\u003c/a\u003e\nto transform JSON from a compact, single-line form held in a file into JSON\nwith insignificant whitespace added that makes it easier for humans to read.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Indent to transform JSON from a compact, single-line form held in a file into JSON with insignificant whitespace added that makes it easier for humans to read. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; // See Related content, below, for documentation // of json.Indent\u0026#39;s 3 arguments: // func Indent(src []byte, prefix, indent string) indent: json.Indent(json.Marshal(input), \u0026#34; \u0026#34;, \u0026#34; \u0026#34;) // The contents of data.json is placed here by // the -l parameter. input: _ Copied! data.json Copy code Copied! {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:{\u0026#34;c\u0026#34;:\u0026#34;two\u0026#34;,\u0026#34;d\u0026#34;:3.0},\u0026#34;e\u0026#34;:false,\u0026#34;f\u0026#34;:[4,5.0,\u0026#34;A\\nMulti\\nLine\\nString\u0026#34;]} TERMINAL Copy code Copied! $ cue export file.cue -l input: data.json -e indent --out text { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;d\u0026#34;: 3.0 }, \u0026#34;e\u0026#34;: false, \u0026#34;f\u0026#34;: [ 4, 5.0, \u0026#34;A\\nMulti\\nLine\\nString\u0026#34; ] } Related content encoding/json.Indent documents the function\u0026rsquo;s arguments The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "88b4325d150907f440b1122e0c3f2507_1",
        "title": "Using \"encoding/json.Indent\" to produce human-readable JSON from a string",
        "link": "/docs/howto/use-encoding-json-indent-to-produce-human-readable-json-from-a-string/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Indent\"\u003e\u003ccode\u003eencoding/json.Indent\u003c/code\u003e\u003c/a\u003e\nto transform JSON from a compact, single-line form held in a string into JSON\nwith insignificant whitespace added that makes it easier for humans to read.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Indent to transform JSON from a compact, single-line form held in a string into JSON with insignificant whitespace added that makes it easier for humans to read. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; // See Related content, below, for documentation // of json.Indent\u0026#39;s 3 arguments: // func Indent(src []byte, prefix, indent string) indent: json.Indent(jsonString, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;) jsonString: #\u0026#34;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:{\u0026#34;c\u0026#34;:\u0026#34;two\u0026#34;,\u0026#34;d\u0026#34;:3.0},\u0026#34;e\u0026#34;:false,\u0026#34;f\u0026#34;:[4,5.0,\u0026#34;A\\nMulti\\nLine\\nString\u0026#34;]}\u0026#34;# TERMINAL Copy code Copied! $ cue export -e indent --out text { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;two\u0026#34;, \u0026#34;d\u0026#34;: 3.0 }, \u0026#34;e\u0026#34;: false, \u0026#34;f\u0026#34;: [ 4, 5.0, \u0026#34;A\\nMulti\\nLine\\nString\u0026#34; ] } Related content encoding/json.Indent documents the function\u0026rsquo;s arguments The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3ba3ddb10cfbadd709598e7fce125598_1",
        "title": "Using \"encoding/json.Validate\" as a field validator",
        "link": "/docs/howto/use-encoding-json-validate-as-a-field-validator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Validate\"\u003e\u003ccode\u003eencoding/json.Validate\u003c/code\u003e\u003c/a\u003e\nas a field validator.\u003c/p\u003e\n\u003cp\u003eIt asserts that properly-formed JSON, encoded in a string, adheres to specific\nconstraints by checking that the data and schema unify successfully.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function encoding/json.Validate as a field validator. It asserts that properly-formed JSON, encoded in a string, adheres to specific constraints by checking that the data and schema unify successfully. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/json\u0026#34; data: \u0026#34;\u0026#34;\u0026#34; { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: \u0026#34;two\u0026#34; } \u0026#34;\u0026#34;\u0026#34; // Validate requires only that data adheres to schema constraints. // Missing fields do not cause validation failures. data: json.Validate(_outOfBoundsSchema) data: json.Validate(_missingFieldSchema) _outOfBoundsSchema: { a!: \u0026gt;99 // validation failure b!: string } _missingFieldSchema: { a!: int b!: string c!: bool // NOT a validation failure } TERMINAL Copy code Copied! $ cue vet -c data: invalid value \u0026#34;{\\n \\\u0026#34;a\\\u0026#34;: 1,\\n \\\u0026#34;b\\\u0026#34;: \\\u0026#34;two\\\u0026#34;\\n}\u0026#34; (does not satisfy encoding/json.Validate): error in call to encoding/json.Validate: invalid value 1 (out of bound \u0026gt;99): ./file.cue:14:7 ./file.cue:5:7 ./file.cue:15:7 ./file.cue:18:6 json.Validate:2:8 encoding/json.Validate validates JSON data that is encoded in a string. To validate data stored in a separate .json file, use CUE\u0026rsquo;s native and simpler unification instead. This is documented in Validating JSON using CUE Related content How-to Guide: Using \u0026#34;encoding/yaml.Validate\u0026#34; and \u0026#34;encoding/yaml.ValidatePartial\u0026#34; as field validators The encoding/json built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "75ae260d5b30ba199ca714be7272c86b_1",
        "title": "Using \"encoding/yaml.Validate\" and \"encoding/yaml.ValidatePartial\" as field validators",
        "link": "/docs/howto/use-encoding-yaml-validate-encoding-yaml-validatepartial-as-field-validators/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/yaml#Validate\"\u003e\u003ccode\u003eencoding/yaml.Validate\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/encoding/yaml#ValidatePartial\"\u003e\u003ccode\u003eencoding/yaml.ValidatePartial\u003c/code\u003e\u003c/a\u003e\nas field validators.\u003c/p\u003e\n\u003cp\u003eThey assert that properly-formed YAML, encoded in a string, adheres to specific\nconstraints by checking that the data and schema unify successfully.\n\u003ccode\u003eencoding.yaml/Validate\u003c/code\u003e also requires that all non-optional fields are\npresent.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions encoding/yaml.Validate and encoding/yaml.ValidatePartial as field validators. They assert that properly-formed YAML, encoded in a string, adheres to specific constraints by checking that the data and schema unify successfully. encoding.yaml/Validate also requires that all non-optional fields are present. Copied! file.cue Copy code Copied! package example import \u0026#34;encoding/yaml\u0026#34; data: \u0026#34;\u0026#34;\u0026#34; a: 1 b: \u0026#34;two\u0026#34; \u0026#34;\u0026#34;\u0026#34; // Validate requires that all non-optional fields in a schema are present in // data, and that data adheres to schema constraints. data: yaml.Validate(_outOfBoundsSchema) data: yaml.Validate(_missingFieldSchema) // ValidatePartial requires only that data adheres to schema constraints. data: yaml.ValidatePartial(_outOfBoundsSchema) data: yaml.ValidatePartial(_missingFieldSchema) _outOfBoundsSchema: { a!: \u0026gt;99 // validation failure for both functions b!: string } _missingFieldSchema: { a!: int b!: string c!: bool // validation failure for yaml.Validate only } TERMINAL Copy code Copied! $ cue vet -c data: invalid value \u0026#34;a: 1\\nb: \\\u0026#34;two\\\u0026#34;\u0026#34; (does not satisfy encoding/yaml.Validate): error in call to encoding/yaml.Validate: invalid value 1 (out of bound \u0026gt;99): ./file.cue:12:7 ./file.cue:5:7 ./file.cue:13:7 ./file.cue:16:7 ./file.cue:17:7 ./file.cue:20:6 yaml.Validate:1:4 data: invalid value \u0026#34;a: 1\\nb: \\\u0026#34;two\\\u0026#34;\u0026#34; (does not satisfy encoding/yaml.Validate): error in call to encoding/yaml.Validate: field is required but not present: ./file.cue:13:7 ./file.cue:5:7 ./file.cue:12:7 ./file.cue:16:7 ./file.cue:17:7 ./file.cue:26:2 data: invalid value \u0026#34;a: 1\\nb: \\\u0026#34;two\\\u0026#34;\u0026#34; (does not satisfy encoding/yaml.ValidatePartial): error in call to encoding/yaml.ValidatePartial: invalid value 1 (out of bound \u0026gt;99): ./file.cue:16:7 ./file.cue:5:7 ./file.cue:12:7 ./file.cue:13:7 ./file.cue:17:7 ./file.cue:20:6 yaml.ValidatePartial:1:4 These functions validate YAML data that is encoded in a string. To validate data stored in a separate .yaml file, use CUE\u0026rsquo;s native and simpler unification instead. This is documented in Validating YAML using CUE Related content How-to Guide: Using \u0026#34;encoding/json.Validate\u0026#34; as a field validator The encoding/yaml built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3b5f492e5a8d346760716843e35c0c41_1",
        "title": "Using \"list.Avg\", \"list.Max\", \"list.Min, and \"list.Sum\" to summarise lists of numbers",
        "link": "/docs/howto/use-list-avg-list-max-list-min-list-sum-to-summarise-lists-of-numbers/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Avg\"\u003e\u003ccode\u003elist.Avg\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Max\"\u003e\u003ccode\u003elist.Max\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Min\"\u003e\u003ccode\u003elist.Min\u003c/code\u003e\u003c/a\u003e, and\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Sum\"\u003e\u003ccode\u003elist.Sum\u003c/code\u003e\u003c/a\u003e\nto calculate various simple summary statistics for a list of numbers including\nthe list\u0026rsquo;s arithmetic mean, its maximum and minimum values, and the sum of its\nvalues.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions list.Avg, list.Max, list.Min, and list.Sum to calculate various simple summary statistics for a list of numbers including the list\u0026rsquo;s arithmetic mean, its maximum and minimum values, and the sum of its values. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; sum: list.Sum(_data) min: list.Min(_data) max: list.Max(_data) mean: list.Avg(_data) _data: [ -0.00000000001, 0, 1, 5, 10, 42, -999, ] TERMINAL Copy code Copied! $ cue eval sum: -941.00000000001 min: -999 max: 42 mean: -134.4285714285728571428571428571429 Related content The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "7ef3e16d61d866b437ec39d11622825e_1",
        "title": "Using \"list.Concat\" to concatenate lists",
        "link": "/docs/howto/use-list-concat-to-concatenate-lists/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Concat\"\u003e\u003ccode\u003elist.Concat\u003c/code\u003e\u003c/a\u003e\nto concatenate a list of lists.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.Concat to concatenate a list of lists. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; output: list.Concat([listA, listB, listC, listB]) listA: [1, 2, 3, 4] listB: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] listC: [{ a: 10 b: \u0026#34;10\u0026#34; }, { a: 11 b: \u0026#34;11\u0026#34; }, { a: 12 b: \u0026#34;12\u0026#34; }] TERMINAL Copy code Copied! $ cue export -e output [ 1, 2, 3, 4, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, { \u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: \u0026#34;10\u0026#34; }, { \u0026#34;a\u0026#34;: 11, \u0026#34;b\u0026#34;: \u0026#34;11\u0026#34; }, { \u0026#34;a\u0026#34;: 12, \u0026#34;b\u0026#34;: \u0026#34;12\u0026#34; }, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34; ] Related content The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "e0c1948d4b6e8f1ecbf5efefac4f2de5_1",
        "title": "Using \"list.Contains\" as a field validator",
        "link": "/docs/howto/use-list-contains-as-a-field-validator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Contains\"\u003e\u003ccode\u003elist.Contains\u003c/code\u003e\u003c/a\u003e\nas a validator that checks if a simple or composite value is contained in a\nlist.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.Contains as a validator that checks if a simple or composite value is contained in a list. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // aList is the example list searched through in this guide. aList: [ 1, \u0026#34;two\u0026#34;, {asInt: 3, asString: \u0026#34;three\u0026#34;}, [4, \u0026#34;four\u0026#34;], ] // When unified with a list, list.Contains searches through the list and emits // an error if the given value is not an element of that list. aList: list.Contains(1) aList: list.Contains(\u0026#34;TWO\u0026#34;) // validation failure // When searching for a struct or a list value, rules are followed to determine // if the value is equal to any of the elements being compared. // The tracking issue for these rules is // https://github.com/cue-lang/docs-and-content/issues/49 aList: list.Contains({asInt: 3}) // validation failure aList: list.Contains({asInt: 3, asString: \u0026#34;three\u0026#34;}) aList: list.Contains([4, \u0026#34;four\u0026#34;]) aList: list.Contains([\u0026#34;four\u0026#34;, 4, 4.0]) // validation failure TERMINAL Copy code Copied! $ cue vet -c aList: invalid value [1,\u0026#34;two\u0026#34;,{asInt:3,asString:\u0026#34;three\u0026#34;},[4,\u0026#34;four\u0026#34;]] (does not satisfy list.Contains(\u0026#34;TWO\u0026#34;)): ./file.cue:15:8 ./file.cue:6:8 ./file.cue:14:8 ./file.cue:15:22 ./file.cue:21:8 ./file.cue:22:8 ./file.cue:23:8 ./file.cue:24:8 aList: invalid value [1,\u0026#34;two\u0026#34;,{asInt:3,asString:\u0026#34;three\u0026#34;},[4,\u0026#34;four\u0026#34;]] (does not satisfy list.Contains({asInt:3})): ./file.cue:21:8 ./file.cue:6:8 ./file.cue:14:8 ./file.cue:15:8 ./file.cue:22:8 ./file.cue:23:8 ./file.cue:24:8 aList: invalid value [1,\u0026#34;two\u0026#34;,{asInt:3,asString:\u0026#34;three\u0026#34;},[4,\u0026#34;four\u0026#34;]] (does not satisfy list.Contains([\u0026#34;four\u0026#34;,4,4.0])): ./file.cue:24:8 ./file.cue:6:8 ./file.cue:14:8 ./file.cue:15:8 ./file.cue:21:8 ./file.cue:22:8 ./file.cue:23:8 Issue cue-lang/docs-and-content#49 tracks the documentation of precisely what CUE means by values being \u0026ldquo;equivalent\u0026rdquo;, \u0026ldquo;equal\u0026rdquo;, or \u0026ldquo;comparable\u0026rdquo;. When this documentation is complete it will be linked to from this guide. Related content How-to Guide: Using \u0026#34;list.Contains\u0026#34; to report if a value is in a list The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "f621901ab13c7b9c082ebbe290fdd149_1",
        "title": "Using \"list.Contains\" to report if a value is in a list",
        "link": "/docs/howto/use-list-contains-to-report-if-a-value-is-in-a-list/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Contains\"\u003e\u003ccode\u003elist.Contains\u003c/code\u003e\u003c/a\u003e\nto report if a simple or composite value is contained in a list.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.Contains to report if a simple or composite value is contained in a list. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // list.Contains searches through a list and reports if the given value is an // element of that list. containsIntTrue: list.Contains( [1, 2, 3, 4, 5], 4) containsIntFalse: list.Contains([1, 2, 3, 4, 5], 99) // _source is the example list searched through in this guide. _source: [ 1, \u0026#34;two\u0026#34;, {asInt: 3, asString: \u0026#34;three\u0026#34;}, [4, \u0026#34;four\u0026#34;], ] // When searching for a basic type, comparison is straight forward. containsStringFalse: list.Contains(_source, \u0026#34;TWO\u0026#34;) // When searching for a struct or a list value, rules are followed to determine // if the value is equal to any of the elements being compared. // The tracking issue for these rules is // https://github.com/cue-lang/docs-and-content/issues/49 containsStructFalse: list.Contains(_source, {asInt: 3}) containsStructTrue: list.Contains( _source, {asInt: 3, asString: \u0026#34;three\u0026#34;}) containsListTrue: list.Contains( _source, [4, \u0026#34;four\u0026#34;]) containsListFalse: list.Contains(_source, [\u0026#34;four\u0026#34;, 4, 4.0]) TERMINAL Copy code Copied! $ cue eval containsIntTrue: true containsIntFalse: false containsStringFalse: false containsStructFalse: false containsStructTrue: true containsListTrue: true containsListFalse: false Issue cue-lang/docs-and-content#49 tracks the documentation of precisely what CUE means by values being \u0026ldquo;equivalent\u0026rdquo;, \u0026ldquo;equal\u0026rdquo;, or \u0026ldquo;comparable\u0026rdquo;. When this documentation is complete it will be linked to from this guide. Related content How-to Guide: Using \u0026#34;list.Contains\u0026#34; as a field validator The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "754d70f0fc6b5faa52200ebbb4fefdfa_1",
        "title": "Using \"list.FlattenN\" to flatten lists",
        "link": "/docs/howto/use-list-flattenn-to-flatten-lists/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#FlattenN\"\u003e\u003ccode\u003elist.FlattenN\u003c/code\u003e\u003c/a\u003e\nto flatten a list by expanding its list elements by a specified depth.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.FlattenN to flatten a list by expanding its list elements by a specified depth. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; // src is a list (of lists (of lists ...)), defined below. src: [...] // one transforms src by expanding its first-level list elements. one: list.FlattenN(src, 1) // two transforms src by expanding its first- and second-level list elements. two: list.FlattenN(src, 2) // all transforms src by expanding all its list elements, recursively, no // matter their depth. all: list.FlattenN(src, -1) src: [ 1, 2, 3, [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], [ [4, 5, 6], [ [\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;], [[7, 8, 9]], ], ], [[[[[\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;]]]]], ] TERMINAL Copy code Copied! $ cue eval src: [1, 2, 3, [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], [[4, 5, 6], [[\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;], [[7, 8, 9]]]], [[[[[\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;]]]]]] one: [1, 2, 3, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, [4, 5, 6], [[\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;], [[7, 8, 9]]], [[[[\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;]]]]] two: [1, 2, 3, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, 4, 5, 6, [\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;], [[7, 8, 9]], [[[\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;]]]] all: [1, 2, 3, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, 4, 5, 6, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, 7, 8, 9, \u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;] Related content The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "0bd35af0f707af737ae57f49c83258b6_1",
        "title": "Using \"list.IsSorted\" as a field validator",
        "link": "/docs/howto/use-list-issorted-as-a-field-validator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#IsSorted\"\u003e\u003ccode\u003elist.IsSorted\u003c/code\u003e\u003c/a\u003e\nas a field validator to assert that lists are sorted, using either a predefined\nor custom comparator.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.IsSorted as a field validator to assert that lists are sorted, using either a predefined or custom comparator. Copied! file.cue Copy code Copied! package example import ( \u0026#34;list\u0026#34; // The strings package is only imported for some examples in this // guide, and is not required when using list.IsSorted. \u0026#34;strings\u0026#34; ) // For lists of numbers or lists of strings, list.IsSorted can be provided // with the predefined comparator list.Ascending or list.Descending. isSorted: [1, 2.2, 3] \u0026amp; list.IsSorted(list.Ascending) // See related content, below, for a list.IsSortedStrings example. stringsDescending: list.IsSorted(list.Descending) // validation failure stringsDescending: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] // Mixed type lists require a custom comparator containing a \u0026#34;less\u0026#34; field that // encodes a comparison between its \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; fields, reflecting x\u0026lt;y. See // list.Sort for details. structsCustom: list.IsSorted({x: {}, y: {}, less: x.a \u0026lt; y.a}) structsCustom: [{a: 1}, {a: 2}, {a: 3}] // This comparator tests if lists of strings are in descending order of how // many \u0026#34;@\u0026#34; characters they contain. _sortAtSymbolCountDescending: { x: string y: string less: strings.Count(x, \u0026#34;@\u0026#34;) \u0026gt; strings.Count(y, \u0026#34;@\u0026#34;) } stringsCountDescending: [\u0026#34;@\u0026#34;, \u0026#34;@@\u0026#34;, \u0026#34;X\u0026#34;] stringsCountDescending: list.IsSorted(_sortAtSymbolCountDescending) // validation failure TERMINAL Copy code Copied! $ cue vet -c stringsDescending: invalid value [\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;] (does not satisfy list.IsSorted({T:number | string,x:number | string,y:number | string,less:_|_(Descending.less: unresolved disjunction number | string (type (string|number)) (and 1 more errors))})): ./file.cue:16:20 ./file.cue:17:20 stringsCountDescending: invalid value [\u0026#34;@\u0026#34;,\u0026#34;@@\u0026#34;,\u0026#34;X\u0026#34;] (does not satisfy list.IsSorted({x:string,y:string,less:_|_(_sortAtSymbolCountDescending.less: error in call to strings.Count: non-concrete value string (and 1 more errors))})): ./file.cue:33:25 ./file.cue:32:25 Related content list.Sort documents the comparator schema and fields How-to Guide: Using \u0026#34;list.IsSorted\u0026#34; to report if lists are sorted How-to Guide: Using \u0026#34;list.IsSortedStrings\u0026#34; as a field validator The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "9fcc86dea307a783a21ed9b2f29cec25_1",
        "title": "Using \"list.IsSorted\" to report if lists are sorted",
        "link": "/docs/howto/use-list-issorted-to-report-if-lists-are-sorted/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#IsSorted\"\u003e\u003ccode\u003elist.IsSorted\u003c/code\u003e\u003c/a\u003e\nto test and report if lists are sorted, using either a predefined or custom\ncomparator.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.IsSorted to test and report if lists are sorted, using either a predefined or custom comparator. Copied! file.cue Copy code Copied! package example import ( \u0026#34;list\u0026#34; // The strings package is only imported for some examples in this // guide, and is not required when using list.IsSorted. \u0026#34;strings\u0026#34; ) // For lists of numbers or lists of strings, list.IsSorted can be provided // with the predefined comparator list.Ascending or list.Descending. isSorted: list.IsSorted([1, 2.2, 3], list.Ascending) // See related content, below, for a list.IsSortedStrings example. stringsDescending: list.IsSorted([\u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;], list.Descending) // Mixed type lists require a custom comparator containing a \u0026#34;less\u0026#34; field that // encodes a comparison between its \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; fields, reflecting x\u0026lt;y. See // list.Sort for details. structsCustomTrue: list.IsSorted( [{a: 1}, {a: 2}, {a: 3}], {x: {}, y: {}, less: x.a \u0026lt; y.a}) structsCustomFalse: list.IsSorted([{a: 2}, {a: 3}, {a: 1}], {x: {}, y: {}, less: x.a \u0026lt; y.a}) // This comparator tests if lists of strings are in descending order of how // many \u0026#34;@\u0026#34; characters they contain. _sortAtSymbolCountDescending: { x: string y: string less: strings.Count(x, \u0026#34;@\u0026#34;) \u0026gt; strings.Count(y, \u0026#34;@\u0026#34;) } stringsCountDescendingTrue: list.IsSorted( [\u0026#34;@@\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;X\u0026#34;], _sortAtSymbolCountDescending) stringsCountDescendingFalse: list.IsSorted([\u0026#34;X\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;@@\u0026#34;], _sortAtSymbolCountDescending) TERMINAL Copy code Copied! $ cue eval isSorted: true stringsDescending: true structsCustomTrue: true structsCustomFalse: false stringsCountDescendingTrue: true stringsCountDescendingFalse: false Related content list.Sort documents the comparator schema and fields How-to Guide: Using \u0026#34;list.IsSorted\u0026#34; as a field validator How-to Guide: Using \u0026#34;list.IsSortedStrings\u0026#34; to report if lists of strings are sorted The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "9c793634ba25aa83baffc2b379659e88_1",
        "title": "Using \"list.IsSortedStrings\" as a field validator",
        "link": "/docs/howto/use-list-issortedstrings-as-a-field-validator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#IsSortedStrings\"\u003e\u003ccode\u003elist.IsSortedStrings\u003c/code\u003e\u003c/a\u003e\nas a field validator to assert that lists of strings are sorted alphabetically.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.IsSortedStrings as a field validator to assert that lists of strings are sorted alphabetically. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; sorted: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] unsorted: [\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;] sorted: list.IsSortedStrings unsorted: list.IsSortedStrings // validation failure TERMINAL Copy code Copied! $ cue eval unsorted: invalid value [\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;A\u0026#34;] (does not satisfy list.IsSortedStrings): ./file.cue:6:11 ./file.cue:9:11 Related content How-to Guide: Using \u0026#34;list.IsSortedStrings\u0026#34; to report if lists of strings are sorted How-to Guide: Using \u0026#34;list.IsSorted\u0026#34; as a field validator The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "937b8efac4e2216f10d688847cc5a9a6_1",
        "title": "Using \"list.IsSortedStrings\" to report if lists of strings are sorted",
        "link": "/docs/howto/use-list-issortedstrings-to-report-if-lists-of-strings-are-sorted/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#IsSortedStrings\"\u003e\u003ccode\u003elist.IsSortedStrings\u003c/code\u003e\u003c/a\u003e\nto test and report if lists of strings are sorted alphabetically.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.IsSortedStrings to test and report if lists of strings are sorted alphabetically. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; _unsorted: [\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;] _sorted: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] testUnsorted: list.IsSortedStrings(_unsorted) testSorted: list.IsSortedStrings(_sorted) TERMINAL Copy code Copied! $ cue eval testUnsorted: false testSorted: true Related content How-to Guide: Using \u0026#34;list.IsSortedStrings\u0026#34; as a field validator How-to Guide: Using \u0026#34;list.IsSorted\u0026#34; to report if lists are sorted The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "b5eb38fbd89c272feb3a43e3477eac57_1",
        "title": "Using \"list.MaxItems\" and \"list.MinItems\" to constrain the length of a list",
        "link": "/docs/howto/use-list-maxitems-list-minitems-to-constrain-list-length/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#MaxItems\"\u003e\u003ccode\u003elist.MaxItems\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#MinItems\"\u003e\u003ccode\u003elist.MinItems\u003c/code\u003e\u003c/a\u003e\nto require that a list contains a maximum and/or minimum number of items.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions list.MaxItems and list.MinItems to require that a list contains a maximum and/or minimum number of items. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; a: [1, 2, 3, 4, 5] b: [1, 2, 3, 4, 5] c: [1, 2, 3, 4, 5] // a must contain no more than 2 items a: list.MaxItems(2) // b must contain at least 6 items b: list.MinItems(6) // c must contain at least 2 items, and no more than 6 items c: list.MinItems(2) \u0026amp; list.MaxItems(6) TERMINAL Copy code Copied! $ cue vet -c a: invalid value [1,2,3,4,5] (does not satisfy list.MaxItems(2)): len(list) \u0026gt; MaxItems(2) (5 \u0026gt; 2): ./file.cue:10:4 ./file.cue:5:4 ./file.cue:10:18 b: invalid value [1,2,3,4,5] (does not satisfy list.MinItems(6)): len(list) \u0026lt; MinItems(6) (5 \u0026lt; 6): ./file.cue:13:4 ./file.cue:6:4 ./file.cue:13:18 Alternative to list.MinItems If the number of required items is both small and known in advance, then this core language syntax might be preferred instead of list.MinItems: Copied! file.cue Copy code Copied! package example // f must contain at least 3 elements f: [_, _, _, ...] f: [1, 2] TERMINAL Copy code Copied! $ cue vet -c f: incompatible list lengths (2 and 3): ./file.cue:6:4 Related content The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "c5812493e76065fcf8687e97341804f5_1",
        "title": "Using \"list.Sort\" to sort lists",
        "link": "/docs/howto/use-list-sort-to-sort-lists/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#Sort\"\u003e\u003ccode\u003elist.Sort\u003c/code\u003e\u003c/a\u003e\nto sort lists, using either a predefined or custom comparator.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.Sort to sort lists, using either a predefined or custom comparator. Copied! file.cue Copy code Copied! package example import ( \u0026#34;list\u0026#34; // The strings package is only imported for some examples in this // guide, and is not required when using list.Sort. \u0026#34;strings\u0026#34; ) // For lists of numbers or lists of strings, list.Sort can be provided with the // predefined comparator list.Ascending or list.Descending. sort: list.Sort([2.2, 3, 1], list.Ascending) // See related content, below, for a list.SortStrings example. stringsDescending: list.Sort([\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;], list.Descending) // Mixed type lists require a custom comparator containing a \u0026#34;less\u0026#34; field that // encodes a comparison between its \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; fields, reflecting x\u0026lt;y. See // list.Sort\u0026#39;s documentation for details. structsCustom: list.Sort([{a: 2}, {a: 3}, {a: 1}], {x: {}, y: {}, less: x.a \u0026lt; y.a}) // This comparator tests if lists of strings are in descending order of how // many \u0026#34;@\u0026#34; characters they contain. _sortAtSymbolCountDescending: { x: string y: string less: strings.Count(x, \u0026#34;@\u0026#34;) \u0026gt; strings.Count(y, \u0026#34;@\u0026#34;) } stringsCountDescending: list.Sort( [\u0026#34;X\u0026#34;, \u0026#34;@@\u0026#34;, \u0026#34;@\u0026#34;], _sortAtSymbolCountDescending) TERMINAL Copy code Copied! $ cue eval sort: [1, 2.2, 3] stringsDescending: [\u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;] structsCustom: [{ a: 1 }, { a: 2 }, { a: 3 }] stringsCountDescending: [\u0026#34;@@\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;X\u0026#34;] Related content list.Sort documents the comparator schema and fields. How-to Guide: Using \u0026#34;list.SortStrings\u0026#34; to sort lists of strings The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "48e9c94851c4e4c45aab67ae9aaf9e9a_1",
        "title": "Using \"list.SortStrings\" to sort lists of strings",
        "link": "/docs/howto/use-list-sortstrings-to-sort-lists-of-strings/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#SortStrings\"\u003e\u003ccode\u003elist.SortStrings\u003c/code\u003e\u003c/a\u003e\nto sort lists of strings alphabetically.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.SortStrings to sort lists of strings alphabetically. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; unsorted: [\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;] sorted: list.SortStrings(unsorted) TERMINAL Copy code Copied! $ cue eval unsorted: [\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;A\u0026#34;] sorted: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] Related content How-to Guide: Using \u0026#34;list.Sort\u0026#34; to sort lists The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "41d42426be568cbe56a0b1ab5a1c44b2_1",
        "title": "Using \"list.UniqueItems\" as a field validator",
        "link": "/docs/howto/use-list-uniqueitems-as-a-field-validator/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/list#UniqueItems\"\u003e\u003ccode\u003elist.UniqueItems\u003c/code\u003e\u003c/a\u003e\nto ensure that a list\u0026rsquo;s items are unique.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function list.UniqueItems to ensure that a list\u0026rsquo;s items are unique. Copied! file.cue Copy code Copied! package example import \u0026#34;list\u0026#34; aList: list.UniqueItems aList: [1, 2.0, 3, \u0026#34;four\u0026#34;, 5, 5.0, false, {a: 1, b: \u0026#34;2\u0026#34;, c: false}, // validation error {a: 1, b: \u0026#34;2\u0026#34;, c: true}, {a: 1, b: 2, c: false}, {a: 1, b: \u0026#34;2\u0026#34;, c: false}, // validation error ] TERMINAL Copy code Copied! $ cue vet -c aList: invalid value [1,2.0,3,\u0026#34;four\u0026#34;,5,5.0,false,{a:1,b:\u0026#34;2\u0026#34;,c:false},{a:1,b:\u0026#34;2\u0026#34;,c:true},{a:1,b:2,c:false},{a:1,b:\u0026#34;2\u0026#34;,c:false}] (does not satisfy list.UniqueItems): equal values at position 7 and 10: ./file.cue:5:8 ./file.cue:6:8 Issue #49 tracks the documentation of precisely what CUE means by values being \u0026ldquo;equivalent\u0026rdquo;, \u0026ldquo;equal\u0026rdquo;, or \u0026ldquo;comparable\u0026rdquo;. When this documentation is complete it will be linked to from this guide. Related content The list built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "0209fdd1e37a30429e6f9eda41856d08_1",
        "title": "Using \"net.IP\" to validate IP addresses",
        "link": "/docs/howto/use-net-ip-to-validate-ip-addresses/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/net#IP\"\u003e\u003ccode\u003enet.IP\u003c/code\u003e\u003c/a\u003e\nto check that values represent valid IPv4 or IPv6 addresses as strings or lists\nof bytes.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function net.IP to check that values represent valid IPv4 or IPv6 addresses as strings or lists of bytes. Copied! file.cue Copy code Copied! package example import \u0026#34;net\u0026#34; // All top-level fields must represent valid IP addresses. [_]: net.IP // These fields represent the same valid IPv4 address. v4String: \u0026#34;198.51.100.14\u0026#34; v4Bytes: [198, 51, 100, 14] // These fields represent the same valid IPv6 address. v6StringFull: \u0026#34;2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026#34; v6StringShort: \u0026#34;2001:0db8:85a3::8a2e:0370:7334\u0026#34; v6Bytes: [32, 1, 13, 184, 133, 163, 0, 0, 1, 0, 138, 46, 3, 112, 115, 52] // Some invalid IP addresses. v4TooManyOctets: \u0026#34;198.51.100.14.0\u0026#34; v4OctetTooLarge: [300, 51, 100, 14] v6ByteTooLarge: [300, 1, 13, 184, 133, 163, 0, 0, 1, 0, 138, 46, 3, 112, 115, 52] TERMINAL Copy code Copied! $ cue vet -c v4OctetTooLarge: invalid value [300,51,100,14] (does not satisfy net.IP): ./file.cue:6:6 ./file.cue:19:18 v4TooManyOctets: invalid value \u0026#34;198.51.100.14.0\u0026#34; (does not satisfy net.IP): ./file.cue:6:6 ./file.cue:18:18 v6ByteTooLarge: invalid value [300,1,13,184,133,163,0,0,1,0,138,46,3,112,115,52] (does not satisfy net.IP): ./file.cue:6:6 ./file.cue:20:17 Related content The net built-in package How-to Guide: Using \u0026#34;net.IPv4\u0026#34; to validate IPv4 addresses How-to Guide: Using \u0026#34;net.IPCIDR\u0026#34; to validate IP CIDR ranges",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "a469c37d8d4a40c90d6eaf1d7771bed1_1",
        "title": "Using \"net.IPCIDR\" to validate IP CIDR ranges",
        "link": "/docs/howto/use-net-ipcidr-to-validate-ip-cidr-ranges/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/net#IPCIDR\"\u003e\u003ccode\u003enet.IPCIDR\u003c/code\u003e\u003c/a\u003e\nto check that values represent valid IPv4 or IPv6 addresses or subnets in\n\u003ca href=\"https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation\"\u003eCIDR notation\u003c/a\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function net.IPCIDR to check that values represent valid IPv4 or IPv6 addresses or subnets in CIDR notation. Copied! file.cue Copy code Copied! package example import \u0026#34;net\u0026#34; // All top-level fields must represent valid CIDR ranges. [_]: net.IPCIDR // Some valid CIDR ranges. v4Block: \u0026#34;198.51.100.0/22\u0026#34; v4Address: \u0026#34;198.51.100.14/24\u0026#34; v6Block: \u0026#34;2001:db8::/48\u0026#34; v6Address: \u0026#34;::1/128\u0026#34; // Some invalid CIDR ranges. v4SubnetMaskTooLarge: \u0026#34;10.0.0.0/50\u0026#34; v6MalformedPrefix: \u0026#34;:::1/128\u0026#34; TERMINAL Copy code Copied! $ cue vet -c v4SubnetMaskTooLarge: invalid value \u0026#34;10.0.0.0/50\u0026#34; (does not satisfy net.IPCIDR): error in call to net.IPCIDR: netip.ParsePrefix(\u0026#34;10.0.0.0/50\u0026#34;): prefix length out of range: ./file.cue:6:6 ./file.cue:15:23 v6MalformedPrefix: invalid value \u0026#34;:::1/128\u0026#34; (does not satisfy net.IPCIDR): error in call to net.IPCIDR: netip.ParsePrefix(\u0026#34;:::1/128\u0026#34;): ParseAddr(\u0026#34;:::1\u0026#34;): each colon-separated field must have at least one digit (at \u0026#34;:1\u0026#34;): ./file.cue:6:6 ./file.cue:16:23 Related content The net built-in package How-to Guide: Using \u0026#34;net.IP\u0026#34; to validate IP addresses How-to Guide: Using \u0026#34;net.IPv4\u0026#34; to validate IPv4 addresses",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "ebf1ae958bfd3ad15dab22af98aae991_1",
        "title": "Using \"net.IPv4\" to validate IPv4 addresses",
        "link": "/docs/howto/use-net-ipv4-to-validate-ipv4-addresses/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/net#IPv4\"\u003e\u003ccode\u003enet.IPv4\u003c/code\u003e\u003c/a\u003e\nto check that values represent valid IPv4 addresses as strings or lists of\nbytes.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function net.IPv4 to check that values represent valid IPv4 addresses as strings or lists of bytes. Copied! file.cue Copy code Copied! package example import \u0026#34;net\u0026#34; // All top-level fields must represent valid IPv4 addresses. [_]: net.IPv4 // These fields represent the same valid IPv4 address. v4String: \u0026#34;198.51.100.14\u0026#34; v4Bytes: [198, 51, 100, 14] // Some invalid IPv4 addresses. tooManyOctets: \u0026#34;198.51.100.14.0\u0026#34; octetTooLarge: [300, 51, 100, 14] v6NotV4: \u0026#34;2001:0db8:85a3::8a2e:0370:7334\u0026#34; TERMINAL Copy code Copied! $ cue vet -c octetTooLarge: invalid value [300,51,100,14] (does not satisfy net.IPv4): ./file.cue:6:6 ./file.cue:14:16 tooManyOctets: invalid value \u0026#34;198.51.100.14.0\u0026#34; (does not satisfy net.IPv4): ./file.cue:6:6 ./file.cue:13:16 v6NotV4: invalid value \u0026#34;2001:0db8:85a3::8a2e:0370:7334\u0026#34; (does not satisfy net.IPv4): ./file.cue:6:6 ./file.cue:15:10 Related content The net built-in package How-to Guide: Using \u0026#34;net.IP\u0026#34; to validate IP addresses How-to Guide: Using \u0026#34;net.IPCIDR\u0026#34; to validate IP CIDR ranges",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "317d134726b41c4d246500d2ec13abe3_1",
        "title": "Using \"net.ParseIP\" and \"net.IPString\" to convert between IP address representations",
        "link": "/docs/howto/use-net-parseip-net-ipstring-to-convert-ip-address-representations/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/net#ParseIP\"\u003e\u003ccode\u003enet.ParseIP\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/net#IPString\"\u003e\u003ccode\u003enet.IPString\u003c/code\u003e\u003c/a\u003e\nto convert IPv4 and IPv6 addresses between their canonical string and\nlist-of-bytes representations.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions net.ParseIP and net.IPString to convert IPv4 and IPv6 addresses between their canonical string and list-of-bytes representations. Copied! file.cue Copy code Copied! package example import \u0026#34;net\u0026#34; v4String: \u0026#34;198.51.100.14\u0026#34; v6String: \u0026#34;2001:db8:85a3::8a2e:370:7334\u0026#34; // Use net.ParseIP to convert IP addresses from strings to lists of bytes. v4Bytes: net.ParseIP(v4String) v6Bytes: net.ParseIP(v6String) // Use net.IPString to convert IP addresses from lists of bytes to strings. // Notice that we\u0026#39;re assigning net.IPString\u0026#39;s output to the same field names we // started with, above. By performing this cross-check we confirm that // net.IPString and net.ParseIP both act as the inverse function of the other. v4String: net.IPString(v4Bytes) v6String: net.IPString(v6Bytes) TERMINAL Copy code Copied! $ cue eval v4String: \u0026#34;198.51.100.14\u0026#34; v6String: \u0026#34;2001:db8:85a3::8a2e:370:7334\u0026#34; v4Bytes: [198, 51, 100, 14] v6Bytes: [32, 1, 13, 184, 133, 163, 0, 0, 0, 0, 138, 46, 3, 112, 115, 52] Related content The net built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "68e8f0ce0a8d110c9d53c548c242914d_1",
        "title": "Using \"path.Base\", \"path.Dir\", and \"path.Ext\" to examine path and filename components",
        "link": "/docs/howto/use-path-base-path-dir-path-ext-to-examine-path-filename-components/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/path#Base\"\u003e\u003ccode\u003epath.Base\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/path#Dir\"\u003e\u003ccode\u003epath.Dir\u003c/code\u003e\u003c/a\u003e, and\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/path#Ext\"\u003e\u003ccode\u003epath.Ext\u003c/code\u003e\u003c/a\u003e\nto access components of a file\u0026rsquo;s name and its path.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions path.Base, path.Dir, and path.Ext to access components of a file\u0026rsquo;s name and its path. Copied! file.cue Copy code Copied! package example import \u0026#34;path\u0026#34; [X=string]: { _OS: *path.Unix | path.Windows | path.Plan9 Dir: path.Dir(X, _OS) Base: path.Base(X, _OS) Ext: path.Ext(X, _OS) } // Examples of absolute paths. \u0026#34;/foo/bar/baz.js\u0026#34;: _ #\u0026#34;C:\\foo\\bar\\baz.js\u0026#34;#: _OS: path.Windows // Examples of directory traversal. \u0026#34;foo/bar/../quux/a.js\u0026#34;: _ #\u0026#34;C:\\foo\\bar\\..\\quux\\a.js\u0026#34;#: _OS: path.Windows // Examples of empty path components. \u0026#34;/foo///bar////baz.js\u0026#34;: _ #\u0026#34;C:\\foo\\\\bar\\\\\\baz.js\u0026#34;#: _OS: path.Windows TERMINAL Copy code Copied! $ cue eval \u0026#34;/foo/bar/baz.js\u0026#34;: { Dir: \u0026#34;/foo/bar\u0026#34; Base: \u0026#34;baz.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } \u0026#34;C:\\\\foo\\\\bar\\\\baz.js\u0026#34;: { Dir: \u0026#34;C:\\\\foo\\\\bar\u0026#34; Base: \u0026#34;baz.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } \u0026#34;foo/bar/../quux/a.js\u0026#34;: { Dir: \u0026#34;foo/quux\u0026#34; Base: \u0026#34;a.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } \u0026#34;C:\\\\foo\\\\bar\\\\..\\\\quux\\\\a.js\u0026#34;: { Dir: \u0026#34;C:\\\\foo\\\\quux\u0026#34; Base: \u0026#34;a.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } \u0026#34;/foo///bar////baz.js\u0026#34;: { Dir: \u0026#34;/foo/bar\u0026#34; Base: \u0026#34;baz.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } \u0026#34;C:\\\\foo\\\\\\\\bar\\\\\\\\\\\\baz.js\u0026#34;: { Dir: \u0026#34;C:\\\\foo\\\\bar\u0026#34; Base: \u0026#34;baz.js\u0026#34; Ext: \u0026#34;.js\u0026#34; } Related content The path built-in package documentation details the rules that each of the functions path.Base, path.Dir, and path.Ext follow as they process their input Using CUE\u0026rsquo;s \u0026ldquo;raw\u0026rdquo; strings is convenient when writing literal Windows paths. They avoid having to escape every backslash (\\\\), as is demonstrated in the Windows-related examples above.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "45eb6cf823ea5032b882c45cd8bdb845_1",
        "title": "Using \"path.Join\" to construct well-formed paths",
        "link": "/docs/howto/use-path-join-to-construct-well-formed-paths/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/path#Join\"\u003e\u003ccode\u003epath.Join\u003c/code\u003e\u003c/a\u003e\nto construct well-formed paths from their individual string components.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function path.Join to construct well-formed paths from their individual string components. Copied! file.cue Copy code Copied! package example import \u0026#34;path\u0026#34; join: path.Join([\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;], path.Unix) unix: path.Join(_components, path.Unix) windows: path.Join(_components, path.Windows) _components: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;, \u0026#34;..\u0026#34;, \u0026#34;quux\u0026#34;, ] TERMINAL Copy code Copied! $ cue export { \u0026#34;join\u0026#34;: \u0026#34;foo/bar/baz\u0026#34;, \u0026#34;unix\u0026#34;: \u0026#34;foo/bar/quux\u0026#34;, \u0026#34;windows\u0026#34;: \u0026#34;foo\\\\bar\\\\quux\u0026#34; } Related content The path built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "447d57c40bd17d022968c8911e8a7877_1",
        "title": "Using \"regexp.ReplaceAll\" and \"regexp.ReplaceAllLiteral\" to modify strings",
        "link": "/docs/howto/use-regexp-replaceall-regexp-replaceallliteral-to-modify-strings/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/regexp#ReplaceAll\"\u003e\u003ccode\u003eregexp.ReplaceAll\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/regexp#ReplaceAllLiteral\"\u003e\u003ccode\u003eregexp.ReplaceAllLiteral\u003c/code\u003e\u003c/a\u003e\nto modify strings using various features of regular expressions.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions regexp.ReplaceAll and regexp.ReplaceAllLiteral to modify strings using various features of regular expressions. Copied! file.cue Copy code Copied! package example import \u0026#34;regexp\u0026#34; // regexp.ReplaceAll and regexp.ReplaceAllLiteral have the same signature: // func ReplaceAllLiteral( pattern, src, repl ) // func ReplaceAll( pattern, src, repl ) // If repl contains only characters that match themselves when used in regular // expressions then the functions behave identically and return the same value: replaceAll: regexp.ReplaceAll(\u0026#34;[aeiou]\u0026#34;, \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34;, \u0026#34;X\u0026#34;) replaceAll: regexp.ReplaceAllLiteral(\u0026#34;[aeiou]\u0026#34;, \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34;, \u0026#34;X\u0026#34;) // Examples in this guide use _src as their source string. _src: \u0026#34;the quick brown fox jumps over the lazy dog\u0026#34; // regexp.ReplaceAll\u0026#39;s repl parameter is a template, which may refer to regular // expression elements such as match indexes and capture groups that were set // up in the pattern parameter. See related content, below, for full // documentation of the template format. // Here we search for the letter \u0026#34;o\u0026#34;, followed by one of \u0026#34;uvwxyz\u0026#34;, and replace // both characters with the second of the pair. oPairReplaceAll: regexp.ReplaceAll(\u0026#34;o([uvwxyz])\u0026#34;, _src, \u0026#34;$1\u0026#34;) // regexp.ReplaceAllLiteral\u0026#39;s repl parameter is used literally. Use it when the // text to be inserted contains regular expression related characters. // Here we insert the literal string \u0026#34;$1\u0026#34;: oPairReplaceAllLiteral: regexp.ReplaceAllLiteral(\u0026#34;o([uvwxyz])\u0026#34;, _src, \u0026#34;$1\u0026#34;) // This example combines several regular expression features. // We search for a vowel, followed by any two letters, at the end of a word. // We remove the vowel by replacing the entire match with the contents of a // named capture group that contains only the two trailing letters. regexReplaceAll: regexp.ReplaceAll(\u0026#34;[aeiou](?P\u0026lt;twoLetters\u0026gt;\\\\w{2}\\\\b)\u0026#34;, _src, \u0026#34;$twoLetters\u0026#34;) TERMINAL Copy code Copied! $ cue eval replaceAll: \u0026#34;thX qXXck brXwn fXx jXmps XvXr thX lXzy dXg\u0026#34; oPairReplaceAll: \u0026#34;the quick brwn fx jumps ver the lazy dog\u0026#34; oPairReplaceAllLiteral: \u0026#34;the quick br$1n f$1 jumps $1er the lazy dog\u0026#34; regexReplaceAll: \u0026#34;the quck brwn fox jumps over the lzy dog\u0026#34; Related content regex.ReplaceAll\u0026rsquo;s replacement templates CUE\u0026rsquo;s regular expression syntax The regexp built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "d1483fff75c87c7100811c251511fa11_1",
        "title": "Using \"strconv.Atoi\" to convert strings to ints",
        "link": "/docs/howto/use-strconv-atoi-to-convert-strings-to-ints/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/strconv#Atoi\"\u003e\u003ccode\u003estrconv.Atoi\u003c/code\u003e\u003c/a\u003e\nto convert a string representation of an int to the number itself, using base\n10.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function strconv.Atoi to convert a string representation of an int to the number itself, using base 10. Copied! file.cue Copy code Copied! package example import \u0026#34;strconv\u0026#34; \u0026#34;0\u0026#34;: strconv.Atoi(\u0026#34;0\u0026#34;) \u0026#34;1\u0026#34;: strconv.Atoi(\u0026#34;1\u0026#34;) \u0026#34;10\u0026#34;: strconv.Atoi(\u0026#34;10\u0026#34;) \u0026#34;42\u0026#34;: strconv.Atoi(\u0026#34;42\u0026#34;) \u0026#34;-42\u0026#34;: strconv.Atoi(\u0026#34;-42\u0026#34;) \u0026#34;050\u0026#34;: strconv.Atoi(\u0026#34;050\u0026#34;) \u0026#34;-050\u0026#34;: strconv.Atoi(\u0026#34;-050\u0026#34;) \u0026#34;00012345\u0026#34;: strconv.Atoi(\u0026#34;00012345\u0026#34;) TERMINAL Copy code Copied! $ cue export { \u0026#34;0\u0026#34;: 0, \u0026#34;1\u0026#34;: 1, \u0026#34;10\u0026#34;: 10, \u0026#34;42\u0026#34;: 42, \u0026#34;-42\u0026#34;: -42, \u0026#34;050\u0026#34;: 50, \u0026#34;-050\u0026#34;: -50, \u0026#34;00012345\u0026#34;: 12345 } Related content strconv.Atoi is a base-10 convenience wrapper around the built-in function strconv.ParseInt, which can perform conversions with custom bases and bit widths The strconv built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","encodings"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "2322b585a3ac759c46fb6fd423a5ef2c_1",
        "title": "Using \"strings.Contains\", \"strings.HasPrefix\", and \"strings.HasSuffix\" as field validators",
        "link": "/docs/howto/use-strings-contains-strings-hasprefix-strings-hassuffix-as-field-validators/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in functions\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/strings#Contains\"\u003e\u003ccode\u003estrings.Contains\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/strings#HasPrefix\"\u003e\u003ccode\u003estrings.HasPrefix\u003c/code\u003e\u003c/a\u003e, and\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/strings#HasSuffix\"\u003e\u003ccode\u003estrings.HasSuffix\u003c/code\u003e\u003c/a\u003e\nto validate fields by asserting that their values match specific strings.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions strings.Contains, strings.HasPrefix, and strings.HasSuffix to validate fields by asserting that their values match specific strings. Copied! file.cue Copy code Copied! package example import \u0026#34;strings\u0026#34; prefix: \u0026#34;Some numbers (123) and letters\u0026#34; contains: \u0026#34;Some numbers (123) and letters\u0026#34; suffix: \u0026#34;Some numbers (123) and letters\u0026#34; prefix: strings.HasPrefix(\u0026#34;Some numbers\u0026#34;) prefix: strings.HasPrefix(\u0026#34;incorrect prefix\u0026#34;) contains: strings.Contains(\u0026#34;numbers\u0026#34;) \u0026amp; strings.Contains(\u0026#34;123\u0026#34;) contains: strings.Contains(\u0026#34;punctuation\u0026#34;) suffix: strings.HasSuffix(\u0026#34;letters\u0026#34;) suffix: strings.HasSuffix(\u0026#34;incorrect suffix\u0026#34;) // None of the built-in functions demonstrated here accept regular expressions. contains: strings.Contains(\u0026#34;.*\u0026#34;) TERMINAL Copy code Copied! $ cue vet -c prefix: invalid value \u0026#34;Some numbers (123) and letters\u0026#34; (does not satisfy strings.HasPrefix(\u0026#34;incorrect prefix\u0026#34;)): ./file.cue:10:9 ./file.cue:5:11 ./file.cue:9:9 ./file.cue:10:27 contains: invalid value \u0026#34;Some numbers (123) and letters\u0026#34; (does not satisfy strings.Contains(\u0026#34;punctuation\u0026#34;)): ./file.cue:13:11 ./file.cue:6:11 ./file.cue:12:11 ./file.cue:13:28 ./file.cue:19:11 suffix: invalid value \u0026#34;Some numbers (123) and letters\u0026#34; (does not satisfy strings.HasSuffix(\u0026#34;incorrect suffix\u0026#34;)): ./file.cue:16:9 ./file.cue:7:11 ./file.cue:15:9 ./file.cue:16:27 contains: invalid value \u0026#34;Some numbers (123) and letters\u0026#34; (does not satisfy strings.Contains(\u0026#34;.*\u0026#34;)): ./file.cue:19:11 ./file.cue:6:11 ./file.cue:12:11 ./file.cue:13:11 ./file.cue:19:28 Related content The strings built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "c05daf5c2548ead97883a1df5484719a_1",
        "title": "Using \"strings.Replace\"",
        "link": "/docs/howto/use-strings-replace/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/strings#Replace\"\u003e\u003ccode\u003estrings.Replace\u003c/code\u003e\u003c/a\u003e\nto make copies of strings with specific substring replacements, \u003cem\u003ewithout\u003c/em\u003e using\nregular expressions.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function strings.Replace to make copies of strings with specific substring replacements, without using regular expressions. Copied! file.cue Copy code Copied! package example import \u0026#34;strings\u0026#34; // func Replace(source, old, new string, count int) string replace: strings.Replace(\u0026#34;This string repeats the word \u0026#39;JSON\u0026#39;: JSON, JSON, JSON.\u0026#34;, \u0026#34;JSON\u0026#34;, \u0026#34;YAML\u0026#34;, 3) // A negative value for the count parameter means unlimited replacements. replaceAll: strings.Replace(\u0026#34;one one one one one one one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, -1) // The old and new parameters are fixed values, not regular expressions. fixed: strings.Replace(\u0026#34;Parameters are fixed strings values.\u0026#34;, \u0026#34;.*\u0026#34;, \u0026#34;REPLACED\u0026#34;, -1) TERMINAL Copy code Copied! $ cue export { \u0026#34;replace\u0026#34;: \u0026#34;This string repeats the word \u0026#39;YAML\u0026#39;: YAML, YAML, JSON.\u0026#34;, \u0026#34;replaceAll\u0026#34;: \u0026#34;two two two two two two two\u0026#34;, \u0026#34;fixed\u0026#34;: \u0026#34;Parameters are fixed strings values.\u0026#34; } Related content The strings built-in package",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "07c036403ea931a525dac1e7d89302d7_1",
        "title": "Using \"text/template.Execute\" to generate text from data",
        "link": "/docs/howto/use-text-template-execute-to-generate-text-from-data/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the built-in function\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/pkg/text/template#Execute\"\u003e\u003ccode\u003etext/template.Execute\u003c/code\u003e\u003c/a\u003e\nwith data-driven templates to generate text output, using Go\u0026rsquo;s\n\u003ca href=\"https://pkg.go.dev/text/template\"\u003etemplate format\u003c/a\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function text/template.Execute with data-driven templates to generate text output, using Go\u0026rsquo;s template format. Copied! file.cue Copy code Copied! package example import \u0026#34;text/template\u0026#34; tasklist: template.Execute(message, data) message: \u0026#34;\u0026#34;\u0026#34; Hello, {{ .name }}. Here are the tasks you still need to do: -- TODO -------------------------------- {{ range $T := .incomplete -}}  {{ printf \u0026#34;%s [estimated effort: %v]\u0026#34; $T.name $T.effort }} {{ end }} You\u0026#39;ve already completed these tasks - well done! -- DONE ----------------------------------------- {{ range $T := .complete -}}  {{ $T.name }} {{ end -}} \u0026#34;\u0026#34;\u0026#34; data: { name: \u0026#34;Alex\u0026#34; tasks: [{ name: \u0026#34;Write CUE how-to guide\u0026#34; effort: 1 complete: true }, { name: \u0026#34;Train for 10k race\u0026#34; effort: 4 complete: false }, { name: \u0026#34;Violin practise\u0026#34; effort: 3 complete: false }, { name: \u0026#34;Go shopping\u0026#34; effort: 3 complete: true }, { name: \u0026#34;Feed cat\u0026#34; effort: 1 complete: false }, ] complete: [for t in tasks if t.complete {t}] incomplete: [for t in tasks if !t.complete {t}] } TERMINAL Copy code Copied! $ cue export -e tasklist --out text Hello, Alex. Here are the tasks you still need to do: -- TODO --------------------------------  Train for 10k race [estimated effort: 4]  Violin practise [estimated effort: 3]  Feed cat [estimated effort: 1] You\u0026#39;ve already completed these tasks - well done! -- DONE -----------------------------------------  Write CUE how-to guide  Go shopping Related content Go\u0026rsquo;s documentation of the template format used by text/template.Execute The text/template built-in package The example on this page is adapted from the excellent Cuetorials' page on text/template",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "68bbdd9379de38c10e7adb9b49fc628f_1",
        "title": "Using modules with the Go API",
        "link": "/docs/tutorial/using-modules-with-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will\nuse CUE\u0026rsquo;s Go API to work with a CUE module dependency fetched from the Central Registry.\u003c/p\u003e\n\u003cp\u003eAlong the way you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLogin to the Central Registry, and authenticate the \u003ccode\u003ecue\u003c/code\u003e command\u003c/li\u003e\n\u003cli\u003eCreate a CUE module that depends on an existing, well-known module\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ecue mod tidy\u003c/code\u003e to fetch and organise your module\u0026rsquo;s dependencies\u003c/li\u003e\n\u003cli\u003eLoad your CUE using the Go API working in a modules-aware mode\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "Introduction In this tutorial you will use CUE\u0026rsquo;s Go API to work with a CUE module dependency fetched from the Central Registry. Along the way you will: Login to the Central Registry, and authenticate the cue command Create a CUE module that depends on an existing, well-known module Use cue mod tidy to fetch and organise your module\u0026rsquo;s dependencies Load your CUE using the Go API working in a modules-aware mode Prerequisites Access to the Central Registry \u0026ndash; if you need to practise using the Central Registry, then first follow the tutorial Working with modules and the Central Registry A tool to edit text files \u0026ndash; any text editor you have will be fine; for example: VSCode or Vim A command terminal \u0026ndash; the cue command works on all platforms; use any terminal on Linux or macOS, or PowerShell, cmd.exe or WSL on Windows. An installed go binary \u0026ndash; installation details An installed cue binary \u0026ndash; installation details This tutorial uses the following version of CUE: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Set up the cue command 1Authenticate the cue command with the Central Registry: TERMINAL Copy code Copied! $ cue login Later in this tutorial the cue command will fetch a well-known module from the Central Registry, which requires authentication. Create a CUE module 2Initialize a new main CUE module in an empty directory: TERMINAL Copy code Copied! $ cue mod init an.example/config@v0 You won\u0026rsquo;t publish this module, so the name you give it is unimportant. 3Create the file main.cue, holding the code for the main module: Copied! main.cue Copy code Copied! package config import \u0026#34;github.com/cue-labs/examples/frostyconfig@v0\u0026#34; config: frostyconfig.#Config \u0026amp; { appName: \u0026#34;alpha\u0026#34; port: 80 features: logging: true } Your main module defines some concrete values for a configuration, constrained by the frostyconfig.#Config schema. Your module imports and uses the frostyconfig package first introduced in the tutorial Working with a custom module registry. You don\u0026rsquo;t need to follow that tutorial right now - it\u0026rsquo;s only mentioned for context. 4Ensure the CUE module is tidy: TERMINAL Copy code Copied! $ cue mod tidy This fetches the frostyconfig module (and any dependencies it might have) from the Central Registry. 5Export the configuration from your CUE module: TERMINAL Copy code Copied! $ cue export { \u0026#34;config\u0026#34;: { \u0026#34;appName\u0026#34;: \u0026#34;alpha\u0026#34;, \u0026#34;port\u0026#34;: 80, \u0026#34;features\u0026#34;: { \u0026#34;logging\u0026#34;: true } } } This export shows that your CUE is valid and you can successfully use a dependency from the Central Registry. Create a Go module and program 6Initialize a Go module for your program: TERMINAL Copy code Copied! $ go mod init an.example/config ... You won\u0026rsquo;t publish this module, so the name you give it is unimportant. 7Create the file main.go containing this Go program: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; \u0026#34;cuelang.org/go/mod/modconfig\u0026#34; ) func main() { ctx := cuecontext.New() // Create a registry client. Passing a nil config // will give us client that behaves like the cue command. reg, err := modconfig.NewRegistry(nil) if err != nil { log.Fatal(err) } // Load the package from the current directory. // We don\u0026#39;t need to specify a Config in this example. insts := load.Instances([]string{\u0026#34;.\u0026#34;}, \u0026amp;load.Config{ Registry: reg, }) // The current directory just has one file without any build tags, // and that file belongs to the example package, so we get a single // instance as a result. v := ctx.BuildInstance(insts[0]) if err := v.Err(); err != nil { log.Fatal(err) } // Lookup the \u0026#39;config\u0026#39; field and print it out config := v.LookupPath(cue.ParsePath(\u0026#34;config\u0026#34;)) fmt.Println(config) } This program loads the CUE package in the current directory, and then prints a message based on the config field. 8Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... You can use @latest in place of the specific version mentioned here. Run the Go program 9Run the Go program: TERMINAL Copy code Copied! $ go run . { appName: \u0026#34;alpha\u0026#34; port: 80 features: { logging: true } } Summary Well done - you\u0026rsquo;ve finished this tutorial! In completing it, you: created a main module that depends on a well-known module from the Central Registry, and used the Go API to load the main module, transparently using the module\u0026rsquo;s dependencies. Related content Reference: CUE Modules Tutorial: Working with a custom module registry",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["go api","modules","tooling"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "7be83e11d4bae5ebb352a72e91ed0347_1",
        "title": "Using the built-in function \"and\" to unify the elements of a list",
        "link": "/docs/howto/use-the-built-in-function-and/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction\n\u003ca href=\"/docs/reference/glossary/#and-built-in-function\"\u003e\u003ccode\u003eand()\u003c/code\u003e\u003c/a\u003e\nto unify all the elements of a list.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function and() to unify all the elements of a list. Copied! example.cue Copy code Copied! package example // c is a list of constraints c: [int, \u0026gt;99, \u0026lt;1000] // Each field in data must adhere to all of the // constraints contained in c data: [string]: and(c) data: { a: 4.2 b: 42 c: 500 // a valid value d: 1001 } TERMINAL Copy code Copied! $ cue vet -c .:example data.a: conflicting values 4.2 and int \u0026amp; \u0026gt;99 \u0026amp; \u0026lt;1000 (mismatched types float and int): ./example.cue:10:5 data.b: invalid value 42 (out of bound \u0026gt;99): ./example.cue:4:10 ./example.cue:11:5 data.d: invalid value 1001 (out of bound \u0026lt;1000): ./example.cue:4:15 ./example.cue:13:5",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "1b5ef0044809b0452a41d98bcd3314d6_1",
        "title": "Using the built-in function \"close\" to close a struct",
        "link": "/docs/howto/use-the-built-in-function-close/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction\n\u003ca href=\"/docs/reference/glossary/#close-built-in-function\"\u003e\u003ccode\u003eclose()\u003c/code\u003e\u003c/a\u003e\nto close a\n\u003ca href=\"/docs/reference/glossary/#struct\"\u003estruct\u003c/a\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function close() to close a struct. Copied! example.cue Copy code Copied! package example // _x is an open struct _x: { a?: int b!: bool c?: string } // \u0026#34;ok\u0026#34; is an open struct ok: _x \u0026amp; { a: 42 b: true c: \u0026#34;a string\u0026#34; d: \u0026#34;an additional field\u0026#34; } // \u0026#34;notOk\u0026#34; is the result of unifying a closed // struct with at least one field not mentioned // by the struct (\u0026#34;d\u0026#34;) notOk: close(_x) \u0026amp; { a: 42 b: true c: \u0026#34;a string\u0026#34; d: \u0026#34;an additional field\u0026#34; } TERMINAL Copy code Copied! $ cue eval -i ok: { a: 42 b: true c: \u0026#34;a string\u0026#34; d: \u0026#34;an additional field\u0026#34; } notOk: { a: 42 b: true c: \u0026#34;a string\u0026#34; d: _|_ // notOk.d: field not allowed }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "e8e37ad52d531907503363d5cf2842db_1",
        "title": "Using the built-in function \"len\" to calculate lengths",
        "link": "/docs/howto/use-the-built-in-function-len/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction\n\u003ca href=\"/docs/reference/glossary/#len-built-in-function\"\u003e\u003ccode\u003elen()\u003c/code\u003e\u003c/a\u003e\nto calculate the lengths of different CUE types.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function len() to calculate the lengths of different CUE types. Copied! example.cue Copy code Copied! package example a: len([5, 4, 3, 2]) // Using len() on a string returns the number of // bytes it contains, not the number of // characters // This input is of type bytes b: len(\u0026#39;abc123\u0026#39;) // This input is of type string b: len(\u0026#34;abc123\u0026#34;) TERMINAL Copy code Copied! $ cue export { \u0026#34;a\u0026#34;: 4, \u0026#34;b\u0026#34;: 14 } Related content Don\u0026rsquo;t use the len function on a string, for the reason mentioned above. Constraining the length of a string demonstrates using functions from the built-in strings package instead",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "4aae5b5a374e2ce797b5cf950e141bf5_1",
        "title": "Using the built-in function \"matchIf\" as a field validator",
        "link": "/docs/howto/use-the-built-in-function-matchif/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction \u003ccode\u003ematchIf\u003c/code\u003e.\nIt may only be used as a field validator and\ncan\u0026rsquo;t be called as a function that returns a boolean value.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ematchIf\u003c/code\u003e requires three arguments:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ethe \u003cem\u003eif-value\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003ethe \u003cem\u003ethen-value\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003ethe \u003cem\u003eelse-value\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe function first checks if a field\u0026rsquo;s value can unify successfully with the \u003cem\u003eif-value\u003c/em\u003e,\nand then validates the field\u0026rsquo;s value by performing one of two tests.\nIf the test fails, then the field\u0026rsquo;s value is invalid:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the field\u0026rsquo;s value \u003cstrong\u003ecould\u003c/strong\u003e unify successfully with the \u003cem\u003eif-value\u003c/em\u003e, can\nthe field\u0026rsquo;s value also unify successfully with the \u003cem\u003ethen-value\u003c/em\u003e?\u003c/li\u003e\n\u003cli\u003eIf the field\u0026rsquo;s value \u003cstrong\u003ecould not\u003c/strong\u003e unify successfully with the \u003cem\u003eif-value\u003c/em\u003e,\ncan the field\u0026rsquo;s value also unify successfully with the \u003cem\u003eelse-value\u003c/em\u003e?\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "This guide demonstrates how to use the built-in function matchIf. It may only be used as a field validator and can\u0026rsquo;t be called as a function that returns a boolean value. matchIf requires three arguments: the if-value the then-value the else-value The function first checks if a field\u0026rsquo;s value can unify successfully with the if-value, and then validates the field\u0026rsquo;s value by performing one of two tests. If the test fails, then the field\u0026rsquo;s value is invalid: If the field\u0026rsquo;s value could unify successfully with the if-value, can the field\u0026rsquo;s value also unify successfully with the then-value? If the field\u0026rsquo;s value could not unify successfully with the if-value, can the field\u0026rsquo;s value also unify successfully with the else-value? Copied! example.cue Copy code Copied! package matchIf // A and B have the same value. A: 42 B: 42 // A validates successfully. A: matchIf(\u0026gt;40, \u0026lt;100, \u0026gt;100) // B fails to validate. B: matchIf(\u0026lt;40, \u0026lt;100, \u0026gt;100) // C and D have the same composite value. C: {x: \u0026#34;some string\u0026#34;, o: 99} D: {x: \u0026#34;some string\u0026#34;, o: 99} // C validates successfully. C: matchIf({x?: string}, {o?: \u0026lt;100}, {o?: \u0026gt;100}) // D fails to validate. D: matchIf({x?: int}, _oUnder100, _oOver100) _oUnder100: {o?: \u0026lt;100} _oOver100: {o?: \u0026gt;100} TERMINAL Copy code Copied! $ cue vet -c B: invalid value 42 (does not satisfy matchIf): invalid value 42 (out of bound \u0026gt;100): ./example.cue:9:4 ./example.cue:5:4 ./example.cue:9:12 ./example.cue:9:17 ./example.cue:9:23 D: invalid value {x:\u0026#34;some string\u0026#34;,o:99} (does not satisfy matchIf): invalid value 99 (out of bound \u0026gt;100): ./example.cue:17:4 ./example.cue:13:4 ./example.cue:13:26 ./example.cue:20:17 Future enhancements The current release of matchIf does not consider hidden fields or definitions when checking for a match with any of its parameters (the if-value, the then-value, or the else-value): Copied! helper-fields.cue Copy code Copied! package helperFields #A: { _aString: string #anInt: int } A: matchIf(#A, #A, #A) \u0026amp; { _aString: 42 #anInt: \u0026#34;not an int\u0026#34; } TERMINAL Copy code Copied! $ cue vet -c .:helperFields # this command succeeds This behaviour may change with future CUE releases. If support for hidden fields or definitions is important to how you would like to use matchIf, please join the CUE community and tell us about your use case.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "e60ff731b15ed4c77d563c158baa144d_1",
        "title": "Using the built-in function \"matchN\" as a field validator",
        "link": "/docs/howto/use-the-built-in-function-matchn/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction \u003ccode\u003ematchN\u003c/code\u003e.\nIt may only be used as a field validator and\ncan\u0026rsquo;t be called as a function that returns a boolean value.\u003c/p\u003e\n\u003cp\u003eThe current implementation of \u003ccode\u003ematchN\u003c/code\u003e is inspired by JSON Schema\u0026rsquo;s\n\u003ccode\u003eoneOf\u003c/code\u003e,\n\u003ccode\u003eanyOf\u003c/code\u003e,\n\u003ccode\u003eallOf\u003c/code\u003e, and\n\u003ccode\u003enot\u003c/code\u003e\nconcepts.\nThis guide shows how those concepts can be encoded in CUE.\u003c/p\u003e",
        "content": "This guide demonstrates how to use the built-in function matchN. It may only be used as a field validator and can\u0026rsquo;t be called as a function that returns a boolean value. The current implementation of matchN is inspired by JSON Schema\u0026rsquo;s oneOf, anyOf, allOf, and not concepts. This guide shows how those concepts can be encoded in CUE. Basic use The matchN function takes two arguments: a number constraint; a list of constraints. The function validates a field\u0026rsquo;s value by unifying the value with each item in the list of constraints in turn, and keeping count of how many list items the field\u0026rsquo;s value is able to unify with. A field\u0026rsquo;s value is valid if the count unifies successfully with the number constraint: Copied! basic.cue Copy code Copied! package basic A: 42 // A validates successfully. A: matchN(1, [int]) A: matchN(2, [int, \u0026gt;10]) A: matchN(2, [int, \u0026gt;10, \u0026gt;100]) B: 42 // B fails to validate. B: matchN(1, [int, \u0026gt;10]) B: matchN(3, [int, \u0026gt;10, \u0026gt;100]) TERMINAL Copy code Copied! $ cue vet -c .:basic B: invalid value 42 (does not satisfy matchN): 2 matched, expected 1: ./basic.cue:11:4 ./basic.cue:9:4 ./basic.cue:11:11 ./basic.cue:12:4 B: invalid value 42 (does not satisfy matchN): 2 matched, expected 3: ./basic.cue:12:4 ./basic.cue:9:4 ./basic.cue:11:4 ./basic.cue:12:11 B: invalid value 42 (out of bound \u0026gt;100): ./basic.cue:12:25 ./basic.cue:9:4 \u0026ldquo;One of\u0026rdquo; With its number constraint set to 1 the matchN function checks that a field\u0026rsquo;s value unifies successfully with just one of the list of constraints: Copied! one-of.cue Copy code Copied! package oneOf import \u0026#34;math\u0026#34; A: 42 // A validates successfully. A: matchN(1, [int]) A: matchN(1, [\u0026gt;10, \u0026gt;100, string]) A: matchN(1, [math.MultipleOf(3), math.MultipleOf(5)]) B: 42 // B fails to validate. B: matchN(1, [int, \u0026gt;10]) B: matchN(1, [string, \u0026gt;100]) C: 15 // C fails to validate. C: matchN(1, [math.MultipleOf(3), math.MultipleOf(5)]) TERMINAL Copy code Copied! $ cue vet -c .:oneOf B: conflicting values 42 and string (mismatched types int and string): ./one-of.cue:11:4 ./one-of.cue:14:15 B: invalid value 42 (does not satisfy matchN): 2 matched, expected 1: ./one-of.cue:13:4 ./one-of.cue:11:4 ./one-of.cue:13:11 ./one-of.cue:14:4 B: invalid value 42 (does not satisfy matchN): 0 matched, expected 1: ./one-of.cue:14:4 ./one-of.cue:11:4 ./one-of.cue:13:4 ./one-of.cue:14:11 B: invalid value 42 (out of bound \u0026gt;100): ./one-of.cue:14:23 ./one-of.cue:11:4 C: invalid value 15 (does not satisfy matchN): 2 matched, expected 1: ./one-of.cue:18:4 ./one-of.cue:16:4 ./one-of.cue:18:11 \u0026ldquo;Any of\u0026rdquo; If the number constraint is set to \u0026gt;0, the function checks that at least one of the list of constraints unifies with the field\u0026rsquo;s value: Copied! any-of.cue Copy code Copied! package anyOf A: 42 // A validates successfully. A: matchN(\u0026gt;0, [\u0026gt;10]) A: matchN(\u0026gt;0, [int, \u0026gt;0, \u0026gt;100, string]) B: 42 // B fails to validate. B: matchN(\u0026gt;0, [string, \u0026gt;100]) TERMINAL Copy code Copied! $ cue vet -c .:anyOf B: conflicting values 42 and string (mismatched types int and string): ./any-of.cue:8:4 ./any-of.cue:10:16 B: invalid value 42 (does not satisfy matchN): 0 matched, expected \u0026gt;0: ./any-of.cue:10:4 ./any-of.cue:8:4 ./any-of.cue:10:11 B: invalid value 42 (out of bound \u0026gt;100): ./any-of.cue:10:24 ./any-of.cue:8:4 \u0026ldquo;All of\u0026rdquo; To check that a field\u0026rsquo;s value unifies successfully with all of the list of constraints, set the number constraint to a value matching the number of items in the list: Copied! all-of.cue Copy code Copied! package allOf import \u0026#34;math\u0026#34; A: 42 // A validates successfully. A: matchN(1, [int]) A: matchN(2, [int, \u0026gt;10]) A: matchN(4, [int, \u0026gt;10, \u0026lt;100, math.MultipleOf(2)]) B: 42 // B fails to validate. B: matchN(3, [int, \u0026gt;10, \u0026gt;100]) B: matchN(4, [int, \u0026gt;10, \u0026lt;100, math.MultipleOf(41)]) TERMINAL Copy code Copied! $ cue vet -c .:allOf B: invalid value 42 (does not satisfy matchN): 2 matched, expected 3: ./all-of.cue:13:4 ./all-of.cue:11:4 ./all-of.cue:13:11 ./all-of.cue:14:4 B: invalid value 42 (does not satisfy matchN): 3 matched, expected 4: ./all-of.cue:14:4 ./all-of.cue:11:4 ./all-of.cue:13:4 ./all-of.cue:14:11 B: invalid value 42 (does not satisfy math.MultipleOf(41)): ./all-of.cue:14:31 ./all-of.cue:11:4 ./all-of.cue:13:4 ./all-of.cue:14:4 ./all-of.cue:14:47 \u0026ldquo;Not\u0026rdquo; If you set the number constraint to 0 then matchN checks that a field\u0026rsquo;s value doesn\u0026rsquo;t unify successfully with any of the list of constraints: Copied! not.cue Copy code Copied! package not import ( \u0026#34;strings\u0026#34; \u0026#34;struct\u0026#34; ) A: 42 // A validates successfully. A: matchN(0, [string]) A: matchN(0, [bytes, struct.MinFields(0)]) A: matchN(0, [\u0026gt;100, strings.HasPrefix(\u0026#34;4\u0026#34;)]) B: 42 // B fails to validate. B: matchN(0, [int]) B: matchN(0, [string, number]) B: matchN(0, [42, \u0026gt;100, strings.HasSuffix(\u0026#34;4\u0026#34;)]) TERMINAL Copy code Copied! $ cue vet -c .:not B: invalid value 42 (does not satisfy matchN): 1 matched, expected 0: ./not.cue:16:4 ./not.cue:14:4 ./not.cue:16:11 ./not.cue:17:4 ./not.cue:18:4 B: invalid value 42 (does not satisfy matchN): 1 matched, expected 0: ./not.cue:17:4 ./not.cue:14:4 ./not.cue:16:4 ./not.cue:17:11 ./not.cue:18:4 More complex uses References Either argument to matchN can be resolved through a reference: Copied! all-but-one.cue Copy code Copied! package allButOne // A validates successfully. A: 42 A: matchN(len(#C)-1, #C) // B fails to validate. B: 42.0 B: matchN(len(#C)-1, #C) #C: [number, int, \u0026gt;100] TERMINAL Copy code Copied! $ cue vet -c .:allButOne B: conflicting values 42.0 and int (mismatched types float and int): ./all-but-one.cue:8:4 ./all-but-one.cue:11:14 B: invalid value 42.0 (does not satisfy matchN): 1 matched, expected 2: ./all-but-one.cue:9:4 ./all-but-one.cue:8:4 ./all-but-one.cue:9:11 B: invalid value 42.0 (out of bound \u0026gt;100): ./all-but-one.cue:11:19 ./all-but-one.cue:8:4 Composite data structures The matchN function can validate composite data structures, not just primitive values. Use it with both structs and lists: Copied! composite.cue Copy code Copied! package composite // A validates successfully. A: matchN(\u0026gt;0, [#C1, #C2]) \u0026amp; { x: 42 y: 4.2 } // B fails to validate. B: matchN(\u0026gt;0, [#C1, #C2]) \u0026amp; { x: 4.2 // Not an int. y: 4.2 // Not a string. z: 4.2 } #C1: {x!: int, ...} #C2: { y!: string z?: float ... } // D validates successfully. D: [1, 2, 3] \u0026amp; matchN(1, [#F1, #F2, #F3]) // E fails to validate. E: [11, 12, 13] \u0026amp; matchN(1, [#F1, #F2, #F3]) #F1: [...\u0026gt;0] #F2: [...\u0026gt;10] #F3: [...\u0026gt;100] TERMINAL Copy code Copied! $ cue vet -c .:composite B.x: conflicting values 4.2 and int (mismatched types float and int): ./composite.cue:10:5 ./composite.cue:14:11 B.y: conflicting values 4.2 and string (mismatched types float and string): ./composite.cue:11:5 ./composite.cue:16:6 B: invalid value {x:4.2,y:4.2,z:4.2} (does not satisfy matchN): 0 matched, expected \u0026gt;0: ./composite.cue:9:4 ./composite.cue:9:11 E: invalid value [11,12,13] (does not satisfy matchN): 2 matched, expected 1: ./composite.cue:24:19 ./composite.cue:24:4 ./composite.cue:24:26",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "e60ff731b15ed4c77d563c158baa144d_2",
        "title": "Using the built-in function \"matchN\" as a field validator",
        "link": "/docs/howto/use-the-built-in-function-matchn/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction \u003ccode\u003ematchN\u003c/code\u003e.\nIt may only be used as a field validator and\ncan\u0026rsquo;t be called as a function that returns a boolean value.\u003c/p\u003e\n\u003cp\u003eThe current implementation of \u003ccode\u003ematchN\u003c/code\u003e is inspired by JSON Schema\u0026rsquo;s\n\u003ccode\u003eoneOf\u003c/code\u003e,\n\u003ccode\u003eanyOf\u003c/code\u003e,\n\u003ccode\u003eallOf\u003c/code\u003e, and\n\u003ccode\u003enot\u003c/code\u003e\nconcepts.\nThis guide shows how those concepts can be encoded in CUE.\u003c/p\u003e",
        "content": "E.0: invalid value 11 (out of bound \u0026gt;100): ./composite.cue:27:10 ./composite.cue:24:5 The sub-optimal error reporting for field E is tracked in issue #3389. Future enhancements The current release of matchN does not consider hidden fields or definitions when checking for a match: Copied! helper-fields.cue Copy code Copied! package helperFields #A: { _aString: string #anInt: int } A: matchN(1, [#A]) \u0026amp; { _aString: 42 #anInt: \u0026#34;not an int\u0026#34; } TERMINAL Copy code Copied! $ cue vet -c .:helperFields # this command succeeds This behaviour may change with future CUE releases. If support for hidden fields or definitions is important to how you would like to use matchN, please join the CUE community and tell us about your use case.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": "",
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "65d69033b89aba0d9480aa8bc5f27223_1",
        "title": "Using the built-in function \"or\" to create a disjunction",
        "link": "/docs/howto/use-the-built-in-function-or/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunction\n\u003ca href=\"/docs/reference/glossary/#or-built-in-function\"\u003e\u003ccode\u003eor()\u003c/code\u003e\u003c/a\u003e\nto create a\n\u003ca href=\"/docs/reference/glossary/#disjunction\"\u003edisjunction\u003c/a\u003e\nfrom a list.\u003c/p\u003e\n\u003cp\u003eThis allows the list to be used as a constraint that only permits values that\nare present in the list.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in function or() to create a disjunction from a list. This allows the list to be used as a constraint that only permits values that are present in the list. Copied! example.cue Copy code Copied! package example source: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] result: or(source) // Each field in \u0026#34;test\u0026#34; must have a value that // unifies successfully with a value in \u0026#34;source\u0026#34;. test: [string]: result test: { one: \u0026#34;a\u0026#34; two: \u0026#34;b\u0026#34; three: \u0026#34;c\u0026#34; four: \u0026#34;XYZ\u0026#34; // invalid value } TERMINAL Copy code Copied! $ cue eval -i .:example source: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] result: \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; test: { one: \u0026#34;a\u0026#34; two: \u0026#34;b\u0026#34; three: \u0026#34;c\u0026#34; four: _|_ // test.four: 3 errors in empty disjunction: (and 3 more errors) }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "89c1d6cff872e0c388c50a0327348e6e_1",
        "title": "Using the built-in functions \"div\", \"mod\", \"quo\", and \"rem\"",
        "link": "/docs/howto/use-the-built-in-functions-div-mod-quo-rem/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to use the\n\u003ca href=\"/docs/reference/glossary/#built-in-functions\"\u003ebuilt-in\u003c/a\u003e\nfunctions\n\u003ca href=\"/docs/reference/glossary/#div-built-in-function\"\u003e\u003ccode\u003ediv()\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"/docs/reference/glossary/#mod-built-in-function\"\u003e\u003ccode\u003emod()\u003c/code\u003e\u003c/a\u003e\nto perform\n\u003ca href=\"https://en.wikipedia.org/wiki/Euclidean_division\"\u003eEuclidean division\u003c/a\u003e,\nand how to use\n\u003ca href=\"/docs/reference/glossary/#quo-built-in-function\"\u003e\u003ccode\u003equo()\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"/docs/reference/glossary/#rem-built-in-function\"\u003e\u003ccode\u003erem()\u003c/code\u003e\u003c/a\u003e\nto perform truncated division.\u003c/p\u003e\n\u003cp\u003eThe behaviours of these functions are defined in\n\u003ca href=\"/docs/reference/spec/#div-mod-quo-and-rem\"\u003ethe CUE language specification\u003c/a\u003e.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to use the built-in functions div() and mod() to perform Euclidean division, and how to use quo() and rem() to perform truncated division. The behaviours of these functions are defined in the CUE language specification. Copied! example.cue Copy code Copied! package example // div returns Euclidean division\u0026#39;s // integer quotient euclidean: quotient: { a: div(15, 4) b: div(15, -4) c: div(-15, 4) d: div(-15, -4) } // mod returns Euclidean division\u0026#39;s // integer remainder euclidean: remainder: { a: mod(15, 4) b: mod(15, -4) c: mod(-15, 4) d: mod(-15, -4) } // quo returns truncated division\u0026#39;s // integer quotient truncated: quotient: { a: quo(15, 4) b: quo(15, -4) c: quo(-15, 4) d: quo(-15, -4) } // rem returns truncated division\u0026#39;s // integer remainder truncated: remainder: { a: rem(15, 4) b: rem(15, -4) c: rem(-15, 4) d: rem(-15, -4) } TERMINAL Copy code Copied! $ cue export { \u0026#34;euclidean\u0026#34;: { \u0026#34;quotient\u0026#34;: { \u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: -3, \u0026#34;c\u0026#34;: -4, \u0026#34;d\u0026#34;: 4 }, \u0026#34;remainder\u0026#34;: { \u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: 3, \u0026#34;c\u0026#34;: 1, \u0026#34;d\u0026#34;: 1 } }, \u0026#34;truncated\u0026#34;: { \u0026#34;quotient\u0026#34;: { \u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: -3, \u0026#34;c\u0026#34;: -3, \u0026#34;d\u0026#34;: 3 }, \u0026#34;remainder\u0026#34;: { \u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: 3, \u0026#34;c\u0026#34;: -3, \u0026#34;d\u0026#34;: -3 } } }",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["language","commented cue"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "dc73a6926e7e96ed23a2f3c55ba23816_1",
        "title": "Using the cue export command",
        "link": "/docs/concept/using-the-cue-export-command/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe \u003ccode\u003ecue export\u003c/code\u003e command takes a configuration and turns some of it (or all of\nit) into validated, concrete data encoded in a format such as JSON or YAML.\nThe \u003ccode\u003ecue export\u003c/code\u003e\n\u003ca href=\"/docs/reference/command/cue-export/\"\u003ereference page\u003c/a\u003e explains\nit more formally, like this:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;The \u003ccode\u003ecue export\u003c/code\u003e command\nevaluates an expression in the context of a particular configuration\nand then\nemits the value of the expression encoded as concrete data.\nThe command fails with an error message\nif evaluation is unsuccessful, or\nif the value of the evaluated expression is not concrete.\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTo validate a configuration \u003cem\u003ewithout\u003c/em\u003e also emitting some or all of its value,\nuse the \u003ca href=\"/docs/reference/command/cue-help-vet/\"\u003e\u003ccode\u003ecue vet\u003c/code\u003e\u003c/a\u003e\ncommand instead.\u003c/p\u003e\n\u003ch2 id=\"whats-in-this-guide\"\u003e\n    \u003ca href=\"#whats-in-this-guide\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eWhat\u0026rsquo;s in this guide?\u003c/h2\u003e\n\u003cp\u003eThis guide shows you how to manage the inputs and output of \u003ccode\u003ecue export\u003c/code\u003e,\nand how to vary some aspects of the evaluation that it performs.\nHere\u0026rsquo;s what you\u0026rsquo;ll find:\u003c/p\u003e",
        "content": "The cue export command takes a configuration and turns some of it (or all of it) into validated, concrete data encoded in a format such as JSON or YAML. The cue export reference page explains it more formally, like this: \u0026ldquo;The cue export command evaluates an expression in the context of a particular configuration and then emits the value of the expression encoded as concrete data. The command fails with an error message if evaluation is unsuccessful, or if the value of the evaluated expression is not concrete.\u0026rdquo; To validate a configuration without also emitting some or all of its value, use the cue vet command instead. What\u0026rsquo;s in this guide? This guide shows you how to manage the inputs and output of cue export, and how to vary some aspects of the evaluation that it performs. Here\u0026rsquo;s what you\u0026rsquo;ll find: Inputs Start here and learn how the inputs you provide are interpreted and combined. Evaluation Find out about the aspects of the command\u0026rsquo;s operation that you can control. Output See how the command output\u0026rsquo;s encoding can be selected, and directed into a specific location.",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["cue command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "3b3455f1fe0df46f4842e0f0292a5b40_1",
        "title": "Using your first CUE workflow command",
        "link": "/docs/howto/use-your-first-cue-workflow-command/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to define a very simple CUE \u003cem\u003eworkflow command\u003c/em\u003e,\nand how to run it.\nThis specific workflow command allows a \u003ccode\u003e-t\u003c/code\u003e flag to\n\u003ca href=\"/docs/reference/command/cue-help-injection/\"\u003einject\u003c/a\u003e\na value into the process so that it can be referred to.\u003c/p\u003e",
        "content": "This guide demonstrates how to define a very simple CUE workflow command, and how to run it. This specific workflow command allows a -t flag to inject a value into the process so that it can be referred to. Copied! some_tool.cue Copy code Copied! package example import \u0026#34;tool/exec\u0026#34; name: *\u0026#34;everyone\u0026#34; | string @tag(who) city: \u0026#34;Kinshasa\u0026#34; // The \u0026#34;hello\u0026#34; command welcomes people to a place. command: hello: { // The command contains a single task. print: exec.Run \u0026amp; { cmd: \u0026#34;echo Hey \\(name), welcome to \\(city)!\u0026#34; } } TERMINAL Copy code Copied! $ cue cmd -t who=Alex hello Hey Alex, welcome to Kinshasa! CUE workflows commands can only be invoked if they are stored in a file with a name ending _tool.cue. Related content Reference: cue help commands \u0026ndash; more information about CUE workflow commands Reference: cue help injection \u0026ndash; injecting values into cue command invocations",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["workflow command"],
        "authors": ["jpluscplusm"]
    },
    
            {
        "objectID": "b275df23becb3fdc256ec6dc1c2c57d4_1",
        "title": "Validating an integer value's parity",
        "link": "/docs/howto/validate-integer-value-parity/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to validate an integer value\u0026rsquo;s parity.\u003c/p\u003e\n\u003cp\u003eTwo schemas \u003ccode\u003e#Odd\u003c/code\u003e and \u003ccode\u003e#Even\u003c/code\u003e are presented that validate an integer is either odd or even respectively.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to validate an integer value\u0026rsquo;s parity. Two schemas #Odd and #Even are presented that validate an integer is either odd or even respectively. Copied! file.cue Copy code Copied! package example #Even: num={2 * (div(num, 2))} #Odd: num={1 + 2*(div(num, 2))} valid: { \u0026#34;-27\u0026#34;: -27 \u0026amp; #Odd \u0026#34;-22\u0026#34;: -22 \u0026amp; #Even \u0026#34;42\u0026#34;: 42 \u0026amp; #Even \u0026#34;47\u0026#34;: 47 \u0026amp; #Odd } invalid: { \u0026#34;-37\u0026#34;: -37 \u0026amp; #Even \u0026#34;-32\u0026#34;: -32 \u0026amp; #Odd \u0026#34;52\u0026#34;: 52 \u0026amp; #Odd \u0026#34;57\u0026#34;: 57 \u0026amp; #Even } TERMINAL Copy code Copied! $ cue eval -ic valid: { \u0026#34;-27\u0026#34;: -27 \u0026#34;-22\u0026#34;: -22 \u0026#34;42\u0026#34;: 42 \u0026#34;47\u0026#34;: 47 } invalid: { \u0026#34;-37\u0026#34;: _|_ // invalid.\u0026#34;-37\u0026#34;: conflicting values -38 and -37 \u0026#34;-32\u0026#34;: _|_ // invalid.\u0026#34;-32\u0026#34;: conflicting values -31 and -32 \u0026#34;52\u0026#34;: _|_ // invalid.\u0026#34;52\u0026#34;: conflicting values 53 and 52 \u0026#34;57\u0026#34;: _|_ // invalid.\u0026#34;57\u0026#34;: conflicting values 56 and 57 } Related content How-to Guide: Using the built-in functions \u0026#34;div\u0026#34;, \u0026#34;mod\u0026#34;, \u0026#34;quo\u0026#34;, and \u0026#34;rem\u0026#34;",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue","validation"],
        "authors": ["noamtd"]
    },
    
            {
        "objectID": "fc69e43c34db68fa5d25c267c2559807_1",
        "title": "Validating data against a schema in Java",
        "link": "/docs/tutorial/validate-data-schema-java/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThe library \u003ccode\u003ecue-api-java\u003c/code\u003e provides a way to use CUE from Java programs.\nA common use for CUE is validating data against a schema, and this tutorial\nshows you how to use the the \u003ccode\u003echeckSchema()\u003c/code\u003e method to check a \u003ccode\u003eValue\u003c/code\u003e against\na schema. The method throws \u003ccode\u003eCueError\u003c/code\u003e if the CUE value is \u003cem\u003enot\u003c/em\u003e an instance of\nthe schema.\u003c/p\u003e\n\u003cdiv class=\"note note--info\" role=\"alert\"\u003e\n\n\n\n\u003csvg class=\"icon note__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--exclamation\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"note__content\"\u003e\u003ccode\u003ecue-api-java\u003c/code\u003e is an experimental technology preview. This means that it\u0026rsquo;s\nunder development and its behaviour might change from one release to the next.\u003c/div\u003e\n\u003c/div\u003e",
        "content": "The library cue-api-java provides a way to use CUE from Java programs. A common use for CUE is validating data against a schema, and this tutorial shows you how to use the the checkSchema() method to check a Value against a schema. The method throws CueError if the CUE value is not an instance of the schema. cue-api-java is an experimental technology preview. This means that it\u0026rsquo;s under development and its behaviour might change from one release to the next. Prerequisites You need the low-level library libcue to be compiled and available on your computer, which is demonstrated in the guide \u0026ldquo;Building libcue as a shared library\u0026rdquo;. You must have the Java library cue-api-java compiled and available on your computer. The guide \u0026ldquo;Building cue-api-java as a JAR file\u0026rdquo; shows you how to compile and install it. This tutorial needs you to install the same version as that guide. Your computer needs to have the Java Development Kit (JDK) version 22 (or later) installed. If you need help choosing a distribution of Java, the site whichjdk.com is a useful guide. Note that many operating systems offer a \u0026ldquo;Long Term Support\u0026rdquo; version of Java, but this often means JDK version 21, which isn\u0026rsquo;t recent enough. Make sure that you have version 22 or later! Set up your environment 1Tell the operating system (and Java) where to find the library libcue on your computer: TERMINAL Copy code Copied! $ export LD_LIBRARY_PATH=/usr/local/lib/ If you have installed libcue into a different directory than /usr/local/lib/ then adapt the command to refer to that directory instead. 2Tell Java where to find the library cue-api-java on your computer: TERMINAL Copy code Copied! $ export CLASSPATH=\u0026#39;/usr/local/share/java/*\u0026#39; If you have installed cue-api-java into a different directory than /usr/local/share/java/ then adapt the command to refer to that directory instead. 3Cross-check the value of this important variable: TERMINAL Copy code Copied! $ echo \u0026#34;$CLASSPATH\u0026#34; /usr/local/share/java/* Java\u0026rsquo;s requirements mean that we need the value of the CLASSPATH variable to end with an asterisk: make sure you see the trailing *. If this value ends with a filename instead of an asterisk (for example: /usr/local/share/java/CUE.jar) then you need to fix this. Repeat the previous step while making sure that you surround the value of the variable with quotes (') when you export it. 4Check that this tutorial\u0026rsquo;s prerequisites are present: TERMINAL Copy code Copied! $ javac --version javac 22.0.2 $ ls $LD_LIBRARY_PATH | grep libcue.so || echo \u0026#39;fail!\u0026#39; libcue.so $ ls $CLASSPATH | grep /CUE.*jar$ || echo \u0026#39;fail!\u0026#39; /usr/local/share/java/CUE.jar If any of these commands fail then your computer doesn\u0026rsquo;t have the related prerequisite installed as expected and this is a problem that you need to fix before continuing with this tutorial. 5Create a directory to hold some files, and change into it: TERMINAL Copy code Copied! $ mkdir -p cue-java-api-tutorials $ cd cue-java-api-tutorials Create a Java program 6Place this Java program in the file CheckSchema.java: Copied! cue-java-api-tutorials/CheckSchema.java Copy code Copied! import org.cuelang.cue.*; public class CheckSchema { public static void main(String[] args) throws Exception { var ctx = new CueContext(); assertDoesNotThrow(() -\u0026gt; { ctx.toValue(true).checkSchema(ctx.compile(\u0026#34;true\u0026#34;)); ctx.toValue(true).checkSchema(ctx.compile(\u0026#34;bool\u0026#34;)); }); assertThrows(CueError.class, () -\u0026gt; ctx.toValue(true).checkSchema(ctx.compile(\u0026#34;int\u0026#34;)) ); assertDoesNotThrow(() -\u0026gt; { ctx.toValue(1).checkSchema(ctx.compile(\u0026#34;1\u0026#34;)); ctx.toValue(1).checkSchema(ctx.compile(\u0026#34;\u0026lt;128\u0026#34;)); ctx.toValue(1).checkSchema(ctx.compile(\u0026#34;int\u0026#34;)); }); assertThrows(CueError.class, () -\u0026gt; ctx.toValue(1).checkSchema(ctx.compile(\u0026#34;\u0026gt;128\u0026#34;)) ); assertThrows(CueError.class, () -\u0026gt; ctx.toValue(1).checkSchema(ctx.compile(\u0026#34;string\u0026#34;)) ); assertDoesNotThrow(() -\u0026gt; { ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b: 1\u0026#34;)); ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b: int\u0026#34;)); ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b!: int\u0026#34;)); ctx.compile(\u0026#34;a: { b: 1, c: 1 }\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b: int\u0026#34;)); ctx.compile(\u0026#34;a: { b: int, c: 1 }\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b: int\u0026#34;)); }); assertThrows(CueError.class, () -\u0026gt; ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;string\u0026#34;)) ); assertThrows(CueError.class, () -\u0026gt; ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: b: 2\u0026#34;)) ); assertThrows(CueError.class, () -\u0026gt; ctx.compile(\u0026#34;a: b: 1\u0026#34;).checkSchema(ctx.compile(\u0026#34;a: { b: int, c: int }\u0026#34;)) ); } @FunctionalInterface interface ThrowingRunnable { void run() throws Exception; } // Asserts that the given runnable does not throw any exception. static void assertDoesNotThrow(ThrowingRunnable runnable) { try { runnable.run(); } catch (Exception e) { throw new AssertionError( \u0026#34;Expected no exception to be thrown, but got: \u0026#34; + e ); } } // Asserts that the given runnable throws the expected exception. static \u0026lt;T extends Throwable\u0026gt; void assertThrows( Class\u0026lt;T\u0026gt; expectedException, ThrowingRunnable runnable) { try { runnable.run(); throw new AssertionError( \u0026#34;Expected exception: \u0026#34; + expectedException.getName() + \u0026#34; to be thrown, but nothing was thrown.\u0026#34; ); } catch (Throwable actualException) { if (!expectedException.isInstance(actualException)) { throw new AssertionError( \u0026#34;Expected exception: \u0026#34; + expectedException.getName() + \u0026#34; but got: \u0026#34; + actualException ); } } } } Compile the program 7Compile the Java program: TERMINAL Copy code Copied! $ javac CheckSchema.java The Java compiler automatically uses the value of the CLASSPATH environment variable to locate the JAR file containing cue-api-java. Run the program 8Run the Java program: TERMINAL Copy code Copied! $ java --enable-native-access=ALL-UNNAMED -cp .:$CLASSPATH CheckSchema This program doesn\u0026rsquo;t produce any output, demonstrating that all its positive and negative assertions succeed, as expected. The Java runtime must be told about a slightly different classpath from the compiler, through the -cp flag, because it needs to locate both the cue-api-java JAR and your compiled code. The --enable-native-access flag avoids a runtime warning that the Foreign Function \u0026amp; Memory API is being used by cue-api-java. Conclusion Great job! You\u0026rsquo;ve managed to run some Java that demonstrates CUE being used to validate data against schemas. See Related content, below, for tutorials and guides that explain more about using CUE in Java. Related content How-to Guide: Building cue-api-java as a JAR file Tutorial: Getting started using CUE in Java Tutorial: Converting values between Java and CUE Tutorial: Handling errors in the Java API java api \u0026ndash; all pages exploring the CUE Java API",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["java api"],
        "authors": ["4ad","jpluscplusm"]
    },
    
            {
        "objectID": "85fa06d462cad34e6b75f36045760ceb_1",
        "title": "Validating Go values using the cuego API",
        "link": "/docs/howto/validate-go-cuego/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to use the\n\u003ca href=\"https://pkg.go.dev/cuelang.org/go/cuego#section-documentation\"\u003e\u003ccode\u003ecuego\u003c/code\u003e\u003c/a\u003e\nAPI to validate Go values against CUE constraints expressed in\n\u003ca href=\"https://go.dev/ref/spec#Struct_types\"\u003eGo struct tags\u003c/a\u003e.\u003c/p\u003e",
        "content": "This guide demonstrates how to use the cuego API to validate Go values against CUE constraints expressed in Go struct tags. Create a Go program using cuego 1Initialize a Go module, or use an existing one if that\u0026rsquo;s more suitable for your situation: TERMINAL Copy code Copied! $ go mod init go.example ... 2Create a main program that uses the cuego API to perform the validation you require. You can use this example code as a starting point: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;cuelang.org/go/cue/errors\u0026#34; \u0026#34;cuelang.org/go/cuego\u0026#34; ) // Policy contains fields with struct tags in the \u0026#34;cue\u0026#34; namespace. // These tags are read by the cuego API, and define field-level CUE constraints. type Policy struct { Level int `cue:\u0026#34;\u0026gt;10\u0026#34;` Action string `cue:\u0026#34; \\\u0026#34;Allow\\\u0026#34; | \\\u0026#34;Deny\\\u0026#34; \u0026#34;` } func main() { // check uses the cuego API to validate an instance of a Policy against the // CUE constraints embedded in the type definition. It returns either a // success message, or one or more errors formatted as a string. check := func(p Policy) string { if err := cuego.Validate(p); err != nil { return errors.Details(err, nil) } return \u0026#34; ok\u0026#34; } // good is an instance of a Policy that adheres to the type\u0026#39;s CUE constraints. good := Policy{ Level: 100, Action: \u0026#34;Allow\u0026#34;, } // bad is an instance of a Policy that violates the type\u0026#39;s CUE constraints. bad := Policy{ Level: 5, Action: \u0026#34;Bypass\u0026#34;, } // Display the validation result for each Policy instance. fmt.Printf(\u0026#34;good: %v\\n\u0026#34;, check(good)) fmt.Printf(\u0026#34;bad: %v\\n\u0026#34;, check(bad)) } This example code uses cuego to check two instances of a simple struct type (good / bad) against CUE constraints embedded in the type definition (Policy), and prints the validation result for each instance. 3Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... 4Run the program: TERMINAL Copy code Copied! $ go run . good:  ok bad: Action: 2 errors in empty disjunction: Action: conflicting values \u0026#34;Allow\u0026#34; and \u0026#34;Bypass\u0026#34;: \u0026lt;field:\u0026gt;:1:2 Action: conflicting values \u0026#34;Deny\u0026#34; and \u0026#34;Bypass\u0026#34;: \u0026lt;field:\u0026gt;:1:12 Level: invalid value 5 (out of bound \u0026gt;10): \u0026lt;field:\u0026gt;:1:1 Related content Go API: cuego \u0026ndash; package documentation Go API: cue/errors \u0026ndash; package documentation Tag: go api \u0026ndash; pages explaining and exploring CUE\u0026rsquo;s Go API",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["go api","validation"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "36a3ba684d2a6eeab9810d24ff9c240a_1",
        "title": "Validating JSON using CUE",
        "link": "/docs/howto/validate-json-using-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eValidating JSON \u003cem\u003evalues\u003c/em\u003e to be of specific data types is a common need for many\nsituations. Ensuring that the values in your JSON file are valid is essential\nto avoid configuration-related errors. This How-to Guide checks and ensures\neach value in a JSON file is the \u003cem\u003edata type\u003c/em\u003e it\u0026rsquo;s supposed to be, using the CUE\ncommand line.\u003c/p\u003e",
        "content": "Introduction Validating JSON values to be of specific data types is a common need for many situations. Ensuring that the values in your JSON file are valid is essential to avoid configuration-related errors. This How-to Guide checks and ensures each value in a JSON file is the data type it\u0026rsquo;s supposed to be, using the CUE command line. Prerequisites You have CUE installed locally. This allows you to run cue commands Requirements Using the command line or terminal File editing Steps 1Create a JSON file called x.json with the following: Copied! x.json Copy code Copied! { \u0026#34;people\u0026#34;: { \u0026#34;Gopher\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Gopher\u0026#34;, \u0026#34;age\u0026#34;: 12, \u0026#34;address\u0026#34;: \u0026#34;Mountain View\u0026#34; }, \u0026#34;Ken\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Ken\u0026#34;, \u0026#34;age\u0026#34;: 21, \u0026#34;address\u0026#34;: \u0026#34;The Blue Sky\u0026#34; } } } 2Create a CUE file named x.cue The following CUE creates a CUE definition that describes the data type constraints for every person. Copied! x.cue Copy code Copied! #Person: { name: string age: int address: string } people: [X=string]: #Person \u0026amp; { name: X } 3Run the following cue command in your terminal: TERMINAL Copy code Copied! $ cue vet -c x.cue x.json NOTE: cue vet is silent when run successfully. Output will only show on error. 4Add another person to your JSON data by replacing your x.json file with the following: Copied! x.json Copy code Copied! { \u0026#34;people\u0026#34;: { \u0026#34;Gopher\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Gopher\u0026#34;, \u0026#34;age\u0026#34;: 12, \u0026#34;address\u0026#34;: \u0026#34;Mountain View\u0026#34; }, \u0026#34;Ken\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Ken\u0026#34;, \u0026#34;age\u0026#34;: 21, \u0026#34;address\u0026#34;: \u0026#34;The Blue Sky\u0026#34; }, \u0026#34;Rob\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Rob\u0026#34;, \u0026#34;age\u0026#34;: 42.2, \u0026#34;address\u0026#34;: \u0026#34;CUEtopia\u0026#34; } } } 5Validate again with cue vet: TERMINAL Copy code Copied! $ cue vet -c x.cue x.json people.Rob.age: conflicting values 42.2 and int (mismatched types float and int): ./x.cue:3:11 ./x.json:15:20 The command output shows validation errors where the JSON violates the (type) constraints that you have declared. 6Fix up the JSON: Copied! x.json Copy code Copied! { \u0026#34;people\u0026#34;: { \u0026#34;Gopher\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Gopher\u0026#34;, \u0026#34;age\u0026#34;: 12, \u0026#34;address\u0026#34;: \u0026#34;Mountain View\u0026#34; }, \u0026#34;Ken\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Ken\u0026#34;, \u0026#34;age\u0026#34;: 21, \u0026#34;address\u0026#34;: \u0026#34;The Blue Sky\u0026#34; }, \u0026#34;Rob\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Rob\u0026#34;, \u0026#34;age\u0026#34;: 42, \u0026#34;address\u0026#34;: \u0026#34;CUEtopia\u0026#34; } } } 7Validate with cue vet again TERMINAL Copy code Copied! $ cue vet -c x.cue x.json The cue vet command will show no output on success. Well done! Any future data errors on names, ages, and addresses in your JSON will be detected. This is especially helpful with JSON files with 100s (and even 1000s) of lines. Further reading/See Also cmd/cue command line documentation",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "4da8c1a851e14eaf1bc37ce076952800_1",
        "title": "Validating JSON using the Go API",
        "link": "/docs/howto/validate-json-using-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to write a Go program that validates JSON files\nusing an embeded CUE schema.\u003c/p\u003e",
        "content": "This guide demonstrates how to write a Go program that validates JSON files using an embeded CUE schema. Set up some schema and data files 1Create a CUE schema. You can use any schema that\u0026rsquo;s relevant to your specific data, but our example uses this simple CUE: Copied! schema.cue Copy code Copied! #Schema: { name?: string age?: int } 2Create some known-good and known-bad test data. You may already have some representative test data. This data is relevant to our example schema: Copied! good.json Copy code Copied! { \u0026#34;name\u0026#34;: \u0026#34;Charlie Cartwright\u0026#34;, \u0026#34;age\u0026#34;: 80 } Copied! bad.json Copy code Copied! { \u0026#34;name\u0026#34;: [ \u0026#34;Moby\u0026#34;, \u0026#34;Dick\u0026#34; ], \u0026#34;age\u0026#34;: \u0026#34;173\u0026#34; } 3Verify that your schema accepts and rejects your test data appropriately. Our example schema is contained in the #Schema definition, which we reference explicitly: TERMINAL Copy code Copied! $ cue vet -c schema.cue good.json -d \u0026#39;#Schema\u0026#39; $ cue vet -c schema.cue bad.json -d \u0026#39;#Schema\u0026#39; age: conflicting values \u0026#34;173\u0026#34; and int (mismatched types string and int): ./bad.json:6:12 ./schema.cue:3:9 name: conflicting values [\u0026#34;Moby\u0026#34;,\u0026#34;Dick\u0026#34;] and string (mismatched types list and string): ./bad.json:2:13 ./schema.cue:2:9 Create a Go program 4Initialize a Go module, or use an existing one if that\u0026rsquo;s more suitable for your situation: TERMINAL Copy code Copied! $ go mod init go.example ... 5Create a main program. You can use this example code as a starting point: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;embed\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/encoding/json\u0026#34; ) // Embed our schema in a Go string variable. // //go:embed schema.cue var cueSource string func main() { ctx := cuecontext.New() // Build the schema schema := ctx.CompileString(cueSource).LookupPath(cue.ParsePath(\u0026#34;#Schema\u0026#34;)) // Load the JSON file specified (the program\u0026#39;s sole argument) as a CUE value dataFilename := os.Args[1] dataFile, err := os.ReadFile(dataFilename) if err != nil { log.Fatal(err) } dataExpr, err := json.Extract(dataFilename, dataFile) if err != nil { log.Fatal(err) } dataAsCUE := ctx.BuildExpr(dataExpr) // Validate the JSON data using the schema unified := schema.Unify(dataAsCUE) if err := unified.Validate(); err != nil { fmt.Println(\u0026#34; JSON: NOT ok\u0026#34;) log.Fatal(err) } fmt.Println(\u0026#34; JSON: ok\u0026#34;) } This example code embeds the CUE from schema.cue and uses it to validate a single JSON file, printing the validation result to its standard output stream. 6Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... Run the Go program 7Verify that the Go program accepts and rejects your test data as expected: TERMINAL Copy code Copied! $ go run . good.json  JSON: ok $ go run . bad.json  JSON: NOT ok #Schema.name: conflicting values string and [\u0026#34;Moby\u0026#34;,\u0026#34;Dick\u0026#34;] (mismatched types string and list) (and 1 more errors) exit status 1 Related content Go API: cue \u0026ndash; package documentation Go API: cue/cuecontext \u0026ndash; package documentation Go API: encoding/json \u0026ndash; package documentation Tag: go api \u0026ndash; pages explaining and exploring CUE\u0026rsquo;s Go API",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["go api","validation","encodings"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "ac0f00413de4563ab1b4e4f367fd9792_1",
        "title": "Validating simple YAML files with the cue command",
        "link": "/docs/tutorial/validating-simple-yaml-files/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn this tutorial, you will use the \u003ccode\u003ecue\u003c/code\u003e command to check that simple YAML data\nfiles are valid.\u003c/p\u003e\n\u003cp\u003eAlong the way, you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstall the \u003ccode\u003ecue\u003c/code\u003e command (if you haven\u0026rsquo;t already).\u003c/li\u003e\n\u003cli\u003eDefine a schema in CUE.\u003c/li\u003e\n\u003cli\u003eValidate a single data file using your schema.\u003c/li\u003e\n\u003cli\u003eDiscover some mistakes in your data file.\u003c/li\u003e\n\u003cli\u003eFix your data file and revalidate it.\u003c/li\u003e\n\u003cli\u003eValidate multiple data files at once.\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "In this tutorial, you will use the cue command to check that simple YAML data files are valid. Along the way, you will: Install the cue command (if you haven\u0026rsquo;t already). Define a schema in CUE. Validate a single data file using your schema. Discover some mistakes in your data file. Fix your data file and revalidate it. Validate multiple data files at once. Prerequisites A tool to edit text files. Any text editor you have will be fine, for example VSCode. A command terminal. cue works on all platforms, so any terminal on Linux or macOS, and on PowerShell, cmd.exe or WSL in Windows. Install the cue command 1If you have not already, follow the steps for downloading and installing CUE. Validate a single data file 2Open a command prompt and create a new directory to hold this tutorial\u0026rsquo;s files. For example: TERMINAL Copy code Copied! $ pwd # we start in our home directory, but you do not need to /home/runner $ mkdir validating-yaml-with-cue $ cd validating-yaml-with-cue 3Create a data file named charlie.yml to hold Charlie the cat\u0026rsquo;s details. Place this information in it, including the deliberate mistake in the species field: Copied! validating-yaml-with-cue/charlie.yml Copy code Copied! name: first: Charlie last: Cartwright species: goldfish age: \u0026#34;15\u0026#34; 4Create a file called pets.cue to hold your schema, and place this CUE in it: Copied! validating-yaml-with-cue/pets.cue Copy code Copied! species!: \u0026#34;cat\u0026#34; | \u0026#34;dog\u0026#34; age?: number cue will check that your data files are valid, that they satisfy this schema. Line 1 is important because, for the purposes of this tutorial, all pets are cats or dogs, so the species field can only contain one of a fixed set of options. This is what CUE calls a disjunction, and is indicated by a pipe symbol (\u0026quot;|\u0026quot;). On line 1 the species field is marked with an exclamation mark (\u0026quot;!\u0026quot;). This means that the field must be present in the data, which CUE calls a required field. On line 2 the age field is marked with a question mark (\u0026quot;?\u0026quot;). CUE calls this an optional field, which means that the field may present in the data, but it may not. The age field is constrained such that, if it is present, it has to be of type number. The number type constraint permits values that are either integers or decimal floating-point numbers. CUE has other primitive types that you can use to constrain a field\u0026rsquo;s value. 5Check that the charlie.yml data file satisfies the schema you defined in pets.cue: TERMINAL Copy code Copied! $ cue vet -c pets.cue charlie.yml age: conflicting values \u0026#34;15\u0026#34; and number (mismatched types string and number): ./charlie.yml:5:6 ./pets.cue:2:11 species: 2 errors in empty disjunction: species: conflicting values \u0026#34;cat\u0026#34; and \u0026#34;goldfish\u0026#34;: ./charlie.yml:4:10 ./pets.cue:1:11 species: conflicting values \u0026#34;dog\u0026#34; and \u0026#34;goldfish\u0026#34;: ./charlie.yml:4:10 ./pets.cue:1:19 cue vet is telling you that there are problems with 2 fields in your data file. Firstly, there is a conflict between what is specified for the age field in charlie.yml on line 5, and the schema\u0026rsquo;s constraints in pets.cue on line 2. cue tells you about these mismatched types, along with pointers to the files and line numbers that disagree with each other. Looking at the files, you can see that your schema says that the age field has to be a number if it is present. In your data file the quotation marks around the number 15 mean that the value is actually a string. Secondly, cue vet says that there are 2 errors in empty disjunction, relating to the species field. This is followed by a pair of conflicting values ... error messages pointing to the files and line numbers that are conflicting. This is cue\u0026rsquo;s way of showing you that it compared the field\u0026rsquo;s value in the data file (goldfish) against both options permitted by your schema (dog or cat), and that it failed to find any options that matched, or unified, successfully. 6Update charlie.yml to: Fix the type mismatch in the age field by removing both quotation marks around the value. Change the species field to the value cat, a valid species according to our schema. Your corrected data file should read as follows: Copied! validating-yaml-with-cue/charlie.yml Copy code Copied! name: first: Charlie last: Cartwright species: cat age: 15 7Re-check the data file against the CUE schema: TERMINAL Copy code Copied! $ cue vet -c pets.cue charlie.yml Notice how the command returns instantly, with no output. This is how the cue vet command tells you that everything is fine: by saying nothing, and silently returning an exit code of 0 to your shell. If you do see some output, it is a sign that you have made some small mistake while following the tutorial or fixing the data file. Do not worry if this happens - just go back a few steps and try again! Validating multiple data files The cue vet command can check more than one data file at once. 8Add a second data file containing the details of another pet. Create a data file named toby.yml to hold Toby the dog\u0026rsquo;s details: Copied! validating-yaml-with-cue/toby.yml Copy code Copied! name: first: Toby last: Dog species: dog age: 12.5 9Ask cue to check that both data files satisfy your schema in pets.cue: TERMINAL Copy code Copied! $ cue vet -c pets.cue charlie.yml toby.yml The command\u0026rsquo;s success (and lack of any error message) confirms that both data files are valid, because both their contents are permitted by the constraints you placed in your schema. cue vet validates each data file independently. Each file must independently satisfy the schema. Conclusion Well done! You can now use your pets.cue file to validate the contents of any number of pet data files in the future. More usefully, you can now write simple schema files to describe the important details of your own YAML and JSON data files, and you can use the cue vet command to check that your data files satisfy any schemas you create.",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["cue command","validation","yaml"],
        "authors": ["jpluscplusm","myitcv"]
    },
    
            {
        "objectID": "83c4e601ba7a479e71ac723dfb20cebe_1",
        "title": "Validating YAML using CUE",
        "link": "/docs/howto/validate-yaml-using-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eValidating YAML \u003cem\u003evalues\u003c/em\u003e to be of specific data types is a common need for many\nsituations. Ensuring that the values in your YAML file are valid is essential to\navoid configuration-related errors. This How-to Guide checks and ensures each\nvalue in a YAML file is the \u003cem\u003edata type\u003c/em\u003e it\u0026rsquo;s supposed to be, using the CUE command line.\u003c/p\u003e",
        "content": "Introduction Validating YAML values to be of specific data types is a common need for many situations. Ensuring that the values in your YAML file are valid is essential to avoid configuration-related errors. This How-to Guide checks and ensures each value in a YAML file is the data type it\u0026rsquo;s supposed to be, using the CUE command line. Prerequisites You have CUE installed locally. This allows you to run cue commands Requirements Using the command line or terminal File editing Steps Create a YAML file called x.yaml with the following: Copied! x.yaml Copy code Copied! people: Gopher: name: Gopher age: 12 address: Mountain View Ken: name: Ken age: 21 address: The Blue Sky Create a CUE file named x.cue The following CUE creates a CUE definition that describes the data type constraints for every person. Copied! x.cue Copy code Copied! #Person: { name: string age: int address: string } people: [X=string]: #Person \u0026amp; { name: X } Run the following cue command in your: TERMINAL Copy code Copied! $ cue vet -c x.cue x.yaml NOTE: cue vet is silent when run successfully. Output will only show on error. Add another person to your YAML data. Copied! x.yaml Copy code Copied! people: Gopher: name: Gopher age: 12 address: Mountain View Ken: name: Ken age: 21 address: The Blue Sky Rob: name: Rob age: 42.2 address: CUEtopia Validate again with cue vet TERMINAL Copy code Copied! $ cue vet -c x.cue x.yaml people.Rob.age: conflicting values 42.2 and int (mismatched types float and int): ./x.cue:3:11 ./x.yaml:12:10 The command output shows validation errors where the YAML violates the (type) constraints that you have declared. Fix up the YAML Copied! x.yaml Copy code Copied! people: Gopher: name: Gopher age: 12 address: Mountain View Ken: name: Ken age: 21 address: The Blue Sky Rob: name: Rob age: 42 address: CUEtopia Validate with cue vet again TERMINAL Copy code Copied! $ cue vet -c x.cue x.yaml The cue vet command will show no output on success. Well done! Any future data errors on names, ages, and addresses in your YAML will be detected. This is especially helpful with YAML files with 100s (and even 1000s) of lines. Further reading/See Also cmd/cue command line documentation",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["cue command"],
        "authors": ""
    },
    
            {
        "objectID": "a1cc56c78a6b8d0b87f0dcc10eddc42f_1",
        "title": "Walking schemas using the Go API",
        "link": "/docs/howto/walk-schemas-using-go-api/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis guide demonstrates how to walk a CUE schema using the Go API,\nprogrammatically inspecting its structure and types.\nThe Go code shown here is a limited code generator and,\nas presented, it generates Go structs from simple CUE definitions.\nIt could be adapted to other schema-walking tasks - not just code generation.\u003c/p\u003e",
        "content": "This guide demonstrates how to walk a CUE schema using the Go API, programmatically inspecting its structure and types. The Go code shown here is a limited code generator and, as presented, it generates Go structs from simple CUE definitions. It could be adapted to other schema-walking tasks - not just code generation. Initialize Go and CUE modules 1Create a Go module, or use an existing one if that\u0026rsquo;s more suitable for your situation: TERMINAL Copy code Copied! $ go mod init go.example ... 2Create a CUE module if you don\u0026rsquo;t already have one: TERMINAL Copy code Copied! $ cue mod init cue.example The identifiers for the CUE and Go modules don\u0026rsquo;t need to match, but it doesn\u0026rsquo;t matter if they\u0026rsquo;re the same. Declare a CUE schema 3Declare the CUE schema that you wish to walk. We\u0026rsquo;ll use the following example.cue file, but you should use some CUE that\u0026rsquo;s specific to your situation. Copied! example.cue Copy code Copied! package example #Person: { name!: string age?: int \u0026amp; \u0026gt;=0 } #Address: { line1!: string line2?: string line3?: string country?: string } aPerson: #Person \u0026amp; { name: \u0026#34;John Adams\u0026#34; } anAddress: #Address \u0026amp; { line1: \u0026#34;1600 Pennsylvania Ave NW\u0026#34; line2: \u0026#34;Washington, DC 20500\u0026#34; country: \u0026#34;United States of America\u0026#34; } someData: aValue: 42 _aHiddenField: aValue: 139 Our example.cue file contains two definitions that we want to process: #Person and #Address. It also includes concrete data fields and a hidden field, which we don\u0026rsquo;t consider as schema. The data and hidden fields are included in order to demonstrate that they are not processed by the code presented below. 4Ensure there are no errors in our CUE: TERMINAL Copy code Copied! $ cue vet -c Use a Go program to walk the schema 5Create the file main.go and add the following code: Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; ) func main() { ctx := cuecontext.New() // Load CUE from the package in the current directory insts := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) v := ctx.BuildInstance(insts[0]) if err := v.Err(); err != nil { log.Fatal(err) } // \u0026#34;Render\u0026#34; the top-level struct definitions as Go types fmt.Printf(\u0026#34;package p\\n\\n\u0026#34;) it, err := v.Fields(cue.Definitions(true)) if err != nil { log.Fatal(err) } for it.Next() { v := it.Value() if !it.Selector().IsDefinition() || v.IncompleteKind() != cue.StructKind { continue } structToType(it.Selector(), it.Value()) } } // structToType prints the top-level fields of a struct value func structToType(name cue.Selector, val cue.Value) { fmt.Printf(\u0026#34;type %v struct {\\n\u0026#34;, strings.TrimPrefix(name.String(), \u0026#34;#\u0026#34;)) // Iterate through the fields of the struct it, _ := val.Fields(cue.Optional(true)) for it.Next() { switch k := it.Value().IncompleteKind(); k { case cue.StringKind, cue.IntKind, cue.FloatKind, cue.BoolKind: fmt.Printf(\u0026#34;\\t%v %v\\n\u0026#34;, it.Selector().Unquoted(), it.Value().IncompleteKind()) } } fmt.Printf(\u0026#34;}\\n\u0026#34;) } 6Add a dependency on cuelang.org/go and ensure the Go module is tidy: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... You can use @latest in place of a specific version. 7Run the Go program: TERMINAL Copy code Copied! $ go run . package p type Person struct { name string age int } type Address struct { line1 string line2 string line3 string country string } As you can see from its output, this Go program is a very limited form of code generator that takes each CUE definition and produces a matching Go struct type. Related content The cue Go API The cue/cuecontext Go API The cue/load Go API Reference: cue help mod init Reference: cue help vet Language Tour: Definitions",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["go api"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "38088f7144263baab4048686939e21e1_1",
        "title": "Working with a custom module registry",
        "link": "/docs/tutorial/working-with-a-custom-module-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will learn how to create and work with CUE modules,\nusing a custom module registry.\u003c/p\u003e\n\u003cp\u003eAlong the way you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDefine a module containing a CUE schema\u003c/li\u003e\n\u003cli\u003ePush the module to a custom registry\u003c/li\u003e\n\u003cli\u003eDefine a top level module that depends on the first module\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ecue mod tidy\u003c/code\u003e to automatically add dependencies and their versions to the \u003ccode\u003emodule.cue\u003c/code\u003e file\u003c/li\u003e\n\u003cli\u003ePublish a module containing a CUE template that depends on the schema\u003c/li\u003e\n\u003cli\u003eUpdate the top level module to depend on the template\u003c/li\u003e\n\u003cli\u003eUpdate the schema and its version, and update the top level module to depend on the new version\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "Introduction In this tutorial you will learn how to create and work with CUE modules, using a custom module registry. Along the way you will: Define a module containing a CUE schema Push the module to a custom registry Define a top level module that depends on the first module Use cue mod tidy to automatically add dependencies and their versions to the module.cue file Publish a module containing a CUE template that depends on the schema Update the top level module to depend on the template Update the schema and its version, and update the top level module to depend on the new version Prerequisites A tool to edit text files. Any text editor you have will be fine, for example VSCode. A command terminal. cue works on all platforms, so any terminal on Linux or macOS, and on PowerShell, cmd.exe or WSL in Windows. An installed cue binary (installation details) Some awareness of CUE schemata (Constraints and Definitions in the CUE tour) This tutorial is written using the following version of cmd/cue: TERMINAL Copy code Copied! $ cue version cue version v0.13.0 ... Create the module for the schema code In this tutorial we will focus on an imaginary application called FrostyApp, which consumes its configuration in YAML format. You will define the configuration in CUE and use a CUE schema to validate it. We would like to be able to share the schema between several consumers. 1Create a directory to hold the schema code: TERMINAL Copy code Copied! $ mkdir frostyconfig $ cd frostyconfig Each module described in this tutorial will live in a separate directory, which you will create as they are needed. 2Initialize the directory as a git repository and a CUE module: TERMINAL Copy code Copied! $ git init -q $ cue mod init --source=git glacial-tech.example/frostyconfig@v0 In order to publish the module to a registry, the code must hold a cue.mod/module.cue file declaring its module path. This is the path prefix to use when importing packages from within the module. Module paths are fully domain-name qualified, and it is good practice to place the module under a domain or a GitHub repository that you control. We will use a custom registry in this tutorial, which has fewer restrictions on the module paths that can be used. By contrast a central shared registry may require proof of control of a domain before allowing updates to a module in that domain. In our example we will assume that we control the domain name glacial-tech.example and place all module paths under that. There are some other constraints on the names that can be used for a module, due to OCI restrictions. The module name must contain only lower-case ASCII letters, ASCII digits, dots (.), and dashes (-). The OCI distribution spec contains full details of the naming restrictions. The --source=git flag tells cue to use the same file-inclusion rules as git, when publishing this module. Modules are always named with the major version at the end of the module path. This is independent from the naming restrictions detailed above: the same OCI repository is used for all major and minor versions of a given module in a registry. 3Create the configuration schema: Copied! frostyconfig/config.cue Copy code Copied! package frostyconfig // #Config defines the schema for the FrostyApp configuration. #Config: { // appName defines the name of the application. appName!: string // port holds the port number the application listens on. port!: int // debug holds whether to enable debug mode. debug?: bool // features holds optional feature settings features?: { // logging enables or disables logging. logging?: bool // analytics enables or disables analytics. analytics?: bool } } The details of the schema are not too important. For the purposes of this tutorial, it represents the schema of the configuration data expected by FrostyApp. Choose an OCI registry 4If you do not have access to an OCI registry, start one locally: TERMINAL Copy code Copied! $ cue mod registry localhost:5001 cue mod registry is a very simple in-memory OCI server. If this command fails with a message mentioning \u0026ldquo;address already in use\u0026rdquo;, then some other program on your computer is already using port 5001. To resolve this, select a different port number and re-run the command using the new value. You will also need to update any commands that use port 5001 as you follow this guide. CUE should work with all OCI-compatible artifact registries, such as the Google Artifact Registry, as CUE uses the standard OCI protocols spoken by such registries. For example, here are some alternatives: TERMINAL Copy code Copied! # running a local registry via docker $ docker run -p 5001:5000 registry # running a local registry via podman $ podman run -p 5001:5000 registry In our example we will run a local instance of the in-memory registry on port 5001. If you need to run one locally, invoke the above docker command in a separate terminal so the registry remains running while you follow the rest of this tutorial. Publish the module 5Set up a required environment variable: TERMINAL Copy code Copied! $ export CUE_REGISTRY=localhost:5001/cuemodules The CUE_REGISTRY variable tells the cue command which registry to use when fetching and pushing modules. In our example the modules will be stored in the registry under the prefix cuemodules. In practice you would want this prefix to be some place of your choice - or you could leave the prefix empty if you plan to dedicate the registry to holding CUE modules. 6Ensure the module.cue file is tidy: TERMINAL Copy code Copied! $ cue mod tidy This command checks that modules for all imported packages are present in the cue.mod/module.cue file and that their versions are correct. It is good practice to run this before publishing a module. So, although this module does not have any dependencies, we will run cue mod tidy anyway. 7Create a git commit: TERMINAL Copy code Copied! $ git add -A $ git commit -q -m \u0026#39;Initial commit\u0026#39; Earlier, you initialized",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "38088f7144263baab4048686939e21e1_2",
        "title": "Working with a custom module registry",
        "link": "/docs/tutorial/working-with-a-custom-module-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will learn how to create and work with CUE modules,\nusing a custom module registry.\u003c/p\u003e\n\u003cp\u003eAlong the way you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDefine a module containing a CUE schema\u003c/li\u003e\n\u003cli\u003ePush the module to a custom registry\u003c/li\u003e\n\u003cli\u003eDefine a top level module that depends on the first module\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ecue mod tidy\u003c/code\u003e to automatically add dependencies and their versions to the \u003ccode\u003emodule.cue\u003c/code\u003e file\u003c/li\u003e\n\u003cli\u003ePublish a module containing a CUE template that depends on the schema\u003c/li\u003e\n\u003cli\u003eUpdate the top level module to depend on the template\u003c/li\u003e\n\u003cli\u003eUpdate the schema and its version, and update the top level module to depend on the new version\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "this module with --source=git, which told the cue command that it should publish only those files that git knows about. The git commit you just created leaves the directory in a \u0026ldquo;clean\u0026rdquo; state, which is necessary for cue to know exactly which files to include in the published module. 8Publish the first version of this module: TERMINAL Copy code Copied! $ cue mod publish v0.0.1 ... This command uploads the module to the registry and publishes it under version v0.0.1. It will be published to the module path we chose in cue mod init earlier - all we need to do in this command is to decide which version we will publish. The version follows semver syntax, and it is good practice to follow semantic version conventions, which include maintaining compatability with earlier minor versions of the same module. The major version under which it is published must match the major version specified in the module file. For example it would be an error to use v1.0.1 here because the module name ends in @v0. The module has now been published to the registry. If you are running a registry locally then you might have seen some output in the docker terminal while the registry received and stored the module. Create a new frostyapp module that depends on the first module Define the actual FrostyApp configuration, constrained by the schema you just published. 9Create a directory and initalize a git repository and a new CUE module within it: TERMINAL Copy code Copied! $ mkdir ../frostyapp $ cd ../frostyapp $ git init -q $ cue mod init --source=git glacial-tech.example/frostyapp@v0 10Create the code for the new module: Copied! frostyapp/config.cue Copy code Copied! package frostyapp import \u0026#34;glacial-tech.example/frostyconfig@v0\u0026#34; config: frostyconfig.#Config \u0026amp; { appName: \u0026#34;alpha\u0026#34; port: 80 features: logging: true } This imports the frostyconfig package from the first module you published and defines some concrete values for the configuration, constrained by the frostyconfig.#Config schema. 11Ensure the module is tidy, pulling all dependencies: TERMINAL Copy code Copied! $ cue mod tidy We can see that the dependencies have now been added to the cue.mod/module.cue file: TERMINAL Copy code Copied! $ cat cue.mod/module.cue module: \u0026#34;glacial-tech.example/frostyapp@v0\u0026#34; language: { version: \u0026#34;v0.13.0\u0026#34; } source: { kind: \u0026#34;git\u0026#34; } deps: { \u0026#34;glacial-tech.example/frostyconfig@v0\u0026#34;: { v: \u0026#34;v0.0.1\u0026#34; } } Our dependencies currently look like this: flowchart TD frostyapp-- v0.0.1 --\u003e frostyconfig Current dependencies Evaluate the configuration 12Export the configuration as YAML: TERMINAL Copy code Copied! $ cue export --out yaml config: appName: alpha port: 80 features: logging: true We can use this new module code just like any other CUE code. Publish a frostytemplate module Suppose we want to define a module that encapsulates some default values for FrostyApp. We could just publish it as part of the frostyconfig original module, but publishing it as a separate module will be useful to demonstrate how dependencies work. Having different modules like this can also be a useful separation of concerns when a schema comes from some other source of truth. 13Create a directory and initalize a git repository and a new CUE module within it: TERMINAL Copy code Copied! $ mkdir ../frostytemplate $ cd ../frostytemplate $ git init -q $ cue mod init --source=git glacial-tech.example/frostytemplate@v0 This defines another module. We have named it frostytemplate because CUE uses the term \u0026ldquo;template\u0026rdquo; to mean code that defines default values and derived data but is not intended to be the final configuration. 14Define the CUE template: Copied! frostytemplate/template.cue Copy code Copied! package frostytemplate import \u0026#34;glacial-tech.example/frostyconfig@v0\u0026#34; // Config defines a set of default values for frostyconfig.#Config. Config: frostyconfig.#Config \u0026amp; { port: *80 | _ debug: *false | _ features: { logging: *true | _ analytics: *true | _ } } We import the schema to constrain the default values, just as we did with the frostyapp module. 15Tidy the module and create a git commit: TERMINAL Copy code Copied! $ cue mod tidy $ git add -A $ git commit -q -m \u0026#39;Initial commit\u0026#39; 16Publish the frostytemplate module: TERMINAL Copy code Copied! $ cue mod publish v0.0.1 ... Update the frostyapp module 17Update the frostyapp module to make use of this new template module: TERMINAL Copy code Copied! $ cd ../frostyapp Copied! frostyapp/config.cue Copy code Copied! package frostyapp import \u0026#34;glacial-tech.example/frostytemplate@v0\u0026#34; config: frostytemplate.Config \u0026amp; { appName: \u0026#34;alpha\u0026#34; } The frostyapp module now gains the benefit of the new defaults. We can remove some fields because they are now provided by the template, satisfying the requirements of the configuration. 18Resolve dependencies in frostyapp: TERMINAL Copy code Copied! $ cue mod tidy Re-running cue mod tidy updates the dependencies in frostyapp to use frostytemplate as well as frostyconfig. Here is what the cue.mod/module.cue file now looks like: TERMINAL Copy code Copied! $ cat cue.mod/module.cue module: \u0026#34;glacial-tech.example/frostyapp@v0\u0026#34; language: { version: \u0026#34;v0.13.0\u0026#34; } source: { kind: \u0026#34;git\u0026#34; } deps: { \u0026#34;glacial-tech.example/frostyconfig@v0\u0026#34;: { v: \u0026#34;v0.0.1\u0026#34; } \u0026#34;glacial-tech.example/frostytemplate@v0\u0026#34;: { v: \u0026#34;v0.0.1\u0026#34; } } flowchart TD frostyapp-- v0.0.1 --\u003e frostytemplate frostytemplate-- v0.0.1 --\u003e frostyconfig Current dependencies 19Re-render the configuration as YAML: TERMINAL Copy code Copied! $ cue export --out yaml config: appName: alpha port: 80 debug: false features: logging: true analytics: true We can see that the values in the configuration reflect the new default values. Add a new field to the schema Suppose that FrostyApp has gained the ability to limit the amount of concurrency it uses, configured with a new maxConcurrency field. We will add that field to the schema and update the app to use it. 20Update the schema to add a new maxConcurrency field: TERMINAL Copy code Copied! $ cd ../frostyconfig Copied! frostyconfig/config.cue Copy code Copied! package frostyconfig // #Config defines the schema for the FrostyApp configuration. #Config: { // appName defines the name of the application. appName!: string // port holds the port number the application listens on. port!: int // debug holds whether to enable debug mode. debug?: bool // maxConcurrency specifies the maximum amount of // concurrent requests to process concurrently. maxConcurrency?: int \u0026amp; \u0026gt;=1 // features holds optional feature settings features?: { // logging enables or disables",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "38088f7144263baab4048686939e21e1_3",
        "title": "Working with a custom module registry",
        "link": "/docs/tutorial/working-with-a-custom-module-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will learn how to create and work with CUE modules,\nusing a custom module registry.\u003c/p\u003e\n\u003cp\u003eAlong the way you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDefine a module containing a CUE schema\u003c/li\u003e\n\u003cli\u003ePush the module to a custom registry\u003c/li\u003e\n\u003cli\u003eDefine a top level module that depends on the first module\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ecue mod tidy\u003c/code\u003e to automatically add dependencies and their versions to the \u003ccode\u003emodule.cue\u003c/code\u003e file\u003c/li\u003e\n\u003cli\u003ePublish a module containing a CUE template that depends on the schema\u003c/li\u003e\n\u003cli\u003eUpdate the top level module to depend on the template\u003c/li\u003e\n\u003cli\u003eUpdate the schema and its version, and update the top level module to depend on the new version\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "logging. logging?: bool // analytics enables or disables analytics. analytics?: bool } } The schema is unchanged except for the new maxConcurrency field. 21Tidy the module and create a git commit: TERMINAL Copy code Copied! $ cue mod tidy $ git add -A $ git commit -q -m \u0026#39;Second commit\u0026#39; 22Upload a new version of the frostyconfig schema: TERMINAL Copy code Copied! $ cue mod publish v0.1.0 ... We incremented the minor version to signify that a backwardly compatible feature has been added. Update the frostyapp module to use the new schema version 23Use the new version of glacial-tech.example/frostyconfig@v0: TERMINAL Copy code Copied! $ cd ../frostyapp TERMINAL Copy code Copied! $ cue mod get glacial-tech.example/frostyconfig@v0.1.0 CUE modules \u0026ldquo;lock in\u0026rdquo; the versions of any dependencies, storing their versions in cue.mod/module.cue file. This gives predictability and dependability but does mean that our frostyapp application will not use the new schema version until it is explicitly updated to do so. flowchart TD frostyapp-- v0.0.1 --\u003e frostytemplate frostyapp-- v0.1.0 --\u003e frostyconfig frostytemplate-- v0.0.1 --\u003e frostyconfig Current dependencies Here, you updated the version in the module.cue file manually, but in the future the cue command will be able to perform this kind of update. 24Check that everything still works and that your configuration is still valid: TERMINAL Copy code Copied! $ cue mod tidy $ cue export --out yaml config: appName: alpha port: 80 debug: false features: logging: true analytics: true So exactly what happened above? Recall that the glacial-tech.example/frostytemplate module remains unchanged: its module still depends on the original v0.0.1 version of the schema. By changing the version at the top level (frostyapp), you caused the new version to be used. In general, we will end up with the the most recent version of all the major versions mentioned in all dependencies. Put another way, there can be several different major versions of a given module, but only one minor version. This is the MVS algorithm used by CUE\u0026rsquo;s dependency resolution. Related content Tutorial: Working with modules and the Central Registry Tutorial: Publishing modules to the Central Registry Reference: CUE Modules",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["rogpeppe"]
    },
    
            {
        "objectID": "1e3f9e5790ba3190044421977f4c94c2_1",
        "title": "Working with incomplete CUE",
        "link": "/docs/concept/working-with-incomplete-cue/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eIn general, CUE can handle references to fields that don\u0026rsquo;t yet exist, or where\na value can\u0026rsquo;t be calculated because there\u0026rsquo;s insufficient information.\nCUE that contains such references or values is referred to as \u003cem\u003eincomplete\u003c/em\u003e CUE\n\u0026ndash; but only if it\u0026rsquo;s otherwise \u003cem\u003evalid\u003c/em\u003e CUE.\u003c/p\u003e",
        "content": "In general, CUE can handle references to fields that don\u0026rsquo;t yet exist, or where a value can\u0026rsquo;t be calculated because there\u0026rsquo;s insufficient information. CUE that contains such references or values is referred to as incomplete CUE \u0026ndash; but only if it\u0026rsquo;s otherwise valid CUE. Here\u0026rsquo;s an example of incomplete CUE. The value of connectionString can\u0026rsquo;t be calculated given the information in database.cue alone because the value of the password field isn\u0026rsquo;t concrete - it\u0026rsquo;s only a string constraint. Copied! database.cue Copy code Copied! package database connectionString: \u0026#34;\\(system)://\\(user):\\(password)@\\(host):\\(port)/\\(database)\u0026#34; system: \u0026#34;postgres\u0026#34; host: \u0026#34;prod.db.example.com\u0026#34; user: \u0026#34;alex\u0026#34; port: \u0026#34;5432\u0026#34; database: \u0026#34;transactions\u0026#34; password: string CUE allows evaluations to be augmented by extra information introduced through Unification. If we introduce information into an evaluation of the database.cue file and provide a concrete string value for the password field then the value of the connectionString field can be calculated. But until that happens, this otherwise valid CUE is referred to as \u0026ldquo;incomplete\u0026rdquo; because it doesn\u0026rsquo;t contain sufficient information to permit a complete evaluation by itself. Note that because incomplete CUE is valid CUE it can be evaluated \u0026hellip; TERMINAL Copy code Copied! $ cue eval database.cue connectionString: \u0026#34;\\(system)://\\(user):\\(password)@\\(host):\\(port)/\\(database)\u0026#34; system: \u0026#34;postgres\u0026#34; host: \u0026#34;prod.db.example.com\u0026#34; user: \u0026#34;alex\u0026#34; port: \u0026#34;5432\u0026#34; database: \u0026#34;transactions\u0026#34; password: string \u0026hellip; but it can\u0026rsquo;t be exported: TERMINAL Copy code Copied! $ cue export database.cue password: incomplete value string: ./database.cue:10:11 connectionString: invalid interpolation: non-concrete value string (type string): ./database.cue:3:19 ./database.cue:10:11 A configuration that results in incomplete values can be made complete by unifying it with the right information. This means that every field that contributes to the emitted configuration must be able to be resolved to a concrete value. Here\u0026rsquo;s some YAML data that will do this for our example and \u0026ldquo;fill in the gaps\u0026rdquo; in our incomplete CUE by providing the password secret: Copied! secrets.yaml Copy code Copied! password: \u0026#34;Ch^ngeMeBef0r3GoL!ve\u0026#34; Unifying our incomplete CUE with this data makes the configuration complete, and allows us to export the result: TERMINAL Copy code Copied! $ cue export database.cue secrets.yaml { \u0026#34;connectionString\u0026#34;: \u0026#34;postgres://alex:Ch^ngeMeBef0r3GoL!ve@prod.db.example.com:5432/transactions\u0026#34;, \u0026#34;system\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;prod.db.example.com\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;alex\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;5432\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;transactions\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Ch^ngeMeBef0r3GoL!ve\u0026#34; } # Export just the data source name as a text value. $ cue export database.cue secrets.yaml -e connectionString \u0026#34;postgres://alex:Ch^ngeMeBef0r3GoL!ve@prod.db.example.com:5432/transactions\u0026#34; Using the Go API The Go API is also able to handle incomplete CUE. To demonstrate the Go API in action we start by initializing a Go module: TERMINAL Copy code Copied! $ go mod init go.example ... We place this example Go code in main.go. Comments explain what is being done at each step. Copied! main.go Copy code Copied! package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;cuelang.org/go/cue\u0026#34; \u0026#34;cuelang.org/go/cue/cuecontext\u0026#34; \u0026#34;cuelang.org/go/cue/load\u0026#34; \u0026#34;cuelang.org/go/encoding/yaml\u0026#34; ) func main() { ctx := cuecontext.New() // Step #1: load the CUE package in the current directory. // It contains a single file - \u0026#34;database.cue\u0026#34;, as shown above. bis := load.Instances([]string{\u0026#34;.\u0026#34;}, nil) step1 := ctx.BuildInstance(bis[0]) fmt.Printf(\u0026#34;step1: %v\\n\u0026#34;, step1) // Step #2: load the \u0026#34;secrets.yaml\u0026#34; file shown above. step2File, err := yaml.Extract(\u0026#34;secrets.yaml\u0026#34;, nil) if err != nil { log.Fatal(err) } step2 := ctx.BuildFile(step2File) fmt.Printf(\u0026#34;step2: %v\\n\u0026#34;, step2) // Ensure that the result of unifying the two steps is both // valid and concrete - and thus could be exported as data: result := step1.Unify(step2) if err := result.Validate(cue.Concrete(true)); err != nil { log.Fatal(err) } // Display the resulting CUE: fmt.Printf(\u0026#34;result: %v\\n\u0026#34;, result) } We fetch the latest version of CUE, and tidy our Go module: TERMINAL Copy code Copied! $ go get cuelang.org/go@v0.13.0 ... $ go mod tidy ... When we run our Go code, it behaves the same as the cue export command above - except that it also displays the interim step1 and step2 values: TERMINAL Copy code Copied! $ go run . step1: { connectionString: \u0026#34;\\(system)://\\(user):\\(password)@\\(host):\\(port)/\\(database)\u0026#34; system: \u0026#34;postgres\u0026#34; host: \u0026#34;prod.db.example.com\u0026#34; user: \u0026#34;alex\u0026#34; port: \u0026#34;5432\u0026#34; database: \u0026#34;transactions\u0026#34; password: string } step2: { password: \u0026#34;Ch^ngeMeBef0r3GoL!ve\u0026#34; } result: { connectionString: \u0026#34;postgres://alex:Ch^ngeMeBef0r3GoL!ve@prod.db.example.com:5432/transactions\u0026#34; system: \u0026#34;postgres\u0026#34; host: \u0026#34;prod.db.example.com\u0026#34; user: \u0026#34;alex\u0026#34; port: \u0026#34;5432\u0026#34; database: \u0026#34;transactions\u0026#34; password: \u0026#34;Ch^ngeMeBef0r3GoL!ve\u0026#34; } Related content Tag: go api \u0026ndash; Guides exploring CUE\u0026rsquo;s Go API",
        "breadcrumb": ["Documentation","Concept Guides"],
        "contentType": "Concept Guides",
        "tags": ["go api"],
        "authors": ["myitcv","jpluscplusm"]
    },
    
            {
        "objectID": "af88c2389d3e1c8e805ca9235fe4a9c1_1",
        "title": "Working with modules and the Central Registry",
        "link": "/docs/tutorial/working-with-the-central-registry/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003ch2 id=\"introduction\"\u003e\n    \u003ca href=\"#introduction\" class=\"anchor\" aria-label=\"Anchor\"\u003e\n\n\n\n\u003csvg class=\"icon anchor__icon\" aria-hidden=\"true\"\u003e\n    \u003cuse xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         xlink:href=\"/img/ui.svg#icon--link\"\u003e\u003c/use\u003e\n\u003c/svg\u003e\n\u003c/a\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial you will learn how to create and work with CUE modules,\nusing the \u003ca href=\"https://registry.cue.works\"\u003eCentral Registry\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlong the way you will:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLogin to the Central Registry, and authenticate the \u003ccode\u003ecue\u003c/code\u003e command\u003c/li\u003e\n\u003cli\u003eCreate a module that depends on an existing, well-known module\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ecue mod tidy\u003c/code\u003e to automatically add dependencies and their versions to the \u003ccode\u003emodule.cue\u003c/code\u003e file\u003c/li\u003e\n\u003c/ul\u003e",
        "content": "Introduction In this tutorial you will learn how to create and work with CUE modules, using the Central Registry. Along the way you will: Login to the Central Registry, and authenticate the cue command Create a module that depends on an existing, well-known module Use cue mod tidy to automatically add dependencies and their versions to the module.cue file Login to the Central Registry 1Visit the Central Registry at https://registry.cue.works and login via GitHub. The Central Registry is in alpha testing - please give us your feedback about the service in the #modules channel on Slack or on Discord! Authenticate the cue command 2Authenticate the cue command (a one-off process): TERMINAL Copy code Copied! $ cue login Create a module 3Initialize a local CUE module. We will not publish this module: TERMINAL Copy code Copied! $ cue mod init glacial-tech.example/frostyapp@v0 We refer to such a module as the main module. Because we won\u0026rsquo;t publish this module, its module path is not significant. The module path we have chosen makes this guide consistent with its companion tutorial Working with a custom module registry. 4Create the code for the new module: Copied! config.cue Copy code Copied! package frostyapp import \u0026#34;github.com/cue-labs/examples/frostyconfig@v0\u0026#34; config: frostyconfig.#Config \u0026amp; { appName: \u0026#34;alpha\u0026#34; port: 80 features: logging: true } This imports the frostyconfig package first introduced in the tutorial Working with a custom module registry. Instead of depending on a version of that module published to a custom registry, we have instead published a version to the Central Registry. In our local module we define some concrete values for the configuration, constrained by the frostyconfig.#Config schema. 5Ensure the module is tidy, pulling all dependencies: TERMINAL Copy code Copied! $ cue mod tidy We can see that the dependencies have now been added to the cue.mod/module.cue file: TERMINAL Copy code Copied! $ cat cue.mod/module.cue module: \u0026#34;glacial-tech.example/frostyapp@v0\u0026#34; language: { version: \u0026#34;v0.13.0\u0026#34; } deps: { \u0026#34;github.com/cue-labs/examples/frostyconfig@v0\u0026#34;: { v: \u0026#34;v0.0.1\u0026#34; } } Evaluate the configuration 6Export the configuration as YAML: TERMINAL Copy code Copied! $ cue export --out yaml config: appName: alpha port: 80 features: logging: true Congratulations! That\u0026rsquo;s it, you have just created a local module that depends on a well-known module from the Central Registry! Related content Tutorial: Publishing modules to the Central Registry Tutorial: Working with a custom module registry Reference: CUE Modules",
        "breadcrumb": ["Documentation","Tutorials"],
        "contentType": "Tutorials",
        "tags": ["modules","tooling","cue command"],
        "authors": ["myitcv"]
    },
    
            {
        "objectID": "e6dd763cecd6d91a6d67e548bf20de9d_1",
        "title": "Writing a type switch",
        "link": "/docs/howto/write-a-type-switch/",
        "publishDate": "0001-01-01T00:00:00Z",
        "summary": "\u003cp\u003eThis \u003ca href=\"/docs/howto/about-commented-cue-guides/\"\u003eCommented CUE\u003c/a\u003e\ndemonstrates how to write a \u003cstrong\u003etype switch\u003c/strong\u003e, where output needs to differ based\non the type of data being processed. Because the CUE language does not include\na switch statement, a mechanism is shown that \u003cem\u003ebehaves\u003c/em\u003e like a switch statement\nin some other languages.\u003c/p\u003e",
        "content": "This Commented CUE demonstrates how to write a type switch, where output needs to differ based on the type of data being processed. Because the CUE language does not include a switch statement, a mechanism is shown that behaves like a switch statement in some other languages. Copied! file.cue Copy code Copied! package example input: [ 42, 139.4, \u0026#34;some string\u0026#34;, [\u0026#34;some\u0026#34;, \u0026#34;list\u0026#34;], {some: \u0026#34;struct\u0026#34;}, true, false, ] // output is derived from input, and adheres to the following schema: output: [...{ source!: _ // the value being examined type!: string // source\u0026#39;s type, in words isANumber!: bool // true iff source is a number }] output: [for v in input { source: v // type\u0026#39;s trailing \u0026#34;[0]\u0026#34; acts like a switch statement, selecting the // first value whose conditional evaluates to true. type: [ if (v \u0026amp; string) != _|_ {\u0026#34;a string\u0026#34;}, if (v \u0026amp; int) != _|_ {\u0026#34;an int\u0026#34;}, if (v \u0026amp; float) != _|_ {\u0026#34;a float\u0026#34;}, if (v \u0026amp; bool) != _|_ {\u0026#34;a boolean\u0026#34;}, if (v \u0026amp; [...]) != _|_ {\u0026#34;a list\u0026#34;}, if (v \u0026amp; {...}) != _|_ {\u0026#34;a struct\u0026#34;}, ][0] // Here, isANumber is implemented as a switch. Other, simpler, // representations are also possible. isANumber: [ if (v \u0026amp; number) != _|_ {true}, if (v \u0026amp; number) == _|_ {false}, ][0] }] TERMINAL Copy code Copied! $ cue eval -s -e output [{ source: 42 type: \u0026#34;an int\u0026#34; isANumber: true }, { source: 139.4 type: \u0026#34;a float\u0026#34; isANumber: true }, { source: \u0026#34;some string\u0026#34; type: \u0026#34;a string\u0026#34; isANumber: false }, { source: [\u0026#34;some\u0026#34;, \u0026#34;list\u0026#34;] type: \u0026#34;a list\u0026#34; isANumber: false }, { source: some: \u0026#34;struct\u0026#34; type: \u0026#34;a struct\u0026#34; isANumber: false }, { source: true type: \u0026#34;a boolean\u0026#34; isANumber: false }, { source: false type: \u0026#34;a boolean\u0026#34; isANumber: false }] The method of testing a value\u0026rsquo;s type shown in this guide is likely to be replaced by tests using more specific and precise builtins when issue #943 is implemented, such as isconcrete. The builtins mentioned in that issue are not yet available, but we mention them here to help guide the implementation choices you make in the interim.",
        "breadcrumb": ["Documentation","How-to Guides"],
        "contentType": "How-to Guides",
        "tags": ["commented cue"],
        "authors": ["jpluscplusm"]
    }
]