<!doctype html>
<html lang="en" dir="ltr" class="no-js">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Note to implementors Notes on the formalism underlying this specification can be found here.Introduction This is a reference manual for the CUE data â€¦">
<meta name="generator" content="Hugo 0.147.5">

<meta name="robots" content="noindex, nofollow">

<link rel="canonical" href="https://cuelang.org/docs/reference/spec/" />
<link rel="shortcut icon" href="/favicons/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="manifest" href="/favicons/webmanifest.json">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#232a68">
<meta name="msapplication-TileColor" content="#232a68">
<meta name="msapplication-config" content="/favicons/browserconfig.xml">
<meta name="theme-color" content="#232a68">

<title>The CUE Language Specification | CUE</title><meta property="og:url" content="//localhost:1313/docs/reference/spec/">
  <meta property="og:site_name" content="CUE">
  <meta property="og:title" content="The CUE Language Specification">
  <meta property="og:description" content="Note to implementors Notes on the formalism underlying this specification can be found here.
Introduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2025-04-16T12:59:45+01:00">
    <meta property="og:image" content="//localhost:1313/img/social.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="//localhost:1313/img/social.png">
  <meta name="twitter:title" content="The CUE Language Specification">
  <meta name="twitter:description" content="Note to implementors Notes on the formalism underlying this specification can be found here.
Introduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.">





<link href="/scss/main.css" rel="stylesheet">



<link rel="preload" href="/fonts/inter/regular.woff2" as="font" crossorigin="anonymous">
<link rel="preload" href="/fonts/inter/500.woff2" as="font" crossorigin="anonymous">
<link rel="preload" href="/fonts/inter/700.woff2" as="font" crossorigin="anonymous">



<script>(()=>{document.documentElement.classList.remove("no-js"),document.documentElement.classList.add("js")})()</script>
</head>
    <body itemscope itemtype="https://schema.org/WebPage">
        <meta itemprop="name" content="The CUE Language Specification">
<meta itemprop="description" content=" Note to implementors Notes on the formalism underlying this specification can be found here.
Introduction This is a reference manual for the CUE data constraint language. CUE, pronounced cue or Q, is a general-purpose and strongly typed constraint-based language. It can be used for data templating, data validation, code generation, scripting, and many other applications involving structured data. The CUE tooling, layered on top of CUE, provides a general purpose scripting language for creating scripts as well as simple servers, also expressed in CUE.
">

    
        <meta itemprop="dateModified" content="2025-04-16T12:59:45+01:00" >
    
            
        <meta itemprop="image" content="//localhost:1313/img/social.png"/>
            
    <meta itemprop="keywords" content="" />

        <a id="skip-nav" class="skip-link" href="#site-main" target="_self">Skip to content</a>

        <div class="site">
            <header id="site-header" class="site__header">
                

<div class="header header--wide" data-header>
    <div class="header__container">
        <div class="header__background"></div>

        <div class="header__branding">
            <a href="/" class="header__logo" rel="home">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><path class="logo__letters" d="M39.555 50.355c-6.853.0-11.907 5.133-11.907 13.602s5.027 13.602 11.907 13.602c5.818.0 10.073-3.648 10.94-8.883l-4.034-.012c-.686 3.389-3.532 5.252-6.88 5.252-4.541.0-7.968-3.533-7.968-9.957s3.414-9.955 7.979-9.955c3.373.0 6.207 1.902 6.865 5.328l.004-.002h4.033c-.906-5.664-5.34-8.975-10.94-8.975zm38.748.362-.002.004h.002zm0 .004v26.478H96.07v-3.44H82.297v-8.105h12.752V62.23H82.297V54.16h13.617v-3.44zm-24.823.0v17.521c0 5.974 4.651 9.4 10.51 9.4 5.86.0 10.528-3.426 10.528-9.4V50.721h-3.995v17.457c0 3.711-2.985 5.793-6.529 5.793s-6.517-2.082-6.517-5.793V50.72z"/><path class="logo__inner" d="M64 9.586C33.947 9.586 9.586 33.947 9.586 64S33.947 118.414 64 118.414 118.414 94.053 118.414 64 94.05 9.586 64 9.586zm0 105.973c-28.476.0-51.562-23.086-51.562-51.562S35.524 12.438 64 12.438 115.562 35.524 115.562 64 92.476 115.562 64 115.562z"/><path class="logo__outer" d="M64 0C28.653.0.0 28.653.0 64s28.653 64 64 64 64-28.653 64-64S99.347.0 64 0zm0 121.843C32.054 121.843 6.157 95.946 6.157 64S32.054 6.157 64 6.157 121.843 32.054 121.843 64 95.946 121.843 64 121.843z"/></svg>
                <span>Homepage of CUE</span>
            </a>
        </div>

        <div class="header__main">
            <nav class="nav nav--main" aria-label="Main menu">
                <ul class="nav__list">
                    
                        <li class="nav__item"><a class="nav__link"
                               href="/docs/"><span class="nav__text">Documentation</span></a>
                        </li>
                    
                        <li class="nav__item"><a class="nav__link"
                               href="/play/"><span class="nav__text">Play</span></a>
                        </li>
                    
                        <li class="nav__item"><a class="nav__link"
                               href="/community/"><span class="nav__text">Community</span></a>
                        </li>
                    
                </ul>
            </nav>
        </div>

        <div class="header__secondary">
            <div class="header__icons">
                <nav class="nav nav--social" aria-label="Social">
                    <ul class="nav__list"><li class="nav__item"><a class="nav__link"
                                   href="https://github.com/cue-lang/cue" target="_blank">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--github"></use>
</svg>

                                    <span class="nav__text">GitHub</span>
                                </a>
                            </li><li class="nav__item"><a class="nav__link"
                                   href="/s/slack">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--slack"></use>
</svg>

                                    <span class="nav__text">Slack</span>
                                </a>
                            </li><li class="nav__item"><a class="nav__link"
                                   href="/s/discord">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-discord"></use>
</svg>

                                    <span class="nav__text">Discord</span>
                                </a>
                            </li><li class="nav__item"><a class="nav__link"
                                   href="https://twitter.com/cue_lang" target="_blank">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-x"></use>
</svg>

                                    <span class="nav__text">X (Twitter)</span>
                                </a>
                            </li><li class="nav__item"><a class="nav__link"
                                   href="https://bsky.app/profile/cuelang.org" target="_blank">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-bluesky"></use>
</svg>

                                    <span class="nav__text">Bluesky</span>
                                </a>
                            </li><li class="nav__item"><a class="nav__link"
                                   href="https://www.youtube.com/@cuelang/videos" target="_blank">
                                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-youtube"></use>
</svg>

                                    <span class="nav__text">YouTube</span>
                                </a>
                            </li></ul>
                </nav>
            </div>

            <div class="header__cta"><a class="button button--skinny"
                       href="/docs/introduction/installation/"><span class="button__text">Install</span>



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--download"></use>
</svg>
</a></div>

            <div class="header__search" data-menu>
                <a href="/search" class="button button--icon button--white-simple" rel="search" data-menu-dropdown="header-dropdown-search">



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--search"></use>
</svg>
<span>Search</span>
                </a>

                <div class="header__dropdown header__dropdown--search" data-menu-dropdown-target="header-dropdown-search">
                    <p class="header__search-title">What are you looking for?</p>





<div data-search-autocomplete="menu"
     data-searchbar-size="small"
     data-searchbar-placeholder=""
>
    <div id="autocomplete-menu"></div>
</div>
</div>
            </div>

            <div class="header__toggle">
                <button class="button button--outline" data-drawer-toggle="menu" aria-haspopup="menu" aria-expanded="false" aria-controls="mobile-menu">
                    <span class="button__text">Menu</span>



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--menu"></use>
</svg>
</button>
            </div>
        </div>
    </div>
</div>

            </header>

            <main id="site-main" class="site__content" itemprop="mainContentOfPage">
                

    <div class="docs" data-docs>
        <div class="docs__main">
            <nav class="breadcrumb" aria-label="breadcrumb">
    <ol class="breadcrumb__list">
    

    
    

    
        <li class="breadcrumb__item"><a class="breadcrumb__link" href="//localhost:1313/docs/reference/">References</a></li>
    
    

    
        <li class="breadcrumb__item" aria-current="page"><h1 class="breadcrumb__text">The CUE Language Specification</h1></li>
    
    </ol>
</nav>


            <article class="article article--docs" itemscope itemtype="https://schema.org/TechArticle">
                <meta itemprop="articleBody" content="




    


    




    

Note to implementors
Notes on the formalism underlying this specification can be found
here.



    




    

Introduction
This is a reference manual for the CUE data constraint language.
CUE, pronounced cue or Q, is a general-purpose and strongly typed
constraint-based language.
It can be used for data templating, data validation, code generation, scripting,
and many other applications involving structured data.
The CUE tooling, layered on top of CUE, provides
a general purpose scripting language for creating scripts as well as
simple servers, also expressed in CUE.
CUE was designed with cloud configuration and related systems in mind,
but is not limited to this domain.
It derives its formalism from relational programming languages.
This formalism allows for managing and reasoning over large amounts of
data in a straightforward manner.
The grammar is compact and regular, allowing for easy analysis by automatic
tools such as integrated development environments.
This document is maintained by mpvl@golang.org.
CUE has a lot of similarities with the Go language. This document draws heavily
from the Go specification as a result.
CUE draws its influence from many languages.
Its main influences were BCL/GCL (internal to Google),
LKB (LinGO), Go, and JSON.
Others are Swift, Typescript, Javascript, Prolog, NCL (internal to Google),
Jsonnet, HCL, Flabbergast, Nix, JSONPath, Haskell, Objective-C, and Python.

    




    

Notation
The syntax is specified using Extended Backus-Naur Form (EBNF):

                Copy code
                
                    Copied!
                
            Production  = production_name &#34;=&#34; [ Expression ] &#34;.&#34; .
Expression  = Alternative { &#34;|&#34; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &#34;â€¦&#34; token ] | Group | Option | Repetition .
Group       = &#34;(&#34; Expression &#34;)&#34; .
Option      = &#34;[&#34; Expression &#34;]&#34; .
Repetition  = &#34;{&#34; Expression &#34;}&#34; .

Productions are expressions constructed from terms and the following operators,
in increasing precedence:

                Copy code
                
                    Copied!
                
            |   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)

Lower-case production names are used to identify lexical tokens. Non-terminals
are in CamelCase. Lexical tokens are enclosed in double quotes &quot;&quot; or back
quotes ``.
The form a â€¦ b represents the set of characters from a through b as
alternatives. The horizontal ellipsis â€¦ is also used elsewhere in the spec to
informally denote various enumerations or code snippets that are not further
specified. The character â€¦ (as opposed to the three characters ...) is not a
token of the CUE language.

    




    

Source code representation
Source code is Unicode text encoded in UTF-8.
Unless otherwise noted, the text is not canonicalized, so a single
accented code point is distinct from the same character constructed from
combining an accent and a letter; those are treated as two code points.
For simplicity, this document will use the unqualified term character to refer
to a Unicode code point in the source text.
Each code point is distinct; for instance, upper and lower case letters are
different characters.
Implementation restriction: For compatibility with other tools, a compiler may
disallow the NUL character (U&#43;0000) in the source text.
Implementation restriction: For compatibility with other tools, a compiler may
ignore a UTF-8-encoded byte order mark (U&#43;FEFF) if it is the first Unicode code
point in the source text. A byte order mark may be disallowed anywhere else in
the source.

    




    

Characters
The following terms are used to denote specific Unicode character classes:

                Copy code
                
                    Copied!
                
            newline        = /* the Unicode code point U&#43;000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as &#34;Letter&#34; */ .
unicode_digit  = /* a Unicode code point classified as &#34;Number, decimal digit&#34; */ .

In The Unicode Standard 8.0, Section 4.5 &ldquo;General Category&rdquo; defines a set of
character categories.
CUE treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo
as Unicode letters, and those in the Number category Nd as Unicode digits.

    




    

Letters and digits
The underscore character _ (U&#43;005F) is considered a letter.

                Copy code
                
                    Copied!
                
            letter        = unicode_letter | &#34;_&#34; | &#34;$&#34; .
decimal_digit = &#34;0&#34; â€¦ &#34;9&#34; .
binary_digit  = &#34;0&#34; â€¦ &#34;1&#34; .
octal_digit   = &#34;0&#34; â€¦ &#34;7&#34; .
hex_digit     = &#34;0&#34; â€¦ &#34;9&#34; | &#34;A&#34; â€¦ &#34;F&#34; | &#34;a&#34; â€¦ &#34;f&#34; .


    




    

Lexical elements

    




    

Comments
Comments serve as program documentation.
CUE supports line comments that start with the character sequence //
and stop at the end of the line.
A comment cannot start inside a string literal or inside a comment.
A comment acts like a newline.

    




    

Tokens
Tokens form the vocabulary of the CUE language. There are four classes:
identifiers, keywords, operators and punctuation, and literals. White space,
formed from spaces (U&#43;0020), horizontal tabs (U&#43;0009), carriage returns
(U&#43;000D), and newlines (U&#43;000A), is ignored except as it separates tokens that
would otherwise combine into a single token. Also, a newline or end of file may
trigger the insertion of a comma. While breaking the input into tokens, the
next token is the longest sequence of characters that form a valid token.

    




    

Commas
The formal grammar uses commas , as terminators in a number of productions.
CUE programs may omit most of these commas using the following rules:
When the input is broken into tokens, a comma is automatically inserted into
the token stream immediately after a line&rsquo;s final token if that token is

an identifier, keyword, or bottom
a number or string literal, including an interpolation
one of the characters ), ], }, or ?
an ellipsis ...

Although commas are automatically inserted, the parser will require
explicit commas between two list elements.

To reflect idiomatic use, examples in this document elide commas using
these rules.

    




    

Identifiers
Identifiers name entities such as fields and aliases.
An identifier is a sequence of one or more letters (which includes _ and $)
and digits, optionally preceded by # or _#.
It may not be _ or $.
The first character in an identifier, or after an # if it contains one,
must be a letter.
Identifiers starting with a # or _ are reserved for definitions and hidden
fields.


                Copy code
                
                    Copied!
                
            identifier  = [ &#34;#&#34; | &#34;_#&#34; ] letter { letter | unicode_digit } .


                Copy code
                
                    Copied!
                
            a
_x9
fieldName
Î±Î²


Some identifiers are predeclared.

    




    

Keywords
CUE has a limited set of keywords.
In addition, CUE reserves all identifiers starting with __ (double underscores)
as keywords.
These are typically targets of pre-declared identifiers.
All keywords may be used as labels (field names).
Unless noted otherwise, they can also be used as identifiers to refer to
the same name.

    




    

Values
The following keywords are values.

                Copy code
                
                    Copied!
                
            null         true         false

These can never be used to refer to a field of the same name.
This restriction is to ensure compatibility with JSON configuration files.

    




    

Preamble
The following keywords are used at the preamble of a CUE file.
After the preamble, they may be used as identifiers to refer to namesake fields.

                Copy code
                
                    Copied!
                
            package      import


    




    

Comprehension clauses
The following keywords are used in comprehensions.

                Copy code
                
                    Copied!
                
            for          in           if           let



    




    

Operators and punctuation
The following character sequences represent operators and punctuation:

                Copy code
                
                    Copied!
                
            &#43;     &amp;&amp;    ==    &lt;     =     (     )
-     ||    !=    &gt;     :     {     }
*     &amp;     =~    &lt;=    ?     [     ]     ,
/     |     !~    &gt;=    !     _|_   ...   .



    




    

Numeric literals
There are several kinds of numeric literals.

                Copy code
                
                    Copied!
                
            int_lit     = decimal_lit | si_lit | octal_lit | binary_lit | hex_lit .
decimal_lit = &#34;0&#34; | ( &#34;1&#34; â€¦ &#34;9&#34; ) { [ &#34;_&#34; ] decimal_digit } .
decimals    = decimal_digit { [ &#34;_&#34; ] decimal_digit } .
si_it       = decimals [ &#34;.&#34; decimals ] multiplier |
              &#34;.&#34; decimals  multiplier .
binary_lit  = &#34;0b&#34; binary_digit { [ &#34;_&#34; ] binary_digit } .
hex_lit     = &#34;0&#34; ( &#34;x&#34; | &#34;X&#34; ) hex_digit { [ &#34;_&#34; ] hex_digit } .
octal_lit   = &#34;0o&#34; octal_digit { [ &#34;_&#34; ] octal_digit } .
multiplier  = ( &#34;K&#34; | &#34;M&#34; | &#34;G&#34; | &#34;T&#34; | &#34;P&#34; ) [ &#34;i&#34; ]

float_lit   = decimals &#34;.&#34; [ decimals ] [ exponent ] |
              decimals exponent |
              &#34;.&#34; decimals [ exponent ].
exponent    = ( &#34;e&#34; | &#34;E&#34; ) [ &#34;&#43;&#34; | &#34;-&#34; ] decimals .

An integer literal is a sequence of digits representing an integer value.
An optional prefix sets a non-decimal base: 0o for octal,
0x or 0X for hexadecimal, and 0b for binary.
In hexadecimal literals, letters a â€¦ f and A â€¦ F represent values 10 through 15.
All integers allow interstitial underscores _;
these have no meaning and are solely for readability.
Integer literals may have an SI or IEC multiplier.
Multipliers can be used with fractional numbers.
When multiplying a fraction by a multiplier, the result is truncated
towards zero if it is not an integer.

                Copy code
                
                    Copied!
                
            42
1.5G    // 1_500_000_000
1.3Ki   // 1.3 * 1024 = trunc(1331.2) = 1331
170_141_183_460_469_231_731_687_303_715_884_105_727
0xBad_Face
0o755
0b0101_0001

A decimal floating-point literal is a representation of
a decimal floating-point value (a float).
It has an integer part, a decimal point, a fractional part, and an
exponent part.
The integer and fractional part comprise decimal digits; the
exponent part is an e or E followed by an optionally signed decimal exponent.
One of the integer part or the fractional part may be elided; one of the decimal
point or the exponent may be elided.

                Copy code
                
                    Copied!
                
            0.
72.40
072.40  // == 72.40
2.71828
1.e&#43;0
6.67428e-11
1E6
.25
.12345E&#43;5


Neither a float_lit nor an si_lit may appear after a token that is:

an identifier, keyword, or bottom
a number or string literal, including an interpolation
one of the characters ), ], }, ?, or ..



    




    

String and byte sequence literals
A string literal represents a string constant obtained from concatenating a
sequence of characters.
Byte sequences are a sequence of bytes.
String and byte sequence literals are character sequences between,
respectively, double and single quotes, as in &quot;bar&quot; and &#39;bar&#39;.
Within the quotes, any character may appear except newline and,
respectively, unescaped double or single quote.
String literals may only be valid UTF-8.
Byte sequences may contain any sequence of bytes.
Several escape sequences allow arbitrary values to be encoded as ASCII text.
An escape sequence starts with an escape delimiter, which is \ by default.
The escape delimiter may be altered to be \ plus a fixed number of
hash symbols # by padding the start and end of a string or byte sequence
literal with this number of hash symbols.

There are four ways to represent the integer value as a numeric constant: \x
followed by exactly two hexadecimal digits; \u followed by exactly four
hexadecimal digits; \U followed by exactly eight hexadecimal digits, and a
plain backslash \ followed by exactly three octal digits.
In each case the value of the literal is the value represented by the
digits in the corresponding base.
Hexadecimal and octal escapes are only allowed within byte sequences
(single quotes).
Although these representations all result in an integer, they have different
valid ranges.
Octal escapes must represent a value between 0 and 255 inclusive.
Hexadecimal escapes satisfy this condition by construction.
The escapes \u and \U represent Unicode code points so within them
some values are illegal, in particular those above 0x10FFFF.
Surrogate halves are allowed,
but are translated into their non-surrogate equivalent internally.
The three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes
represent individual bytes of the resulting string; all other escapes represent
the (possibly multi-byte) UTF-8 encoding of individual characters.
Thus inside a string literal \377 and \xFF represent a single byte of
value 0xFF=255, while Ã¿, \u00FF, \U000000FF and \xc3\xbf represent
the two bytes 0xc3 0xbf of the UTF-8 encoding of character U&#43;00FF.

                Copy code
                
                    Copied!
                
            \a   U&#43;0007 alert or bell
\b   U&#43;0008 backspace
\f   U&#43;000C form feed
\n   U&#43;000A line feed or newline
\r   U&#43;000D carriage return
\t   U&#43;0009 horizontal tab
\v   U&#43;000b vertical tab
\/   U&#43;002f slash (solidus)
\\   U&#43;005c backslash
\&#39;   U&#43;0027 single quote  (valid escape only within single quoted literals)
\&#34;   U&#43;0022 double quote  (valid escape only within double quoted literals)

The escape \( is used as an escape for string interpolation.
A \( must be followed by a valid CUE Expression, followed by a ).
A backslash at the end of a line elides the line terminator that follows it.
This may not escape the final newline inside a multiline string: that
newline is already implicitly elided.
All other sequences starting with a backslash are illegal inside literals.

                Copy code
                
                    Copied!
                
            escaped_char     = `\` { `#` } ( &#34;a&#34; | &#34;b&#34; | &#34;f&#34; | &#34;n&#34; | &#34;r&#34; | &#34;t&#34; | &#34;v&#34; | &#34;/&#34; | `\` | &#34;&#39;&#34; | `&#34;` ) .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` { `#` } octal_digit octal_digit octal_digit .
hex_byte_value   = `\` { `#` } &#34;x&#34; hex_digit hex_digit .
little_u_value   = `\` { `#` } &#34;u&#34; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` { `#` } &#34;U&#34; hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
interpolation    = &#34;\&#34; { `#` } &#34;(&#34; Expression &#34;)&#34; .

string_lit       = simple_string_lit |
                   multiline_string_lit |
                   simple_bytes_lit |
                   multiline_bytes_lit |
                   `#` string_lit `#` .

simple_string_lit    = `&#34;` { unicode_value | interpolation } `&#34;` .
simple_bytes_lit     = `&#39;` { unicode_value | interpolation | byte_value } `&#39;` .
multiline_string_lit = `&#34;&#34;&#34;` newline
                             { unicode_value | interpolation | newline }
                             newline `&#34;&#34;&#34;` .
multiline_bytes_lit  = &#34;&#39;&#39;&#39;&#34; newline
                             { unicode_value | interpolation | byte_value | newline }
                             newline &#34;&#39;&#39;&#39;&#34; .

Carriage return characters (\r) inside string literals are discarded from
the string value.

                Copy code
                
                    Copied!
                
            &#39;a\000\xab&#39;
&#39;\007&#39;
&#39;\377&#39;
&#39;\xa&#39;        // illegal: too few hexadecimal digits
&#34;\n&#34;
&#34;\&#34;&#34;
&#39;Hello, world!\n&#39;
&#34;Hello, \( name )!&#34;
&#34;æ—¥æœ¬èªž&#34;
&#34;\u65e5æœ¬\U00008a9e&#34;
&#39;\xff\u00FF&#39;
&#34;\uD800&#34;             // illegal: surrogate half (TODO: probably should allow)
&#34;\U00110000&#34;         // illegal: invalid Unicode code point

#&#34;This is not an \(interpolation)&#34;#
#&#34;This is an \#(interpolation)&#34;#
#&#34;The sequence &#34;\U0001F604&#34; renders as \#U0001F604.&#34;#

These examples all represent the same string:

                Copy code
                
                    Copied!
                
            &#34;æ—¥æœ¬èªž&#34;                                 // UTF-8 input text
&#39;æ—¥æœ¬èªž&#39;                                 // UTF-8 input text as byte sequence
&#34;\u65e5\u672c\u8a9e&#34;                    // the explicit Unicode code points
&#34;\U000065e5\U0000672c\U00008a9e&#34;        // the explicit Unicode code points
&#39;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&#39;  // the explicit UTF-8 bytes

If the source code represents a character as two code points, such as a
combining form involving an accent and a letter, the result will appear as two
code points if placed in a string literal.
Strings and byte sequences have a multiline equivalent.
Multiline strings are like their single-line equivalent,
but allow newline characters.
Multiline strings and byte sequences respectively start with
a triple double quote (&quot;&quot;&quot;) or triple single quote (&#39;&#39;&#39;),
immediately followed by a newline, which is discarded from the string contents.
The string is closed by a matching triple quote, which must be by itself
on a new line, preceded by optional whitespace.
The newline preceding the closing quote is discarded from the string contents.
The whitespace before a closing triple quote must appear before any non-empty
line after the opening quote and will be removed from each of these
lines in the string literal.
A closing triple quote may not appear in the string.
To include it is suffices to escape one of the quotes.

                Copy code
                
                    Copied!
                
            &#34;&#34;&#34;
    lily:
    out of the water
    out of itself

    bass
    picking \
    bugs
    off the moon
        â€”â€‰Nick Virgilio, Selected Haiku, 1988
    &#34;&#34;&#34;

This represents the same string as:

                Copy code
                
                    Copied!
                
            &#34;lily:\nout of the water\nout of itself\n\n&#34; &#43;
&#34;bass\npicking bugs\noff the moon\n&#34; &#43;
&#34;    â€”â€‰Nick Virgilio, Selected Haiku, 1988&#34;



    




    

Values
In addition to simple values like &quot;hello&quot; and 42.0, CUE has structs.
A struct is a map from labels to values, like {a: 42.0, b: &quot;hello&quot;}.
Structs are CUE&rsquo;s only way of building up complex values;
lists, which we will see later,
are defined in terms of structs.
All possible values are ordered in a lattice,
a partial order where every two elements have a single greatest lower bound.
A value a is an instance of a value b,
denoted a âŠ‘ b, if b == a or b is more general than a,
that is if a orders before b in the partial order
(âŠ‘ is not a CUE operator).
We also say that b subsumes a in this case.
In graphical terms, b is &ldquo;above&rdquo; a in the lattice.

At the top of the lattice is the single ancestor of all values, called
top, denoted _ in CUE.
Every value is an instance of top.
At the bottom of the lattice is the value called bottom, denoted _|_.
A bottom value usually indicates an error.
Bottom is an instance of every value.
An atom is any value whose only instances are itself and bottom.
Examples of atoms are 42.0, &quot;hello&quot;, true, and null.
A value is concrete if it is either an atom, or a struct whose field values
are all concrete, recursively.
CUE&rsquo;s values also include what we normally think of as types, like string and
float.
It does not distinguish between types and values:
only the relationship of values in the lattice is important.
Each CUE &ldquo;type&rdquo; subsumes the concrete values that one would normally think
of as part of that type.
For example, &quot;hello&quot; is an instance of string, and 42.0 is an instance of
float.
In addition to string and float, CUE has null, int, bool, and bytes.
We informally call these CUE&rsquo;s &ldquo;basic types&rdquo;.

                Copy code
                
                    Copied!
                
            false âŠ‘ bool
true  âŠ‘ bool
true  âŠ‘ true
5.0   âŠ‘ float
bool  âŠ‘ _
_|_   âŠ‘ _
_|_   âŠ‘ _|_

_     â‹¢ _|_
_     â‹¢ bool
int   â‹¢ bool
bool  â‹¢ int
false â‹¢ true
true  â‹¢ false
float â‹¢ 5.0
5     â‹¢ 6


    




    

Unification
The unification of values a and b
is defined as the greatest lower bound of a and b. (That is, the
value u such that u âŠ‘ a and u âŠ‘ b,
and for any other value v for which v âŠ‘ a and v âŠ‘ b
it holds that v âŠ‘ u.)
Since CUE values form a lattice, the unification of two CUE values is
always unique.
These all follow from the definition of unification:

The unification of a with itself is always a.
The unification of values a and b where a âŠ‘ b is always a.
The unification of a value with bottom is always bottom.

Unification in CUE is a binary expression, written a &amp; b.
It is commutative, associative, and idempotent.
As a consequence, order of evaluation is irrelevant, a property that is key
to many of the constructs in the CUE language as well as the tooling layered
on top of it.


    




    

Disjunction
The disjunction of values a and b
is defined as the least upper bound of a and b.
(That is, the value d such that a âŠ‘ d and b âŠ‘ d,
and for any other value e for which a âŠ‘ e and b âŠ‘ e,
it holds that d âŠ‘ e.)
This style of disjunctions is sometimes also referred to as sum types.
Since CUE values form a lattice, the disjunction of two CUE values is always unique.
These all follow from the definition of disjunction:

The disjunction of a with itself is always a.
The disjunction of a value a and b where a âŠ‘ b is always b.
The disjunction of a value a with bottom is always a.
The disjunction of two bottom values is bottom.

Disjunction in CUE is a binary expression, written a | b.
It is commutative, associative, and idempotent.
The unification of a disjunction with another value is equal to the disjunction
composed of the unification of this value with all of the original elements
of the disjunction.
In other words, unification distributes over disjunction.

                Copy code
                
                    Copied!
                
            (a_0 | ... |a_n) &amp; b ==&gt; a_0&amp;b | ... | a_n&amp;b.


                Copy code
                
                    Copied!
                
            Expression                Result
({a:1} | {b:2}) &amp; {c:3}   {a:1, c:3} | {b:2, c:3}
(int | string) &amp; &#34;foo&#34;    &#34;foo&#34;
(&#34;a&#34; | &#34;b&#34;) &amp; &#34;c&#34;         _|_

A disjunction is normalized if there is no element
a for which there is an element b such that a âŠ‘ b.


    




    

Default values
Any value v may be associated with a default value d,
where d must be in instance of v (d âŠ‘ v).
Default values are introduced by means of disjunctions.
Any element of a disjunction can be marked as a default
by prefixing it with an asterisk * (a unary expression).
Syntactically consecutive disjunctions are considered to be
part of a single disjunction,
whereby multiple disjuncts can be marked as default.
A marked disjunction is one where any of its terms are marked.
So a | b | *c | d is a single marked disjunction of four terms,
whereas a | (b | *c | d) is an unmarked disjunction of two terms,
one of which is a marked disjunction of three terms.
During unification, if all the marked disjuncts of a marked disjunction are
eliminated, then the remaining unmarked disjuncts are considered as if they
originated from an unmarked disjunction

As explained below, distinguishing the nesting of disjunctions like this
is only relevant when both an outer and nested disjunction are marked.
Intuitively, when an expression needs to be resolved for an operation other
than unification or disjunction,
non-starred elements are dropped in favor of starred ones if the starred ones
do not resolve to bottom.
To define the unification and disjunction operation we use the notation
âŸ¨vâŸ© to denote a CUE value v that is not associated with a default
and the notation âŸ¨v, dâŸ© to denote a value v associated with a default
value d.
The rewrite rules for unifying such values are as follows:

                Copy code
                
                    Copied!
                
            U0: âŸ¨v1âŸ© &amp; âŸ¨v2âŸ©         =&gt; âŸ¨v1&amp;v2âŸ©
U1: âŸ¨v1, d1âŸ© &amp; âŸ¨v2âŸ©     =&gt; âŸ¨v1&amp;v2, d1&amp;v2âŸ©
U2: âŸ¨v1, d1âŸ© &amp; âŸ¨v2, d2âŸ© =&gt; âŸ¨v1&amp;v2, d1&amp;d2âŸ©

The rewrite rules for disjoining terms of unmarked disjunctions are

                Copy code
                
                    Copied!
                
            D0: âŸ¨v1âŸ© | âŸ¨v2âŸ©         =&gt; âŸ¨v1|v2âŸ©
D1: âŸ¨v1, d1âŸ© | âŸ¨v2âŸ©     =&gt; âŸ¨v1|v2, d1âŸ©
D2: âŸ¨v1, d1âŸ© | âŸ¨v2, d2âŸ© =&gt; âŸ¨v1|v2, d1|d2âŸ©

Terms of marked disjunctions are first rewritten according to the following
rules:

                Copy code
                
                    Copied!
                
            M0:  âŸ¨vâŸ©    =&gt; âŸ¨vâŸ©        don&#39;t introduce defaults for unmarked term
M1: *âŸ¨vâŸ©    =&gt; âŸ¨v, vâŸ©     introduce identical default for marked term
M2: *âŸ¨v, dâŸ© =&gt; âŸ¨v, dâŸ©     keep existing defaults for marked term
M3:  âŸ¨v, dâŸ© =&gt; âŸ¨vâŸ©        strip existing defaults from unmarked term

Note that for any marked disjunction a,
the expressions a|a, *a|a and *a|*a all resolve to a.

                Copy code
                
                    Copied!
                
            Expression               Value-default pair     Rules applied
*&#34;tcp&#34; | &#34;udp&#34;           âŸ¨&#34;tcp&#34;|&#34;udp&#34;, &#34;tcp&#34;âŸ©    M1, D1
string | *&#34;foo&#34;          âŸ¨string, &#34;foo&#34;âŸ©         M1, D1

*1 | 2 | 3               âŸ¨1|2|3, 1âŸ©              M1, D1

(*1|2|3) | (1|*2|3)      âŸ¨1|2|3, 1|2âŸ©            M1, D1, D2
(*1|2|3) | *(1|*2|3)     âŸ¨1|2|3, 2âŸ©              M1, M2, M3, D1, D2
(*1|2|3) | (1|*2|3)&amp;2    âŸ¨1|2|3, 1|2âŸ©            M1, D1, U1, D2

(*1|2) &amp; (1|*2)          âŸ¨1|2, _|_âŸ©              M1, D1, U2


The rules of subsumption for defaults can be derived from the above definitions
and are as follows.

                Copy code
                
                    Copied!
                
            âŸ¨v2, d2âŸ© âŠ‘ âŸ¨v1, d1âŸ©  if v2 âŠ‘ v1 and d2 âŠ‘ d1
âŸ¨v1, d1âŸ© âŠ‘ âŸ¨vâŸ©       if v1 âŠ‘ v
âŸ¨vâŸ©      âŠ‘ âŸ¨v1, d1âŸ©  if v âŠ‘ d1




                Copy code
                
                    Copied!
                
            Expression                       Resolves to
&#34;tcp&#34; | &#34;udp&#34;                    &#34;tcp&#34; | &#34;udp&#34;
*&#34;tcp&#34; | &#34;udp&#34;                   &#34;tcp&#34;
float | *1                       1
*string | 1.0                    string
(*1|2) &#43; (2|*3)                  4

(*1|2|3) | (1|*2|3)              1|2
(*1|2|3) &amp; (1|*2|3)              1|2|3 // default is _|_

(* &gt;=5 | int) &amp; (* &lt;=5 | int)    5

(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (&#34;udp&#34;|*&#34;tcp&#34;)  &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (&#34;udp&#34;|&#34;tcp&#34;)   &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; &#34;tcp&#34;           &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (*&#34;udp&#34;|&#34;tcp&#34;)  &#34;tcp&#34; | &#34;udp&#34; // default is _|_

(*true | false) &amp; bool           true
(*true | false) &amp; (true | false) true

{a: 1} | {b: 1}                  {a: 1} | {b: 1}
{a: 1} | *{b: 1}                 {b:1}
*{a: 1} | *{b: 1}                {a: 1} | {b: 1}
({a: 1} | {b: 1}) &amp; {a:1}        {a:1}  | {a: 1, b: 1}
({a:1}|*{b:1}) &amp; ({a:1}|*{b:1})  {b:1}


    




    

Bottom and errors
Any evaluation error in CUE results in a bottom value, represented by
the token _|_.
Bottom is an instance of every other value.
Any evaluation error is represented as bottom.
Implementations may associate error strings with different instances of bottom;
logically they all remain the same value.

                Copy code
                
                    Copied!
                
            bottom_lit = &#34;_|_&#34; .


    




    

Top
Top is represented by the underscore character _, lexically an identifier.
Unifying any value v with top results in v itself.

                Copy code
                
                    Copied!
                
            Expr        Result
_ &amp;  5        5
_ &amp;  _        _
_ &amp; _|_      _|_
_ | _|_       _


    




    

Null
The null value is represented with the keyword null.
It has only one parent, top, and one child, bottom.
It is unordered with respect to any other value.

                Copy code
                
                    Copied!
                
            null_lit   = &#34;null&#34; .


                Copy code
                
                    Copied!
                
            null &amp; 8     _|_
null &amp; _     null
null &amp; _|_   _|_


    




    

Boolean values
A boolean type represents the set of Boolean truth values denoted by
the keywords true and false.
The predeclared boolean type is bool; it is a defined type and a separate
element in the lattice.

                Copy code
                
                    Copied!
                
            bool_lit = &#34;true&#34; | &#34;false&#34; .


                Copy code
                
                    Copied!
                
            bool &amp; true          true
true &amp; true          true
true &amp; false         _|_
bool &amp; (false|true)  false | true
bool &amp; (true|false)  true | false


    




    

Numeric values
The integer type represents the set of all integral numbers.
The decimal floating-point type represents the set of all decimal floating-point
numbers.
They are two distinct types.
Both are instances instances of a generic number type.

The predeclared number, integer, and decimal floating-point types are
number, int and float; they are defined types.

A decimal floating-point literal always has type float;
it is not an instance of int even if it is an integral number.
Integer literals are always of type int and don&rsquo;t match type float.
Numeric literals are exact values of arbitrary precision.
If the operation permits it, numbers should be kept in arbitrary precision.
Implementation restriction: although numeric values have arbitrary precision
in the language, implementations may implement them using an internal
representation with limited precision.
That said, every implementation must:

Represent integer values with at least 256 bits.
Represent floating-point values with a mantissa of at least 256 bits and
a signed binary exponent of at least 16 bits.
Give an error if unable to represent an integer value precisely.
Give an error if unable to represent a floating-point value due to overflow.
Round to the nearest representable value if unable to represent
a floating-point value due to limits on precision.
These requirements apply to the result of any expression except for builtin
functions, for which an unusual loss of precision must be explicitly documented.


    




    

Strings
The string type represents the set of UTF-8 strings,
not allowing surrogates.
The predeclared string type is string; it is a defined type.
The length of a string s (its size in bytes) can be discovered using
the builtin function len.

    




    

Bytes
The bytes type represents the set of byte sequences.
A byte sequence value is a (possibly empty) sequence of bytes.
The number of bytes is called the length of the byte sequence
and is never negative.
The predeclared byte sequence type is bytes; it is a defined type.

    




    

Bounds
A bound, syntactically a unary expression, defines
a logically infinite disjunction of concrete values represented as a single comparison.
For example, &gt;= 2 represents the infinite disjunction 2|3|4|5|6|7|â€¦.
For any comparison operator op except ==,
op a is the disjunction of every x such that x op a.

                Copy code
                
                    Copied!
                
            2 &amp; &gt;=2 &amp; &lt;=5           // 2, where 2 is either an int or float.
2.5 &amp; &gt;=1 &amp; &lt;=5         // 2.5
2 &amp; &gt;=1.0 &amp; &lt;3.0        // 2.0
2 &amp; &gt;1 &amp; &lt;3.0           // 2.0
2.5 &amp; int &amp; &gt;1 &amp; &lt;5     // _|_
2.5 &amp; float &amp; &gt;1 &amp; &lt;5   // 2.5
int &amp; 2 &amp; &gt;1.0 &amp; &lt;3.0   // _|_
2.5 &amp; &gt;=(int &amp; 1) &amp; &lt;5  // _|_
&gt;=0 &amp; &lt;=7 &amp; &gt;=3 &amp; &lt;=10  // &gt;=3 &amp; &lt;=7
!=null &amp; 1              // 1
&gt;=5 &amp; &lt;=5               // 5


    




    

Structs
A struct is a set of elements called fields, each of
which has a name, called a label, and value.
We say a label is defined for a struct if the struct has a field with the
corresponding label.
The value for a label f of struct a is denoted a.f.
A struct a is an instance of b, or a âŠ‘ b, if for any label f
defined for b, label f is also defined for a and a.f âŠ‘ b.f.
Note that if a is an instance of b it may have fields with labels that
are not defined for b.
The (unique) struct with no fields, written {}, has every struct as an
instance. It can be considered the type of all structs.

                Copy code
                
                    Copied!
                
            {a: 1} âŠ‘ {}
{a: 1, b: 1} âŠ‘ {a: 1}
{a: 1} âŠ‘ {a: int}
{a: 1, b: 1.0} âŠ‘ {a: int, b: number}

{} â‹¢ {a: 1}
{a: 2} â‹¢ {a: 1}
{a: 1} â‹¢ {b: 1}

The successful unification of structs a and b is a new struct c which
has all fields of both a and b, where
the value of a field f in c is a.f &amp; b.f if f is defined in both a and b,
or just a.f or b.f if f is in just a or b, respectively.
Any references to a or b
in their respective field values need to be replaced with references to c.
The result of a unification is bottom (_|_) if any of its defined
fields evaluates to bottom, recursively.
A struct literal may contain multiple fields with the same label,
the result of which is the unification of all those fields.

                Copy code
                
                    Copied!
                
            StructLit       = &#34;{&#34; { Declaration &#34;,&#34; } &#34;}&#34; .
Declaration     = Field | Ellipsis | Embedding | LetClause | attribute .
Ellipsis        = &#34;...&#34; [ Expression ] .
Embedding       = Comprehension | AliasExpr .
Field           = Label &#34;:&#34; { Label &#34;:&#34; } AliasExpr { attribute } .
Label           = [ identifier &#34;=&#34; ] LabelExpr .
LabelExpr       = LabelName [ &#34;?&#34; | &#34;!&#34; ] | &#34;[&#34; AliasExpr &#34;]&#34; .
LabelName       = identifier | simple_string_lit | &#34;(&#34; AliasExpr &#34;)&#34; .

attribute       = &#34;@&#34; identifier &#34;(&#34; attr_tokens &#34;)&#34; .
attr_tokens     = { attr_token |
                    &#34;(&#34; attr_tokens &#34;)&#34; |
                    &#34;[&#34; attr_tokens &#34;]&#34; |
                    &#34;{&#34; attr_tokens &#34;}&#34; } .
attr_token      = /* any token except &#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, or &#39;}&#39; */


                Copy code
                
                    Copied!
                
            Expression                             Result
{a: int, a: 1}                         {a: 1}
{a: int} &amp; {a: 1}                      {a: 1}
{a: &gt;=1 &amp; &lt;=7} &amp; {a: &gt;=5 &amp; &lt;=9}        {a: &gt;=5 &amp; &lt;=7}
{a: &gt;=1 &amp; &lt;=7, a: &gt;=5 &amp; &lt;=9}           {a: &gt;=5 &amp; &lt;=7}

{a: 1} &amp; {b: 2}                        {a: 1, b: 2}
{a: 1, b: int} &amp; {b: 2}                {a: 1, b: 2}

{a: 1} &amp; {a: 2}                        _|_


    




    

Field constraints
A struct may declare field constraints which define values
that should be unified with a given field once it is defined.
The existence of a field constraint declares, but does not define, that field.
Syntactically, a field is marked as a constraint
by following its label with an optional marker ?
or required marker !.
These markers are not part of the field name.
A struct that has a required field constraint with a bottom value
evaluates to bottom.
An optional field constraint with a bottom value does not invalidate
the struct that contains it
as long as it is not unified with a defined field.
The subsumption relation for fields with the various markers is defined as

                Copy code
                
                    Copied!
                
            {a: x} âŠ‘ {a!: x} âŠ‘ {a?: x}

for any given x.
Implementations may error upon encountering a required field constraint
when manifesting CUE as data.

                Copy code
                
                    Copied!
                
            Expression                             Result
{foo?: 3} &amp; {foo: 3}                   {foo: 3}
{foo!: 3} &amp; {foo: 3}                   {foo: 3}

{foo!: int} &amp; {foo: int}               {foo:  int}
{foo!: int} &amp; {foo?: &lt;1}               {foo!: &lt;1}
{foo!: int} &amp; {foo: &lt;=3}               {foo:  &lt;=3}
{foo!: int} &amp; {foo: 3}                 {foo:  3}

{foo!: 3} &amp; {foo: int}                 {foo: 3}
{foo!: 3} &amp; {foo: &lt;=4}                 {foo: 3}

{foo?: 1} &amp; {foo?: 2}                  {foo?: _|_} // No error
{foo?: 1} &amp; {foo!: 2}                  _|_
{foo?: 1} &amp; {foo: 2}                   _|_




    




    

Dynamic fields
A dynamic field is a field whose label is determined by
an expression wrapped in parentheses.
A dynamic field may be marked as optional or required.

                Copy code
                
                    Copied!
                
            Expression                             Result
a:   &#34;foo&#34;                             a:   &#34;foo&#34;
b:   &#34;bar&#34;                             b:   &#34;bar&#34;
(a): &#34;baz&#34;                             foo: &#34;baz&#34;

(a&#43;b): &#34;qux&#34;                           foobar: &#34;qux&#34;

(a)?: string                           foo?: string
(b)!: string                           bar!: string


    




    

Pattern and default constraints
A struct may define constraints that apply to a collection of fields.
A pattern constraint, denoted [pattern]: value, defines a pattern, which
is a value of type string, and a value to unify with fields whose label
unifies with the pattern.
For a given struct a with pattern constraint [p]: v, v is unified
with any field with name f in a for which p &amp; f is not bottom.
When unifying struct a and b,
any pattern constraint declared in a and b
are also declared in the result of unification.

Additionally, a default constraint, denoted ...value, defines a value
to unify with any field for which there is no other declaration in a struct.
When unifying structs a and b,
a default constraint ...v declared in a
defines that the value v should unify with any field in the resulting struct c
whose label does not unify with any of the patterns of the pattern
constraints defined for a and for which there exists no field declaration
in a with that label.
The token ... is a shorthand for ..._.
Note: default constraints of the form ..._ are not yet implemented.

                Copy code
                
                    Copied!
                
            a: {
    foo:      string  // foo is a string
    [=~&#34;^i&#34;]: int     // all other fields starting with i are integers
    [=~&#34;^b&#34;]: bool    // all other fields starting with b are booleans
    [&gt;&#34;c&#34;]:   string  // all other fields lexically after c are strings

    ...string         // all other fields must be a string. Note: default constraints are not yet implemented.
}

b: a &amp; {
    i3:    3
    bar:   true
    other: &#34;a string&#34;
}


Concrete field labels may be an identifier or string, the latter of which may be
interpolated.
Fields with identifier labels can be referred to within the scope they are
defined, string labels cannot.
References within such interpolated strings are resolved within
the scope of the struct in which the label sequence is
defined and can reference concrete labels lexically preceding
the label within a label sequence.






                Copy code
                
                    Copied!
                
            intMap: [string]: int
intMap: {
    t1: 43
    t2: 2.4  // error: 2.4 is not an integer
}

nameMap: [string]: {
    firstName: string
    nickName:  *firstName | string
}

nameMap: hank: firstName: &#34;Hank&#34;

The optional field set defined by nameMap matches every field,
in this case just hank, and unifies the associated constraint
with the matched field, resulting in:

                Copy code
                
                    Copied!
                
            nameMap: hank: {
    firstName: &#34;Hank&#34;
    nickName:  &#34;Hank&#34;
}


    




    

Closed structs
By default, structs are open to adding fields.
Instances of an open struct p may contain fields not defined in p.
This is makes it easy to add fields, but can lead to bugs:

                Copy code
                
                    Copied!
                
            S: {
    field1: string
}

S1: S &amp; { field2: &#34;foo&#34; }

// S1 is { field1: string, field2: &#34;foo&#34; }


A: {
    field1: string
    field2: string
}

A1: A &amp; {
    feild1: &#34;foo&#34;  // &#34;field1&#34; was accidentally misspelled
}

// A1 is
//    { field1: string, field2: string, feild1: &#34;foo&#34; }
// not the intended
//    { field1: &#34;foo&#34;, field2: string }

A closed struct c is a struct whose instances may not declare any field
with a name that does not match the name of a field
or the pattern of a pattern constraint defined in c.
Hidden fields are excluded from this limitation.
A struct that is the result of unifying any struct with a ...
declaration is defined for all regular fields.
Closing a struct is equivalent to adding ..._|_ to it.
Syntactically, structs are closed explicitly with the close builtin or
implicitly and recursively by definitions.

                Copy code
                
                    Copied!
                
            A: close({
    field1: string
    field2: string
})

A1: A &amp; {
    feild1: string
} // _|_ feild1 not defined for A

A2: A &amp; {
    for k,v in { feild1: string } {
        k: v
    }
}  // _|_ feild1 not defined for A

C: close({
    [_]: _
})

C2: C &amp; {
    for k,v in { thisIsFine: string } {
        &#34;\(k)&#34;: v
    }
}

D: close({
    // Values generated by comprehensions are treated as embeddings.
    for k,v in { x: string } {
        &#34;\(k)&#34;: v
    }
})




    




    

Embedding
A struct may contain an embedded value, an operand used as a declaration.
An embedded value of type struct is unified with the struct in which it is
embedded, but disregarding the restrictions imposed by closed structs.
So if an embedding resolves to a closed struct, the corresponding enclosing
struct will also be closed, but may have fields that are not allowed if
normal rules for closed structs were observed.
If an embedded value is not of type struct, the struct may only have
definitions or hidden fields. Regular fields are not allowed in such case.
The result of { A } is A for any A (including definitions).
Syntactically, embeddings may be any expression.

                Copy code
                
                    Copied!
                
            S1: {
    a: 1
    b: 2
    {
        c: 3
    }
}
// S1 is { a: 1, b: 2, c: 3 }

S2: close({
    a: 1
    b: 2
    {
        c: 3
    }
})
// same as close(S1)

S3: {
    a: 1
    b: 2
    close({
        c: 3
    })
}
// same as S2


    




    

Definitions and hidden fields
A field is a definition if its identifier starts with # or _#.
A field is hidden if its identifier starts with a _.
All other fields are regular.
Definitions and hidden fields are not emitted when converting a CUE program
to data and are never required to be concrete.
Referencing a definition will recursively close it.
That is, a referenced definition will not unify with a struct
that would add a field anywhere within the definition that it does not
already define or explicitly allow with a pattern constraint or ....
Embedding allows bypassing this check.
If referencing a definition would always result in an error, implementations
may report this inconsistency at the point of its declaration.

                Copy code
                
                    Copied!
                
            #MyStruct: {
    sub: field:    string
}

#MyStruct: {
    sub: enabled?: bool
}

myValue: #MyStruct &amp; {
    sub: feild:   2     // error, feild not defined in #MyStruct
    sub: enabled: true  // okay
}

#D: {
    #OneOf

    c: int // adds this field.
}

#OneOf: { a: int } | { b: int }


D1: #D &amp; { a: 12, c: 22 }  // { a: 12, c: 22 }
D2: #D &amp; { a: 12, b: 33 }  // _|_ // cannot define both `a` and `b`


                Copy code
                
                    Copied!
                
            #A: {a: int}

B: {
    #A
    b: c: int
}

x: B
x: d: 3  // not allowed, as closed by embedded #A

y: B.b
y: d: 3  // allowed as nothing closes b

#B: {
    #A
    b: c: int
}

z: #B.b
z: d: 3  // not allowed, as referencing #B closes b



    




    

Attributes
Attributes allow associating meta information with values.
Their primary purpose is to define mappings between CUE and
other representations.
Attributes do not influence the evaluation of CUE.
An attribute associates an identifier with a value, a balanced token sequence,
which is a sequence of CUE tokens with balanced brackets ((), [], and {}).
The sequence may not contain interpolations.
Fields, structs and packages can be associated with a set of attributes.
Attributes accumulate during unification, but implementations may remove
duplicates that have the same source string representation.
The interpretation of an attribute, including the handling of multiple
attributes for a given identifier, is up to the consumer of the attribute.
Field attributes define additional information about a field,
such as a mapping to a protocol buffer  tag or alternative
name of the field when mapping to a different language.

                Copy code
                
                    Copied!
                
            // Package attribute
@protobuf(proto3)

myStruct1: {
    // Struct attribute:
    @jsonschema(id=&#34;https://example.org/mystruct1.json&#34;)

    // Field attributes
    field: string @go(Field)
    attr:  int    @xml(,attr) @go(Attr)
}

myStruct2: {
    field: string @go(Field)
    attr:  int    @xml(a1,attr) @go(Attr)
}

Combined: myStruct1 &amp; myStruct2
// field: string @go(Field)
// attr:  int    @xml(,attr) @xml(a1,attr) @go(Attr)


    




    

Aliases
Aliases name values that can be referred to
within the scope in which they are declared.
The name of an alias must be unique within its scope.

                Copy code
                
                    Copied!
                
            AliasExpr  = [ identifier &#34;=&#34; ] Expression .

Aliases can appear in several positions:

In front of a Label (X=label: value):

binds the identifier to the same value as label would be bound
to if it were a valid identifier.

In front of a dynamic field (X=(label): value):

binds the identifier to the same value as label if it were a valid
static identifier.

In front of a dynamic field expression ((X=expr): value):

binds the identifier to the concrete label resulting from evaluating expr.

In front of a pattern constraint (X=[expr]: value):

binds the identifier to the same field as the matched by the pattern
within the instance of the field value (value).

In front of a pattern constraint expression ([X=expr]: value):

binds the identifier to the concrete label that matches expr
within the instances of the field value (value).

Before a value (foo: X=x)

binds the identifier to the value it precedes within the scope of that value.

Before a list element ([ X=value, X&#43;1 ]) (Not yet implemented)

binds the identifier to the list element it precedes within the scope of the
list expression.



                Copy code
                
                    Copied!
                
            // A field alias
foo: X  // 4
X=&#34;not an identifier&#34;: 4

// A value alias
foo: X={x: X.a}
bar: foo &amp; {a: 1}  // {a: 1, x: 1}

// A label alias
[Y=string]: { name: Y }
foo: { value: 1 } // outputs: foo: { name: &#34;foo&#34;, value: 1 }



    




    

Let declarations
Let declarations bind an identifier to an expression.
The identifier is only visible within the scope
in which it is declared.
The identifier must be unique within its scope.

                Copy code
                
                    Copied!
                
            let x = expr

a: x &#43; 1
b: x &#43; 2


    




    

Shorthand notation for nested structs
A field whose value is a struct with a single field may be written as
a colon-separated sequence of the two field names,
followed by a colon and the value of that single field.

                Copy code
                
                    Copied!
                
            job: myTask: replicas: 2

expands to

                Copy code
                
                    Copied!
                
            job: {
    myTask: {
        replicas: 2
    }
}



    




    

Lists
A list literal defines a new value of type list.
A list may be open or closed.
An open list is indicated with a ... at the end of an element list,
optionally followed by a value for the remaining elements.
The length of a closed list is the number of elements it contains.
The length of an open list is the number of elements as a lower bound
and an unlimited number of elements as its upper bound.

                Copy code
                
                    Copied!
                
            ListLit       = &#34;[&#34; [ ElementList [ &#34;,&#34; ] ] &#34;]&#34; .
ElementList   = Ellipsis | Embedding { &#34;,&#34; Embedding } [ &#34;,&#34; Ellipsis ] .

Lists can be thought of as structs:

                Copy code
                
                    Copied!
                
            List: *null | {
    Elem: _
    Tail: List
}

For closed lists, Tail is null for the last element, for open lists it is
*null | List, defaulting to the shortest variant.
For instance, the open list [ 1, 2, &hellip; ] can be represented as:

                Copy code
                
                    Copied!
                
            open: List &amp; { Elem: 1, Tail: { Elem: 2 } }

and the closed version of this list, [ 1, 2 ], as

                Copy code
                
                    Copied!
                
            closed: List &amp; { Elem: 1, Tail: { Elem: 2, Tail: null } }

Using this representation, the subsumption rule for lists can
be derived from those of structs.
Implementations are not required to implement lists as structs.
The Elem and Tail fields are not special and len will not work as
expected in these cases.

    




    

Declarations and Scopes

    




    

Blocks
A block is a possibly empty sequence of declarations.
The braces of a struct literal { ... } form a block, but there are
others as well:

The universe block encompasses all CUE source text.
Each package has a package block
containing all CUE source text in that package.
Each file has a file block containing all CUE source text in that file.
Each for and let clause in a comprehension
is considered to be its own implicit block.

Blocks nest and influence scoping.

    




    

Declarations and scope
A declaration  may bind an identifier to a field, alias, or package.
Every identifier in a program must be declared.
Other than for fields,
no identifier may be declared twice within the same block.
For fields, an identifier may be declared more than once within the same block,
resulting in a field with a value that is the result of unifying the values
of all fields with the same identifier.
String labels do not bind an identifier to the respective field.
The scope of a declared identifier is the extent of source text in which the
identifier denotes the specified field, alias, or package.
CUE is lexically scoped using blocks:

The scope of a predeclared identifier is the universe block.
The scope of an identifier denoting a field
declared at top level (outside any struct literal) is the package block.
The scope of an identifier denoting an alias
declared at top level (outside any struct literal) is the file block.
The scope of a let identifier
declared at top level (outside any struct literal) is the file block.
The scope of the package name of an imported package is the file block of the
file containing the import declaration.
The scope of a field, alias or let identifier declared inside a struct
literal is the innermost containing block.

An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes the entity
declared by the inner declaration.
The package clause is not a declaration;
the package name does not appear in any scope.
Its purpose is to identify the files belonging to the same package
and to specify the default name for import declarations.

    




    

Predeclared identifiers
CUE predefines a set of types and builtin functions.
For each of these there is a corresponding keyword which is the name
of the predefined identifier, prefixed with __.

                Copy code
                
                    Copied!
                
            Functions
len close and or

Types
null      The null type and value
bool      All boolean values
int       All integral numbers
float     All decimal floating-point numbers
string    Any valid UTF-8 sequence
bytes     Any valid byte sequence

Derived   Value
number    int | float
uint      &gt;=0
uint8     &gt;=0 &amp; &lt;=255
int8      &gt;=-128 &amp; &lt;=127
uint16    &gt;=0 &amp; &lt;=65535
int16     &gt;=-32_768 &amp; &lt;=32_767
rune      &gt;=0 &amp; &lt;=0x10FFFF
uint32    &gt;=0 &amp; &lt;=4_294_967_295
int32     &gt;=-2_147_483_648 &amp; &lt;=2_147_483_647
uint64    &gt;=0 &amp; &lt;=18_446_744_073_709_551_615
int64     &gt;=-9_223_372_036_854_775_808 &amp; &lt;=9_223_372_036_854_775_807
uint128   &gt;=0 &amp; &lt;=340_282_366_920_938_463_463_374_607_431_768_211_455
int128    &gt;=-170_141_183_460_469_231_731_687_303_715_884_105_728 &amp;
           &lt;=170_141_183_460_469_231_731_687_303_715_884_105_727
float32   &gt;=-3.40282346638528859811704183484516925440e&#43;38 &amp;
          &lt;=3.40282346638528859811704183484516925440e&#43;38
float64   &gt;=-1.797693134862315708145274237317043567981e&#43;308 &amp;
          &lt;=1.797693134862315708145274237317043567981e&#43;308


    




    

Exported identifiers

An identifier of a package may be exported to permit access to it
from another package.
All identifiers not starting with _ (so all regular fields and definitions
starting with #) are exported.
Any identifier starting with _ is not visible outside the package and resides
in a separate namespace than namesake identifiers of other packages.

                Copy code
                
                    Copied!
                
            package mypackage

foo:   string  // visible outside mypackage
&#34;bar&#34;: string  // visible outside mypackage

#Foo: {      // visible outside mypackage
    a:  1    // visible outside mypackage
    _b: 2    // not visible outside mypackage

    #C: {    // visible outside mypackage
        d: 4 // visible outside mypackage
    }
    _#E: foo // not visible outside mypackage
}


    




    

Uniqueness of identifiers
Given a set of identifiers, an identifier is called unique if it is different
from every other in the set, after applying normalization following
Unicode Annex #31.
Two identifiers are different if they are spelled differently
or if they appear in different packages and are not exported.
Otherwise, they are the same.

    




    

Field declarations
A field associates the value of an expression to a label within a struct.
If this label is an identifier, it binds the field to that identifier,
so the field&rsquo;s value can be referenced by writing the identifier.
String labels are not bound to fields.

                Copy code
                
                    Copied!
                
            a: {
    b: 2
    &#34;s&#34;: 3

    c: b   // 2
    d: s   // _|_ unresolved identifier &#34;s&#34;
    e: a.s // 3
}

If an expression may result in a value associated with a default value
as described in default values, the field binds to this
value-default pair.


    




    

Let declarations

Within a struct, a let clause binds an identifier to the given expression.
Within the scope of the identifier, the identifier refers to the
locally declared expression.
The expression is evaluated in the scope it was declared.

    




    

Expressions
An expression specifies the computation of a value by applying operators and
builtin functions to operands.
Expressions that require concrete values are called incomplete if any of
their operands are not concrete, but define a value that would be legal for
that expression.
Incomplete expressions may be left unevaluated until a concrete value is
requested at the application level.

    




    

Operands
Operands denote the elementary values in an expression.
An operand may be a literal, a (possibly qualified) identifier denoting
a field, alias, or let declaration, or a parenthesized expression.

                Copy code
                
                    Copied!
                
            Operand     = Literal | OperandName | &#34;(&#34; Expression &#34;)&#34; .
Literal     = BasicLit | ListLit | StructLit .
BasicLit    = int_lit | float_lit | string_lit |
              null_lit | bool_lit | bottom_lit .
OperandName = identifier | QualifiedIdent .


    




    

Qualified identifiers
A qualified identifier is an identifier qualified with a package name prefix.

                Copy code
                
                    Copied!
                
            QualifiedIdent = PackageName &#34;.&#34; identifier .

A qualified identifier accesses an identifier in a different package,
which must be imported.
The identifier must be declared in the package block of that package.

                Copy code
                
                    Copied!
                
            math.Sin    // denotes the Sin function in package math


    




    

References
An identifier operand refers to a field and is called a reference.
The value of a reference is a copy of the expression associated with the field
that it is bound to,
with any references within that expression bound to the respective copies of
the fields they were originally bound to.
Implementations may use a different mechanism to evaluate as long as
these semantics are maintained.

                Copy code
                
                    Copied!
                
            a: {
    place:    string
    greeting: &#34;Hello, \(place)!&#34;
}

b: a &amp; { place: &#34;world&#34; }
c: a &amp; { place: &#34;you&#34; }

d: b.greeting  // &#34;Hello, world!&#34;
e: c.greeting  // &#34;Hello, you!&#34;


    




    

Primary expressions
Primary expressions are the operands for unary and binary expressions.

                Copy code
                
                    Copied!
                
            PrimaryExpr =
	Operand |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Arguments .

Selector       = &#34;.&#34; (identifier | simple_string_lit) .
Index          = &#34;[&#34; Expression &#34;]&#34; .
Argument       = Expression .
Arguments      = &#34;(&#34; [ ( Argument { &#34;,&#34; Argument } ) [ &#34;,&#34; ] ] &#34;)&#34; .



                Copy code
                
                    Copied!
                
            x
2
(s &#43; &#34;.txt&#34;)
f(3.1415, true)
m[&#34;foo&#34;]
obj.color
f.p[i].x


    




    

Selectors
For a primary expression x that is not a package name,
the selector expression

                Copy code
                
                    Copied!
                
            x.f

denotes the element of a struct x identified by f.

f must be an identifier or a string literal identifying
any definition or regular non-optional field.
The identifier f is called the field selector.


If x is a package name, see the section on qualified identifiers.

Otherwise, if x is not a struct,
or if f does not exist in x,
the result of the expression is bottom (an error).
In the latter case the expression is incomplete.
The operand of a selector may be associated with a default.

                Copy code
                
                    Copied!
                
            T: {
    x:     int
    y:     3
    &#34;x-y&#34;: 4
}

a: T.x     // int
b: T.y     // 3
c: T.z     // _|_ // field &#39;z&#39; not found in T
d: T.&#34;x-y&#34; // 4

e: {a: 1|*2} | *{a: 3|*4}
f: e.a  // 4 (default value)



    




    

Index expressions
A primary expression of the form

                Copy code
                
                    Copied!
                
            a[x]

denotes the element of a list or struct a indexed by x.
The value x is called the index or field name, respectively.
The following rules apply:
If a is not a struct:

a is a list (which need not be complete)
the index x unified with int must be concrete.
the index x is in range if 0 &lt;= x &lt; len(a), where only the
explicitly defined values of an open-ended list are considered,
otherwise it is out of range

The result of a[x] is
for a of list type:

the list element at index x, if x is within range
bottom (an error), otherwise

for a of struct type:

the index x unified with string must be concrete.
the value of the regular and non-optional field named x of struct a,
if this field exists
bottom (an error), otherwise


                Copy code
                
                    Copied!
                
            a: [ 1, 2 ][1]     // 2
b: [ 1, 2 ][2]     // _|_
c: [ 1, 2, ...][2] // _|_

// Defaults are selected for both operand and index:
x: [1, 2] | *[3, 4]
y: int | *1
z: x[y]  // 4


    




    

Operators
Operators combine operands into expressions.

                Copy code
                
                    Copied!
                
            Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &#34;|&#34; | &#34;&amp;&#34; | &#34;||&#34; | &#34;&amp;&amp;&#34; | &#34;==&#34; | rel_op | add_op | mul_op  .
rel_op     = &#34;!=&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;=~&#34; | &#34;!~&#34; .
add_op     = &#34;&#43;&#34; | &#34;-&#34; .
mul_op     = &#34;*&#34; | &#34;/&#34; .
unary_op   = &#34;&#43;&#34; | &#34;-&#34; | &#34;!&#34; | &#34;*&#34; | rel_op .

Comparisons are discussed elsewhere.
For any binary operators, the operand types must unify.



    




    

Operator precedence
Unary operators have the highest precedence.
There are eight precedence levels for binary operators.
Multiplication operators binds strongest, followed by
addition operators, comparison operators,
&amp;&amp; (logical AND), || (logical OR), &amp; (unification),
and finally | (disjunction):

                Copy code
                
                    Copied!
                
            Precedence    Operator
    7             *  /
    6             &#43;  -
    5             ==  !=  &lt;  &lt;=  &gt;  &gt;= =~ !~
    4             &amp;&amp;
    3             ||
    2             &amp;
    1             |

Binary operators of the same precedence associate from left to right.
For instance, x / y * z is the same as (x / y) * z.

                Copy code
                
                    Copied!
                
            &#43;x
23 &#43; 3*x[i]
x &lt;= f()
f() || g()
x == y&#43;1 &amp;&amp; y == z-1
2 | int
{ a: 1 } &amp; { b: 2 }


    




    

Arithmetic operators
Arithmetic operators apply to numeric values and yield a result of the same type
as the first operand. The four standard arithmetic operators
(&#43;, -, *, /) apply to integer and decimal floating-point types;
&#43; and * also apply to strings and bytes.

                Copy code
                
                    Copied!
                
            &#43;    sum                    integers, floats, strings, bytes
-    difference             integers, floats
*    product                integers, floats, strings, bytes
/    quotient               integers, floats

For any operator that accepts operands of type float, any operand may be
of type int or float, in which case the result will be float
if it cannot be represented as an int or if any of the operands are float,
or int otherwise.
So the result of 1 / 2 is 0.5 and is of type float.
The result of division by zero is bottom (an error).

Integer division is implemented through the builtin functions
quo, rem, div, and mod.
The unary operators &#43; and - are defined for numeric values as follows:

                Copy code
                
                    Copied!
                
            &#43;x                          is 0 &#43; x
-x    negation              is 0 - x


    




    

String operators
Strings can be concatenated using the &#43; operator:

                Copy code
                
                    Copied!
                
            s: &#34;hi &#34; &#43; name &#43; &#34; and good bye&#34;

String addition creates a new string by concatenating the operands.
A string can be repeated by multiplying it:

                Copy code
                
                    Copied!
                
            s: &#34;etc. &#34;*3  // &#34;etc. etc. etc. &#34;



    




    

Comparison operators
Comparison operators compare two operands and yield an untyped boolean value.

                Copy code
                
                    Copied!
                
            ==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
=~    matches regular expression
!~    does not match regular expression


In any comparison, the types of the two operands must unify or one of the
operands must be null.
The equality operators == and != apply to operands that are comparable.
The ordering operators &lt;, &lt;=, &gt;, and &gt;= apply to operands that are ordered.
The matching operators =~ and !~ apply to a string and a regular
expression operand.
These terms and the result of the comparisons are defined as follows:

Null is comparable with itself and any other type.
Two null values are always equal, null is unequal with anything else.
Boolean values are comparable.
Two boolean values are equal if they are either both true or both false.
Integer values are comparable and ordered, in the usual way.
Floating-point values are comparable and ordered, as per the definitions
for binary coded decimals in the IEEE-754-2008 standard.
Floating point numbers may be compared with integers.
String and bytes values are comparable and ordered lexically byte-wise.
Struct are not comparable.
Lists are not comparable.
The regular expression syntax is the one accepted by RE2,
described in https://github.com/google/re2/wiki/Syntax,
except for \C.
s =~ r is true if s matches the regular expression r.
s !~ r is true if s does not match regular expression r.





                Copy code
                
                    Copied!
                
            3 &lt; 4       // true
3 &lt; 4.0     // true
null == 2   // false
null != {}  // true
{} == {}    // _|_: structs are not comparable against structs

&#34;Wild cats&#34; =~ &#34;cat&#34;   // true
&#34;Wild cats&#34; !~ &#34;dog&#34;   // true

&#34;foo&#34; =~ &#34;^[a-z]{3}$&#34;  // true
&#34;foo&#34; =~ &#34;^[a-z]{4}$&#34;  // false



    




    

Logical operators
Logical operators apply to boolean values and yield a result of the same type
as the operands. The right operand is evaluated conditionally.

                Copy code
                
                    Copied!
                
            &amp;&amp;    conditional AND    p &amp;&amp; q  is  &#34;if p then q else false&#34;
||    conditional OR     p || q  is  &#34;if p then true else q&#34;
!     NOT                !p      is  &#34;not p&#34;







    




    

Calls
Calls can be made to core library functions, called builtins.
Given an expression f of function type F,

                Copy code
                
                    Copied!
                
            f(a1, a2, â€¦ an)

calls f with arguments a1, a2, â€¦ an. Arguments must be expressions
of which the values are an instance of the parameter types of F
and are evaluated before the function is called.

                Copy code
                
                    Copied!
                
            a: math.Atan2(x, y)

In a function call, the function value and arguments are evaluated in the usual
order.
After they are evaluated, the parameters of the call are passed by value
to the function and the called function begins execution.
The return parameters
of the function are passed by value back to the calling function when the
function returns.

    




    

Comprehensions
Lists and fields can be constructed using comprehensions.
Comprehensions define a clause sequence that consists of a sequence of
for, if, and let clauses, nesting from left to right.
The sequence must start with a for or if clause.
The for and let clauses each define a new scope in which new values are
bound to be available for the next clause.
The for clause binds the defined identifiers, on each iteration, to the next
value of some iterable value in a new scope.
A for clause may bind one or two identifiers.
If there is one identifier, it binds it to the value of
a list element or struct field value.
If there are two identifiers, the first value will be the key or index,
if available, and the second will be the value.
For lists, for iterates over all elements in the list after closing it.
For structs, for iterates over all non-optional regular fields.
An if clause, or guard, specifies an expression that terminates the current
iteration if it evaluates to false.
The let clause binds the result of an expression to the defined identifier
in a new scope.
A current iteration is said to complete if the innermost block of the clause
sequence is reached.
Syntactically, the comprehension value is a struct.
A comprehension can generate non-struct values by embedding such values within
this struct.
Within lists, the values yielded by a comprehension are inserted in the list
at the position of the comprehension.
Within structs, the values yielded by a comprehension are embedded within the
struct.
Both structs and lists may contain multiple comprehensions.

                Copy code
                
                    Copied!
                
            Comprehension       = Clauses StructLit .

Clauses             = StartClause { [ &#34;,&#34; ] Clause } .
StartClause         = ForClause | GuardClause .
Clause              = StartClause | LetClause .
ForClause           = &#34;for&#34; identifier [ &#34;,&#34; identifier ] &#34;in&#34; Expression .
GuardClause         = &#34;if&#34; Expression .
LetClause           = &#34;let&#34; identifier &#34;=&#34; Expression .


                Copy code
                
                    Copied!
                
            a: [1, 2, 3, 4]
b: [for x in a if x &gt; 1 { x&#43;1 }]  // [3, 4, 5]

c: {
    for x in a
    if x &lt; 4
    let y = 1 {
        &#34;\(x)&#34;: x &#43; y
    }
}
d: { &#34;1&#34;: 2, &#34;2&#34;: 3, &#34;3&#34;: 4 }


    




    

String interpolation
String interpolation allows constructing strings by replacing placeholder
expressions with their string representation.
String interpolation may be used in single- and double-quoted strings, as well
as their multiline equivalent.
A placeholder consists of \( followed by an expression and ).
The expression is evaluated in the scope within which the string is defined.
The result of the expression is substituted as follows:

string: as is
bool: the JSON representation of the bool
number: a JSON representation of the number that preserves the
precision of the underlying binary coded decimal
bytes: as if substituted within single quotes or
converted to valid UTF-8 replacing the
maximal subpart of ill-formed subsequences with a single
replacement character (W3C encoding standard) otherwise
list: illegal
struct: illegal


                Copy code
                
                    Copied!
                
            a: &#34;World&#34;
b: &#34;Hello \( a )!&#34; // Hello World!


    




    

Builtin Functions
Builtin functions are predeclared. They are called like any other function.

    




    

len
The builtin function len takes arguments of various types and returns
a result of type int.

                Copy code
                
                    Copied!
                
            Argument type    Result

bytes            length of byte sequence
list             list length, smallest length for an open list
struct           number of distinct data fields, excluding field constraints



                Copy code
                
                    Copied!
                
            Expression           Result
len(&#34;HellÃ¸&#34;)         6
len([1, 2, 3])       3
len([1, 2, ...])     2


    




    

close
The builtin function close converts a partially defined, or open, struct
to a fully defined, or closed, struct.

    




    

and
The builtin function and takes a list and returns the result of applying
the &amp; operator to all elements in the list.
It returns top for the empty list.

                Copy code
                
                    Copied!
                
            Expression:          Result
and([a, b])          a &amp; b
and([a])             a
and([])              _


    




    

or
The builtin function or takes a list and returns the result of applying
the | operator to all elements in the list.
It returns bottom for the empty list.

                Copy code
                
                    Copied!
                
            Expression:          Result
or([a, b])           a | b
or([a])              a
or([])               _|_


    




    

div, mod, quo and rem
For two integer values x and y,
the integer quotient q = div(x, y) and remainder r = mod(x, y)
implement Euclidean division and
satisfy the following relationship:

                Copy code
                
                    Copied!
                
            r = x - y*q  with 0 &lt;= r &lt; |y|

where |y| denotes the absolute value of y.

                Copy code
                
                    Copied!
                
             x     y   div(x, y)  mod(x, y)
 5     3        1          2
-5     3       -2          1
 5    -3       -1          2
-5    -3        2          1

For two integer values x and y,
the integer quotient q = quo(x, y) and remainder r = rem(x, y)
implement truncated division and
satisfy the following relationship:

                Copy code
                
                    Copied!
                
            x = q*y &#43; r  and  |r| &lt; |y|

with quo(x, y) truncated towards zero.

                Copy code
                
                    Copied!
                
             x     y   quo(x, y)  rem(x, y)
 5     3        1          2
-5     3       -1         -2
 5    -3       -1          2
-5    -3        1         -2

A zero divisor in either case results in bottom (an error).

    




    

Cycles
Implementations are required to interpret or reject cycles encountered
during evaluation according to the rules in this section.

    




    

Reference cycles
A reference cycle occurs if a field references itself, either directly or
indirectly.

                Copy code
                
                    Copied!
                
            // x references itself
x: x

// indirect cycles
b: c
c: d
d: b

Implementations should treat these as _.
Two particular cases are discussed below.

    




    

Expressions that unify an atom with an expression
An expression of the form a &amp; e, where a is an atom
and e is an expression, always evaluates to a or bottom.
As it does not matter how we fail, we can assume the result to be a
and postpone validating a == e until after all references
in e have been resolved.

                Copy code
                
                    Copied!
                
            // Config            Evaluates to (requiring concrete values)
x: {                  x: {
    a: b &#43; 100            a: _|_ // cycle detected
    b: a - 100            b: _|_ // cycle detected
}                     }

y: x &amp; {              y: {
    a: 200                a: 200 // asserted that 200 == b &#43; 100
                          b: 100
}                     }


    




    

Field values
A field value of the form r &amp; v,
where r evaluates to a reference cycle and v is a concrete value,
evaluates to v.
Unification is idempotent and unifying a value with itself ad infinitum,
which is what the cycle represents, results in this value.
Implementations should detect cycles of this kind, ignore r,
and take v as the result of unification.


                Copy code
                
                    Copied!
                
            Configuration    Evaluated
//    c           Cycles in nodes of type struct evaluate
//  â†™ï¸Ž   â†–         to the fixed point of unifying their
// a  â†’  b        values ad infinitum.

a: b &amp; { x: 1 }   // a: { x: 1, y: 2, z: 3 }
b: c &amp; { y: 2 }   // b: { x: 1, y: 2, z: 3 }
c: a &amp; { z: 3 }   // c: { x: 1, y: 2, z: 3 }

// resolve a             b &amp; {x:1}
// substitute b          c &amp; {y:2} &amp; {x:1}
// substitute c          a &amp; {z:3} &amp; {y:2} &amp; {x:1}
// eliminate a (cycle)   {z:3} &amp; {y:2} &amp; {x:1}
// simplify              {x:1,y:2,z:3}

This rule also applies to field values that are disjunctions of unification
operations of the above form.

                Copy code
                
                    Copied!
                
            a: b&amp;{x:1} | {y:1}  // {x:1,y:3,z:2} | {y:1}
b: {x:2} | c&amp;{z:2}  // {x:2} | {x:1,y:3,z:2}
c: a&amp;{y:3} | {z:3}  // {x:1,y:3,z:2} | {z:3}


// resolving a           b&amp;{x:1} | {y:1}
// substitute b          ({x:2} | c&amp;{z:2})&amp;{x:1} | {y:1}
// simplify              c&amp;{z:2}&amp;{x:1} | {y:1}
// substitute c          (a&amp;{y:3} | {z:3})&amp;{z:2}&amp;{x:1} | {y:1}
// simplify              a&amp;{y:3}&amp;{z:2}&amp;{x:1} | {y:1}
// eliminate a (cycle)   {y:3}&amp;{z:2}&amp;{x:1} | {y:1}
// expand                {x:1,y:3,z:2} | {y:1}

Note that all nodes that form a reference cycle to form a struct will evaluate
to the same value.
If a field value is a disjunction, any element that is part of a cycle will
evaluate to this value.

    




    

Structural cycles
A structural cycle is when a node references one of its ancestor nodes.
It is possible to construct a structural cycle by unifying two acyclic values:

                Copy code
                
                    Copied!
                
            // acyclic
y: {
    f: h: g
    g: _
}
// acyclic
x: {
    f: _
    g: f
}
// introduces structural cycle
z: x &amp; y

Implementations should be able to detect such structural cycles dynamically.
A structural cycle can result in infinite structure or evaluation loops.

                Copy code
                
                    Copied!
                
            // infinite structure
a: b: a

// infinite evaluation
f: {
    n:   int
    out: n &#43; (f &amp; {n: 1}).out
}

CUE must allow or disallow structural cycles under certain circumstances.
If a node a references an ancestor node, we call it and any of its
field values a.f cyclic.
So if a is cyclic, all of its descendants are also regarded as cyclic.
A given node x, whose value is composed of the conjuncts c1 &amp; ... &amp; cn,
is valid if any of its conjuncts is not cyclic.

                Copy code
                
                    Copied!
                
            // Disallowed: a list of infinite length with all elements being 1.
#List: {
    head: 1
    tail: #List
}

// Disallowed: another infinite structure (a:{b:{d:{b:{d:{...}}}}}, ...).
a: {
    b: c
}
c: {
    d: a
}

// #List defines a list of arbitrary length. Because the recursive reference
// is part of a disjunction, this does not result in a structural cycle.
#List: {
    head: _
    tail: null | #List
}

// Usage of #List. The value of tail in the most deeply nested element will
// be `null`: as the value of the disjunct referring to list is the only
// conjunct, all conjuncts are cyclic and the value is invalid and so
// eliminated from the disjunction.
MyList: #List &amp; { head: 1, tail: { head: 2 }}



    




    

Modules, instances, and packages
CUE configurations are constructed combining instances.
An instance, in turn, is constructed from one or more source files belonging
to the same package that together declare the data representation.
Elements of this data representation may be exported and used
in other instances.

    




    

Source file organization
Each source file consists of an optional package clause defining collection
of files to which it belongs,
followed by a possibly empty set of import declarations that declare
packages whose contents it wishes to use, followed by a possibly empty set of
declarations.
Like with a struct, a source file may contain embeddings.
Unlike with a struct, the embedded expressions may be any value.
If the result of the unification of all embedded values is not a struct,
it will be output instead of its enclosing file when exporting CUE
to a data format

                Copy code
                
                    Copied!
                
            SourceFile = { attribute &#34;,&#34; } [ PackageClause &#34;,&#34; ] { ImportDecl &#34;,&#34; } { Declaration &#34;,&#34; } .


                Copy code
                
                    Copied!
                
            &#34;Hello \(#place)!&#34;

#place: &#34;world&#34;

// Outputs &#34;Hello world!&#34;


    




    

Package clause
A package clause is an optional clause that defines the package to which
a source file the file belongs.

                Copy code
                
                    Copied!
                
            PackageClause  = &#34;package&#34; PackageName .
PackageName    = identifier .

The PackageName must not be a definition identifier.
If the PackageName is the blank identifier (_), it is treated the same
as if there were no package clause. This can be useful to allow adding
package level attributes or doc comments to a CUE file without a package
name.

                Copy code
                
                    Copied!
                
            package math


    




    

Modules and instances
A module defines a tree of directories, rooted at the module root.
All source files within a module with the same package name belong to the same
package.

A module may define multiple packages.
An instance of a package is any subset of files belonging
to the same package.




It is interpreted as the concatenation of these files.
An implementation may impose conventions on the layout of package files
to determine which files of a package belongs to an instance.
For example, an instance may be defined as the subset of package files
belonging to a directory and all its ancestors.


    




    

Import declarations
An import declaration states that the source file containing the declaration
depends on definitions of the imported package
and enables access to exported identifiers of that package.
The import names an identifier (PackageName) to be used for access and an
ImportPath that specifies the package to be imported.

                Copy code
                
                    Copied!
                
            ImportDecl       = &#34;import&#34; ( ImportSpec | &#34;(&#34; { ImportSpec &#34;,&#34; } &#34;)&#34; ) .
ImportSpec       = [ PackageName ] ImportPath .
ImportLocation   = { unicode_value } .
ImportPath       = `&#34;` ImportLocation [ &#34;:&#34; identifier ] `&#34;` .

The PackageName is used in qualified identifiers to access
exported identifiers of the package within the importing source file.
It is declared in the file block.
It defaults to the identifier specified in the package clause of the imported
package, which must match either the last path component of ImportLocation
or the identifier following it.

The interpretation of the ImportPath is implementation-dependent but it is
typically either the path of a builtin package or a fully qualifying location
of a package within a source code repository.
An ImportLocation must be a non-empty string using only characters belonging to
Unicode&rsquo;s L, M, N, P, and S general categories
(the Graphic characters without spaces)
and may not include the characters !&quot;#$%&amp;&#39;()*,:;&lt;=&gt;?[\\]^`{|}
or the Unicode replacement character U&#43;FFFD.
Assume we have package containing the package clause package math,
which exports function Sin at the path identified by lib/math.
This table illustrates how Sin is accessed in files
that import the package after the various types of import declaration.


                Copy code
                
                    Copied!
                
            Import declaration          Local name of Sin

import   &#34;lib/math&#34;         math.Sin
import   &#34;lib/math:math&#34;    math.Sin
import m &#34;lib/math&#34;         m.Sin

An import declaration declares a dependency relation between the importing and
imported package. It is illegal for a package to import itself, directly or
indirectly, or to directly import a package without referring to any of its
exported identifiers.

    




    

An example package
TODO
">
<meta itemprop="wordCount" content="12204">


                <div class="article__container">
                    



<header class="article__header">
        <div class="article__info"><div class="article__authors">


<div class="authors">
    
        
        

        
            <details class="authors__item" data-dropdown>
                <summary class="authors__avatar">
                    <img class="authors__image" src="https://github.com/mpvl.png" alt="mpvl">

                    
                        <span class="authors__display-name">Marcel van Lohuizen</span>
                    
                </summary>

                <div class="authors--popover">
                    <div class="authors__avatar">
                        <img class="authors__image" src="https://github.com/mpvl.png" alt="mpvl">

                        <div class="authors__name">
                            
                                <span class="authors__display-name">Marcel van Lohuizen</span>
                            

                        </div>
                    </div>

                    <div class="authors__links">
                        <div class="authors__github">

                            <a class="authors__link" href="https://github.com/mpvl">
                                



<svg class="icon authors__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--github"></use>
</svg>

                                <p>
                                    <span class="authors__link-text">Github profile</span>
                                </p>
                            </a>
                        </div>

                        <div class="authors__search">
                            <a class="authors__link" href="/search/?q=author:mpvl">
                                



<svg class="icon authors__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--search"></use>
</svg>

                                <p>
                                    <span class="authors__link-text">Search all content by this author</span>
                                </p>
                            </a>
                        </div>
                    </div>
                </div>
            </details>
        
    
</div>
</div></div></header>



                    <div class="article__content">
                        
                            <div class="note note--info" role="alert">



<svg class="icon note__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--exclamation"></use>
</svg>
<div class="note__content"><h4 id="note-to-implementors">
    <a href="#note-to-implementors" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Note to implementors</h4>
<p>Notes on the formalism underlying this specification can be found
<a href="https://github.com/cue-lang/cue/blob/master/doc/ref/impl.md">here</a>.</p></div>
</div>

<h2 id="introduction">
    <a href="#introduction" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Introduction</h2>
<p>This is a reference manual for the CUE data constraint language.
CUE, pronounced cue or Q, is a general-purpose and strongly typed
constraint-based language.
It can be used for data templating, data validation, code generation, scripting,
and many other applications involving structured data.
The CUE tooling, layered on top of CUE, provides
a general purpose scripting language for creating scripts as well as
simple servers, also expressed in CUE.</p>
<p>CUE was designed with cloud configuration and related systems in mind,
but is not limited to this domain.
It derives its formalism from relational programming languages.
This formalism allows for managing and reasoning over large amounts of
data in a straightforward manner.</p>
<p>The grammar is compact and regular, allowing for easy analysis by automatic
tools such as integrated development environments.</p>
<p>This document is maintained by <a href="mailto:mpvl@golang.org">mpvl@golang.org</a>.
CUE has a lot of similarities with the Go language. This document draws heavily
from the Go specification as a result.</p>
<p>CUE draws its influence from many languages.
Its main influences were BCL/GCL (internal to Google),
LKB (LinGO), Go, and JSON.
Others are Swift, Typescript, Javascript, Prolog, NCL (internal to Google),
Jsonnet, HCL, Flabbergast, Nix, JSONPath, Haskell, Objective-C, and Python.</p>
<h2 id="notation">
    <a href="#notation" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Notation</h2>
<p>The syntax is specified using Extended Backus-Naur Form (EBNF):</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UHJvZHVjdGlvbiAgPSBwcm9kdWN0aW9uX25hbWUgIj0iIFsgRXhwcmVzc2lvbiBdICIuIiAuCkV4cHJlc3Npb24gID0gQWx0ZXJuYXRpdmUgeyAifCIgQWx0ZXJuYXRpdmUgfSAuCkFsdGVybmF0aXZlID0gVGVybSB7IFRlcm0gfSAuClRlcm0gICAgICAgID0gcHJvZHVjdGlvbl9uYW1lIHwgdG9rZW4gWyAi4oCmIiB0b2tlbiBdIHwgR3JvdXAgfCBPcHRpb24gfCBSZXBldGl0aW9uIC4KR3JvdXAgICAgICAgPSAiKCIgRXhwcmVzc2lvbiAiKSIgLgpPcHRpb24gICAgICA9ICJbIiBFeHByZXNzaW9uICJdIiAuClJlcGV0aXRpb24gID0gInsiIEV4cHJlc3Npb24gIn0iIC4=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Production  = production_name &#34;=&#34; [ Expression ] &#34;.&#34; .
Expression  = Alternative { &#34;|&#34; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &#34;â€¦&#34; token ] | Group | Option | Repetition .
Group       = &#34;(&#34; Expression &#34;)&#34; .
Option      = &#34;[&#34; Expression &#34;]&#34; .
Repetition  = &#34;{&#34; Expression &#34;}&#34; .</code></pre></div>
</div>
<p>Productions are expressions constructed from terms and the following operators,
in increasing precedence:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="fCAgIGFsdGVybmF0aW9uCigpICBncm91cGluZwpbXSAgb3B0aW9uICgwIG9yIDEgdGltZXMpCnt9ICByZXBldGl0aW9uICgwIHRvIG4gdGltZXMp">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)</code></pre></div>
</div>
<p>Lower-case production names are used to identify lexical tokens. Non-terminals
are in CamelCase. Lexical tokens are enclosed in double quotes <code>&quot;&quot;</code> or back
quotes <code>``</code>.</p>
<p>The form <code>a â€¦ b</code> represents the set of characters from a through b as
alternatives. The horizontal ellipsis <code>â€¦</code> is also used elsewhere in the spec to
informally denote various enumerations or code snippets that are not further
specified. The character <code>â€¦</code> (as opposed to the three characters <code>...</code>) is not a
token of the CUE language.</p>
<h2 id="source-code-representation">
    <a href="#source-code-representation" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Source code representation</h2>
<p>Source code is Unicode text encoded in UTF-8.
Unless otherwise noted, the text is not canonicalized, so a single
accented code point is distinct from the same character constructed from
combining an accent and a letter; those are treated as two code points.
For simplicity, this document will use the unqualified term character to refer
to a Unicode code point in the source text.</p>
<p>Each code point is distinct; for instance, upper and lower case letters are
different characters.</p>
<p>Implementation restriction: For compatibility with other tools, a compiler may
disallow the NUL character (U+0000) in the source text.</p>
<p>Implementation restriction: For compatibility with other tools, a compiler may
ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code
point in the source text. A byte order mark may be disallowed anywhere else in
the source.</p>
<h3 id="characters">
    <a href="#characters" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Characters</h3>
<p>The following terms are used to denote specific Unicode character classes:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bmV3bGluZSAgICAgICAgPSAvKiB0aGUgVW5pY29kZSBjb2RlIHBvaW50IFUrMDAwQSAqLyAuCnVuaWNvZGVfY2hhciAgID0gLyogYW4gYXJiaXRyYXJ5IFVuaWNvZGUgY29kZSBwb2ludCBleGNlcHQgbmV3bGluZSAqLyAuCnVuaWNvZGVfbGV0dGVyID0gLyogYSBVbmljb2RlIGNvZGUgcG9pbnQgY2xhc3NpZmllZCBhcyAiTGV0dGVyIiAqLyAuCnVuaWNvZGVfZGlnaXQgID0gLyogYSBVbmljb2RlIGNvZGUgcG9pbnQgY2xhc3NpZmllZCBhcyAiTnVtYmVyLCBkZWNpbWFsIGRpZ2l0IiAqLyAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as &#34;Letter&#34; */ .
unicode_digit  = /* a Unicode code point classified as &#34;Number, decimal digit&#34; */ .</code></pre></div>
</div>
<p>In The Unicode Standard 8.0, Section 4.5 &ldquo;General Category&rdquo; defines a set of
character categories.
CUE treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo
as Unicode letters, and those in the Number category Nd as Unicode digits.</p>
<h3 id="letters-and-digits">
    <a href="#letters-and-digits" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Letters and digits</h3>
<p>The underscore character <code>_</code> (U+005F) is considered a letter.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bGV0dGVyICAgICAgICA9IHVuaWNvZGVfbGV0dGVyIHwgIl8iIHwgIiQiIC4KZGVjaW1hbF9kaWdpdCA9ICIwIiDigKYgIjkiIC4KYmluYXJ5X2RpZ2l0ICA9ICIwIiDigKYgIjEiIC4Kb2N0YWxfZGlnaXQgICA9ICIwIiDigKYgIjciIC4KaGV4X2RpZ2l0ICAgICA9ICIwIiDigKYgIjkiIHwgIkEiIOKApiAiRiIgfCAiYSIg4oCmICJmIiAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>letter        = unicode_letter | &#34;_&#34; | &#34;$&#34; .
decimal_digit = &#34;0&#34; â€¦ &#34;9&#34; .
binary_digit  = &#34;0&#34; â€¦ &#34;1&#34; .
octal_digit   = &#34;0&#34; â€¦ &#34;7&#34; .
hex_digit     = &#34;0&#34; â€¦ &#34;9&#34; | &#34;A&#34; â€¦ &#34;F&#34; | &#34;a&#34; â€¦ &#34;f&#34; .</code></pre></div>
</div>
<h2 id="lexical-elements">
    <a href="#lexical-elements" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Lexical elements</h2>
<h3 id="comments">
    <a href="#comments" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Comments</h3>
<p>Comments serve as program documentation.
CUE supports line comments that start with the character sequence <code>//</code>
and stop at the end of the line.</p>
<p>A comment cannot start inside a string literal or inside a comment.
A comment acts like a newline.</p>
<h3 id="tokens">
    <a href="#tokens" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Tokens</h3>
<p>Tokens form the vocabulary of the CUE language. There are four classes:
identifiers, keywords, operators and punctuation, and literals. White space,
formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns
(U+000D), and newlines (U+000A), is ignored except as it separates tokens that
would otherwise combine into a single token. Also, a newline or end of file may
trigger the insertion of a comma. While breaking the input into tokens, the
next token is the longest sequence of characters that form a valid token.</p>
<h3 id="commas">
    <a href="#commas" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Commas</h3>
<p>The formal grammar uses commas <code>,</code> as terminators in a number of productions.
CUE programs may omit most of these commas using the following rules:</p>
<p>When the input is broken into tokens, a comma is automatically inserted into
the token stream immediately after a line&rsquo;s final token if that token is</p>
<ul>
<li>an identifier, keyword, or bottom</li>
<li>a number or string literal, including an interpolation</li>
<li>one of the characters <code>)</code>, <code>]</code>, <code>}</code>, or <code>?</code></li>
<li>an ellipsis <code>...</code></li>
</ul>
<p>Although commas are automatically inserted, the parser will require
explicit commas between two list elements.</p>
<!--
TODO: remove the above exception
-->
<p>To reflect idiomatic use, examples in this document elide commas using
these rules.</p>
<h3 id="identifiers">
    <a href="#identifiers" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Identifiers</h3>
<p>Identifiers name entities such as fields and aliases.
An identifier is a sequence of one or more letters (which includes <code>_</code> and <code>$</code>)
and digits, optionally preceded by <code>#</code> or <code>_#</code>.
It may not be <code>_</code> or <code>$</code>.
The first character in an identifier, or after an <code>#</code> if it contains one,
must be a letter.
Identifiers starting with a <code>#</code> or <code>_</code> are reserved for definitions and hidden
fields.</p>
<!--
TODO: allow identifiers as defined in Unicode UAX #31
(https://unicode.org/reports/tr31/).

Identifiers are normalized using the NFC normal form.
-->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="aWRlbnRpZmllciAgPSBbICIjIiB8ICJfIyIgXSBsZXR0ZXIgeyBsZXR0ZXIgfCB1bmljb2RlX2RpZ2l0IH0gLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>identifier  = [ &#34;#&#34; | &#34;_#&#34; ] letter { letter | unicode_digit } .</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YQpfeDkKZmllbGROYW1lCs6xzrI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a
_x9
fieldName
Î±Î²</code></pre></div>
</div>
<!-- TODO: Allow Unicode identifiers TR 32 http://unicode.org/reports/tr31/ -->
<p>Some identifiers are <a href="/docs/reference/spec/#predeclared-identifiers">predeclared</a>.</p>
<h3 id="keywords">
    <a href="#keywords" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Keywords</h3>
<p>CUE has a limited set of keywords.
In addition, CUE reserves all identifiers starting with <code>__</code> (double underscores)
as keywords.
These are typically targets of pre-declared identifiers.</p>
<p>All keywords may be used as labels (field names).
Unless noted otherwise, they can also be used as identifiers to refer to
the same name.</p>
<h4 id="values">
    <a href="#values" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Values</h4>
<p>The following keywords are values.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bnVsbCAgICAgICAgIHRydWUgICAgICAgICBmYWxzZQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>null         true         false</code></pre></div>
</div>
<p>These can never be used to refer to a field of the same name.
This restriction is to ensure compatibility with JSON configuration files.</p>
<h4 id="preamble">
    <a href="#preamble" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Preamble</h4>
<p>The following keywords are used at the preamble of a CUE file.
After the preamble, they may be used as identifiers to refer to namesake fields.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="cGFja2FnZSAgICAgIGltcG9ydA==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>package      import</code></pre></div>
</div>
<h4 id="comprehension-clauses">
    <a href="#comprehension-clauses" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Comprehension clauses</h4>
<p>The following keywords are used in comprehensions.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Zm9yICAgICAgICAgIGluICAgICAgICAgICBpZiAgICAgICAgICAgbGV0">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>for          in           if           let</code></pre></div>
</div>
<!--
TODO:
    reduce [to]
    order [by]
-->
<h3 id="operators-and-punctuation">
    <a href="#operators-and-punctuation" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Operators and punctuation</h3>
<p>The following character sequences represent operators and punctuation:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="KyAgICAgJiYgICAgPT0gICAgPCAgICAgPSAgICAgKCAgICAgKQotICAgICB8fCAgICAhPSAgICA&#43;ICAgICA6ICAgICB7ICAgICB9CiogICAgICYgICAgID1&#43;ICAgIDw9ICAgID8gICAgIFsgICAgIF0gICAgICwKLyAgICAgfCAgICAgIX4gICAgPj0gICAgISAgICAgX3xfICAgLi4uICAgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>+     &amp;&amp;    ==    &lt;     =     (     )
-     ||    !=    &gt;     :     {     }
*     &amp;     =~    &lt;=    ?     [     ]     ,
/     |     !~    &gt;=    !     _|_   ...   .</code></pre></div>
</div>
<!--
Free tokens:  ; ~ ^
// To be used:
  @   at: associative lists.

// Idea: use # instead of @ for attributes and allow then at declaration level.
// This will open up the possibility of defining #! at the start of a file
// without requiring special syntax. Although probably not quite.
 -->
<h3 id="numeric-literals">
    <a href="#numeric-literals" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Numeric literals</h3>
<p>There are several kinds of numeric literals.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="aW50X2xpdCAgICAgPSBkZWNpbWFsX2xpdCB8IHNpX2xpdCB8IG9jdGFsX2xpdCB8IGJpbmFyeV9saXQgfCBoZXhfbGl0IC4KZGVjaW1hbF9saXQgPSAiMCIgfCAoICIxIiDigKYgIjkiICkgeyBbICJfIiBdIGRlY2ltYWxfZGlnaXQgfSAuCmRlY2ltYWxzICAgID0gZGVjaW1hbF9kaWdpdCB7IFsgIl8iIF0gZGVjaW1hbF9kaWdpdCB9IC4Kc2lfaXQgICAgICAgPSBkZWNpbWFscyBbICIuIiBkZWNpbWFscyBdIG11bHRpcGxpZXIgfAogICAgICAgICAgICAgICIuIiBkZWNpbWFscyAgbXVsdGlwbGllciAuCmJpbmFyeV9saXQgID0gIjBiIiBiaW5hcnlfZGlnaXQgeyBbICJfIiBdIGJpbmFyeV9kaWdpdCB9IC4KaGV4X2xpdCAgICAgPSAiMCIgKCAieCIgfCAiWCIgKSBoZXhfZGlnaXQgeyBbICJfIiBdIGhleF9kaWdpdCB9IC4Kb2N0YWxfbGl0ICAgPSAiMG8iIG9jdGFsX2RpZ2l0IHsgWyAiXyIgXSBvY3RhbF9kaWdpdCB9IC4KbXVsdGlwbGllciAgPSAoICJLIiB8ICJNIiB8ICJHIiB8ICJUIiB8ICJQIiApIFsgImkiIF0KCmZsb2F0X2xpdCAgID0gZGVjaW1hbHMgIi4iIFsgZGVjaW1hbHMgXSBbIGV4cG9uZW50IF0gfAogICAgICAgICAgICAgIGRlY2ltYWxzIGV4cG9uZW50IHwKICAgICAgICAgICAgICAiLiIgZGVjaW1hbHMgWyBleHBvbmVudCBdLgpleHBvbmVudCAgICA9ICggImUiIHwgIkUiICkgWyAiKyIgfCAiLSIgXSBkZWNpbWFscyAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>int_lit     = decimal_lit | si_lit | octal_lit | binary_lit | hex_lit .
decimal_lit = &#34;0&#34; | ( &#34;1&#34; â€¦ &#34;9&#34; ) { [ &#34;_&#34; ] decimal_digit } .
decimals    = decimal_digit { [ &#34;_&#34; ] decimal_digit } .
si_it       = decimals [ &#34;.&#34; decimals ] multiplier |
              &#34;.&#34; decimals  multiplier .
binary_lit  = &#34;0b&#34; binary_digit { [ &#34;_&#34; ] binary_digit } .
hex_lit     = &#34;0&#34; ( &#34;x&#34; | &#34;X&#34; ) hex_digit { [ &#34;_&#34; ] hex_digit } .
octal_lit   = &#34;0o&#34; octal_digit { [ &#34;_&#34; ] octal_digit } .
multiplier  = ( &#34;K&#34; | &#34;M&#34; | &#34;G&#34; | &#34;T&#34; | &#34;P&#34; ) [ &#34;i&#34; ]

float_lit   = decimals &#34;.&#34; [ decimals ] [ exponent ] |
              decimals exponent |
              &#34;.&#34; decimals [ exponent ].
exponent    = ( &#34;e&#34; | &#34;E&#34; ) [ &#34;+&#34; | &#34;-&#34; ] decimals .</code></pre></div>
</div>
<p>An <em>integer literal</em> is a sequence of digits representing an integer value.
An optional prefix sets a non-decimal base: <code>0o</code> for octal,
<code>0x</code> or <code>0X</code> for hexadecimal, and <code>0b</code> for binary.
In hexadecimal literals, letters <code>a â€¦ f</code> and <code>A â€¦ F</code> represent values 10 through 15.
All integers allow interstitial underscores <code>_</code>;
these have no meaning and are solely for readability.</p>
<p>Integer literals may have an SI or IEC multiplier.
Multipliers can be used with fractional numbers.
When multiplying a fraction by a multiplier, the result is truncated
towards zero if it is not an integer.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="NDIKMS41RyAgICAvLyAxXzUwMF8wMDBfMDAwCjEuM0tpICAgLy8gMS4zICogMTAyNCA9IHRydW5jKDEzMzEuMikgPSAxMzMxCjE3MF8xNDFfMTgzXzQ2MF80NjlfMjMxXzczMV82ODdfMzAzXzcxNV84ODRfMTA1XzcyNwoweEJhZF9GYWNlCjBvNzU1CjBiMDEwMV8wMDAx">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>42
1.5G    // 1_500_000_000
1.3Ki   // 1.3 * 1024 = trunc(1331.2) = 1331
170_141_183_460_469_231_731_687_303_715_884_105_727
0xBad_Face
0o755
0b0101_0001</code></pre></div>
</div>
<p>A <em>decimal floating-point literal</em> is a representation of
a decimal floating-point value (a <em>float</em>).
It has an integer part, a decimal point, a fractional part, and an
exponent part.
The integer and fractional part comprise decimal digits; the
exponent part is an <code>e</code> or <code>E</code> followed by an optionally signed decimal exponent.
One of the integer part or the fractional part may be elided; one of the decimal
point or the exponent may be elided.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="MC4KNzIuNDAKMDcyLjQwICAvLyA9PSA3Mi40MAoyLjcxODI4CjEuZSswCjYuNjc0MjhlLTExCjFFNgouMjUKLjEyMzQ1RSs1">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5</code></pre></div>
</div>
<!--
TODO: consider allowing Exo (and up), if not followed by a sign
or number. Alternatively one could only allow Ei, Yi, and Zi.
-->
<p>Neither a <code>float_lit</code> nor an <code>si_lit</code> may appear after a token that is:</p>
<ul>
<li>an identifier, keyword, or bottom</li>
<li>a number or string literal, including an interpolation</li>
<li>one of the characters <code>)</code>, <code>]</code>, <code>}</code>, <code>?</code>, or <code>.</code>.</li>
</ul>
<!--
So
`a + 3.2Ti`  -> `a`, `+`, `3.2Ti`
`a 3.2Ti`    -> `a`, `3`, `.`, `2`, `Ti`
`a + .5e3`   -> `a`, `+`, `.5e3`
`a .5e3`     -> `a`, `.`, `5`, `e3`.
-->
<h3 id="string-and-byte-sequence-literals">
    <a href="#string-and-byte-sequence-literals" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>String and byte sequence literals</h3>
<p>A string literal represents a string constant obtained from concatenating a
sequence of characters.
Byte sequences are a sequence of bytes.</p>
<p>String and byte sequence literals are character sequences between,
respectively, double and single quotes, as in <code>&quot;bar&quot;</code> and <code>'bar'</code>.
Within the quotes, any character may appear except newline and,
respectively, unescaped double or single quote.
String literals may only be valid UTF-8.
Byte sequences may contain any sequence of bytes.</p>
<p>Several escape sequences allow arbitrary values to be encoded as ASCII text.
An escape sequence starts with an <em>escape delimiter</em>, which is <code>\</code> by default.
The escape delimiter may be altered to be <code>\</code> plus a fixed number of
hash symbols <code>#</code> by padding the start and end of a string or byte sequence
literal with this number of hash symbols.</p>
<!--
TODO: move these examples further up so it's evident why #" exists.
	#"This is not an \(interpolation)"#
	#"This is an \#(interpolation)"#
	#"The sequence "\U0001F604" renders as \#U0001F604."#
-->
<p>There are four ways to represent the integer value as a numeric constant: <code>\x</code>
followed by exactly two hexadecimal digits; <code>\u</code> followed by exactly four
hexadecimal digits; <code>\U</code> followed by exactly eight hexadecimal digits, and a
plain backslash <code>\</code> followed by exactly three octal digits.
In each case the value of the literal is the value represented by the
digits in the corresponding base.
Hexadecimal and octal escapes are only allowed within byte sequences
(single quotes).</p>
<p>Although these representations all result in an integer, they have different
valid ranges.
Octal escapes must represent a value between 0 and 255 inclusive.
Hexadecimal escapes satisfy this condition by construction.
The escapes <code>\u</code> and <code>\U</code> represent Unicode code points so within them
some values are illegal, in particular those above <code>0x10FFFF</code>.
Surrogate halves are allowed,
but are translated into their non-surrogate equivalent internally.</p>
<p>The three-digit octal (<code>\nnn</code>) and two-digit hexadecimal (<code>\xnn</code>) escapes
represent individual bytes of the resulting string; all other escapes represent
the (possibly multi-byte) UTF-8 encoding of individual characters.
Thus inside a string literal <code>\377</code> and <code>\xFF</code> represent a single byte of
value <code>0xFF=255</code>, while <code>Ã¿</code>, <code>\u00FF</code>, <code>\U000000FF</code> and <code>\xc3\xbf</code> represent
the two bytes <code>0xc3 0xbf</code> of the UTF-8 encoding of character <code>U+00FF</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="XGEgICBVKzAwMDcgYWxlcnQgb3IgYmVsbApcYiAgIFUrMDAwOCBiYWNrc3BhY2UKXGYgICBVKzAwMEMgZm9ybSBmZWVkClxuICAgVSswMDBBIGxpbmUgZmVlZCBvciBuZXdsaW5lClxyICAgVSswMDBEIGNhcnJpYWdlIHJldHVybgpcdCAgIFUrMDAwOSBob3Jpem9udGFsIHRhYgpcdiAgIFUrMDAwYiB2ZXJ0aWNhbCB0YWIKXC8gICBVKzAwMmYgc2xhc2ggKHNvbGlkdXMpClxcICAgVSswMDVjIGJhY2tzbGFzaApcJyAgIFUrMDAyNyBzaW5nbGUgcXVvdGUgICh2YWxpZCBlc2NhcGUgb25seSB3aXRoaW4gc2luZ2xlIHF1b3RlZCBsaXRlcmFscykKXCIgICBVKzAwMjIgZG91YmxlIHF1b3RlICAodmFsaWQgZXNjYXBlIG9ubHkgd2l0aGluIGRvdWJsZSBxdW90ZWQgbGl0ZXJhbHMp">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\/   U+002f slash (solidus)
\\   U+005c backslash
\&#39;   U+0027 single quote  (valid escape only within single quoted literals)
\&#34;   U+0022 double quote  (valid escape only within double quoted literals)</code></pre></div>
</div>
<p>The escape <code>\(</code> is used as an escape for string interpolation.
A <code>\(</code> must be followed by a valid CUE Expression, followed by a <code>)</code>.</p>
<p>A backslash at the end of a line elides the line terminator that follows it.
This may not escape the final newline inside a multiline string: that
newline is already implicitly elided.</p>
<p>All other sequences starting with a backslash are illegal inside literals.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="ZXNjYXBlZF9jaGFyICAgICA9IGBcYCB7IGAjYCB9ICggImEiIHwgImIiIHwgImYiIHwgIm4iIHwgInIiIHwgInQiIHwgInYiIHwgIi8iIHwgYFxgIHwgIiciIHwgYCJgICkgLgpieXRlX3ZhbHVlICAgICAgID0gb2N0YWxfYnl0ZV92YWx1ZSB8IGhleF9ieXRlX3ZhbHVlIC4Kb2N0YWxfYnl0ZV92YWx1ZSA9IGBcYCB7IGAjYCB9IG9jdGFsX2RpZ2l0IG9jdGFsX2RpZ2l0IG9jdGFsX2RpZ2l0IC4KaGV4X2J5dGVfdmFsdWUgICA9IGBcYCB7IGAjYCB9ICJ4IiBoZXhfZGlnaXQgaGV4X2RpZ2l0IC4KbGl0dGxlX3VfdmFsdWUgICA9IGBcYCB7IGAjYCB9ICJ1IiBoZXhfZGlnaXQgaGV4X2RpZ2l0IGhleF9kaWdpdCBoZXhfZGlnaXQgLgpiaWdfdV92YWx1ZSAgICAgID0gYFxgIHsgYCNgIH0gIlUiIGhleF9kaWdpdCBoZXhfZGlnaXQgaGV4X2RpZ2l0IGhleF9kaWdpdAogICAgICAgICAgICAgICAgICAgICAgICAgICBoZXhfZGlnaXQgaGV4X2RpZ2l0IGhleF9kaWdpdCBoZXhfZGlnaXQgLgp1bmljb2RlX3ZhbHVlICAgID0gdW5pY29kZV9jaGFyIHwgbGl0dGxlX3VfdmFsdWUgfCBiaWdfdV92YWx1ZSB8IGVzY2FwZWRfY2hhciAuCmludGVycG9sYXRpb24gICAgPSAiXCIgeyBgI2AgfSAiKCIgRXhwcmVzc2lvbiAiKSIgLgoKc3RyaW5nX2xpdCAgICAgICA9IHNpbXBsZV9zdHJpbmdfbGl0IHwKICAgICAgICAgICAgICAgICAgIG11bHRpbGluZV9zdHJpbmdfbGl0IHwKICAgICAgICAgICAgICAgICAgIHNpbXBsZV9ieXRlc19saXQgfAogICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lX2J5dGVzX2xpdCB8CiAgICAgICAgICAgICAgICAgICBgI2Agc3RyaW5nX2xpdCBgI2AgLgoKc2ltcGxlX3N0cmluZ19saXQgICAgPSBgImAgeyB1bmljb2RlX3ZhbHVlIHwgaW50ZXJwb2xhdGlvbiB9IGAiYCAuCnNpbXBsZV9ieXRlc19saXQgICAgID0gYCdgIHsgdW5pY29kZV92YWx1ZSB8IGludGVycG9sYXRpb24gfCBieXRlX3ZhbHVlIH0gYCdgIC4KbXVsdGlsaW5lX3N0cmluZ19saXQgPSBgIiIiYCBuZXdsaW5lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB1bmljb2RlX3ZhbHVlIHwgaW50ZXJwb2xhdGlvbiB8IG5ld2xpbmUgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmUgYCIiImAgLgptdWx0aWxpbmVfYnl0ZXNfbGl0ICA9ICInJyciIG5ld2xpbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHVuaWNvZGVfdmFsdWUgfCBpbnRlcnBvbGF0aW9uIHwgYnl0ZV92YWx1ZSB8IG5ld2xpbmUgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmUgIicnJyIgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>escaped_char     = `\` { `#` } ( &#34;a&#34; | &#34;b&#34; | &#34;f&#34; | &#34;n&#34; | &#34;r&#34; | &#34;t&#34; | &#34;v&#34; | &#34;/&#34; | `\` | &#34;&#39;&#34; | `&#34;` ) .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` { `#` } octal_digit octal_digit octal_digit .
hex_byte_value   = `\` { `#` } &#34;x&#34; hex_digit hex_digit .
little_u_value   = `\` { `#` } &#34;u&#34; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` { `#` } &#34;U&#34; hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
interpolation    = &#34;\&#34; { `#` } &#34;(&#34; Expression &#34;)&#34; .

string_lit       = simple_string_lit |
                   multiline_string_lit |
                   simple_bytes_lit |
                   multiline_bytes_lit |
                   `#` string_lit `#` .

simple_string_lit    = `&#34;` { unicode_value | interpolation } `&#34;` .
simple_bytes_lit     = `&#39;` { unicode_value | interpolation | byte_value } `&#39;` .
multiline_string_lit = `&#34;&#34;&#34;` newline
                             { unicode_value | interpolation | newline }
                             newline `&#34;&#34;&#34;` .
multiline_bytes_lit  = &#34;&#39;&#39;&#39;&#34; newline
                             { unicode_value | interpolation | byte_value | newline }
                             newline &#34;&#39;&#39;&#39;&#34; .</code></pre></div>
</div>
<p>Carriage return characters (<code>\r</code>) inside string literals are discarded from
the string value.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="J2FcMDAwXHhhYicKJ1wwMDcnCidcMzc3JwonXHhhJyAgICAgICAgLy8gaWxsZWdhbDogdG9vIGZldyBoZXhhZGVjaW1hbCBkaWdpdHMKIlxuIgoiXCIiCidIZWxsbywgd29ybGQhXG4nCiJIZWxsbywgXCggbmFtZSApISIKIuaXpeacrOiqniIKIlx1NjVlNeacrFxVMDAwMDhhOWUiCidceGZmXHUwMEZGJwoiXHVEODAwIiAgICAgICAgICAgICAvLyBpbGxlZ2FsOiBzdXJyb2dhdGUgaGFsZiAoVE9ETzogcHJvYmFibHkgc2hvdWxkIGFsbG93KQoiXFUwMDExMDAwMCIgICAgICAgICAvLyBpbGxlZ2FsOiBpbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludAoKIyJUaGlzIGlzIG5vdCBhbiBcKGludGVycG9sYXRpb24pIiMKIyJUaGlzIGlzIGFuIFwjKGludGVycG9sYXRpb24pIiMKIyJUaGUgc2VxdWVuY2UgIlxVMDAwMUY2MDQiIHJlbmRlcnMgYXMgXCNVMDAwMUY2MDQuIiM=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&#39;a\000\xab&#39;
&#39;\007&#39;
&#39;\377&#39;
&#39;\xa&#39;        // illegal: too few hexadecimal digits
&#34;\n&#34;
&#34;\&#34;&#34;
&#39;Hello, world!\n&#39;
&#34;Hello, \( name )!&#34;
&#34;æ—¥æœ¬èªž&#34;
&#34;\u65e5æœ¬\U00008a9e&#34;
&#39;\xff\u00FF&#39;
&#34;\uD800&#34;             // illegal: surrogate half (TODO: probably should allow)
&#34;\U00110000&#34;         // illegal: invalid Unicode code point

#&#34;This is not an \(interpolation)&#34;#
#&#34;This is an \#(interpolation)&#34;#
#&#34;The sequence &#34;\U0001F604&#34; renders as \#U0001F604.&#34;#</code></pre></div>
</div>
<p>These examples all represent the same string:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="IuaXpeacrOiqniIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVVEYtOCBpbnB1dCB0ZXh0Cifml6XmnKzoqp4nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVVRGLTggaW5wdXQgdGV4dCBhcyBieXRlIHNlcXVlbmNlCiJcdTY1ZTVcdTY3MmNcdThhOWUiICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXhwbGljaXQgVW5pY29kZSBjb2RlIHBvaW50cwoiXFUwMDAwNjVlNVxVMDAwMDY3MmNcVTAwMDA4YTllIiAgICAgICAgLy8gdGhlIGV4cGxpY2l0IFVuaWNvZGUgY29kZSBwb2ludHMKJ1x4ZTZceDk3XHhhNVx4ZTZceDljXHhhY1x4ZThceGFhXHg5ZScgIC8vIHRoZSBleHBsaWNpdCBVVEYtOCBieXRlcw==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&#34;æ—¥æœ¬èªž&#34;                                 // UTF-8 input text
&#39;æ—¥æœ¬èªž&#39;                                 // UTF-8 input text as byte sequence
&#34;\u65e5\u672c\u8a9e&#34;                    // the explicit Unicode code points
&#34;\U000065e5\U0000672c\U00008a9e&#34;        // the explicit Unicode code points
&#39;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&#39;  // the explicit UTF-8 bytes</code></pre></div>
</div>
<p>If the source code represents a character as two code points, such as a
combining form involving an accent and a letter, the result will appear as two
code points if placed in a string literal.</p>
<p>Strings and byte sequences have a multiline equivalent.
Multiline strings are like their single-line equivalent,
but allow newline characters.</p>
<p>Multiline strings and byte sequences respectively start with
a triple double quote (<code>&quot;&quot;&quot;</code>) or triple single quote (<code>'''</code>),
immediately followed by a newline, which is discarded from the string contents.
The string is closed by a matching triple quote, which must be by itself
on a new line, preceded by optional whitespace.
The newline preceding the closing quote is discarded from the string contents.
The whitespace before a closing triple quote must appear before any non-empty
line after the opening quote and will be removed from each of these
lines in the string literal.
A closing triple quote may not appear in the string.
To include it is suffices to escape one of the quotes.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="IiIiCiAgICBsaWx5OgogICAgb3V0IG9mIHRoZSB3YXRlcgogICAgb3V0IG9mIGl0c2VsZgoKICAgIGJhc3MKICAgIHBpY2tpbmcgXAogICAgYnVncwogICAgb2ZmIHRoZSBtb29uCiAgICAgICAg4oCU4oCJTmljayBWaXJnaWxpbywgU2VsZWN0ZWQgSGFpa3UsIDE5ODgKICAgICIiIg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&#34;&#34;&#34;
    lily:
    out of the water
    out of itself

    bass
    picking \
    bugs
    off the moon
        â€”â€‰Nick Virgilio, Selected Haiku, 1988
    &#34;&#34;&#34;</code></pre></div>
</div>
<p>This represents the same string as:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="ImxpbHk6XG5vdXQgb2YgdGhlIHdhdGVyXG5vdXQgb2YgaXRzZWxmXG5cbiIgKwoiYmFzc1xucGlja2luZyBidWdzXG5vZmYgdGhlIG1vb25cbiIgKwoiICAgIOKAlOKAiU5pY2sgVmlyZ2lsaW8sIFNlbGVjdGVkIEhhaWt1LCAxOTg4Ig==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&#34;lily:\nout of the water\nout of itself\n\n&#34; +
&#34;bass\npicking bugs\noff the moon\n&#34; +
&#34;    â€”â€‰Nick Virgilio, Selected Haiku, 1988&#34;</code></pre></div>
</div>
<!-- TODO: other values

Support for other values:
- Duration literals
- regular expressions: `re("[a-z]")`
-->
<h2 id="values-1">
    <a href="#values-1" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Values</h2>
<p>In addition to simple values like <code>&quot;hello&quot;</code> and <code>42.0</code>, CUE has <a href="/docs/reference/spec/#structs">structs</a>.
A struct is a map from labels to values, like <code>{a: 42.0, b: &quot;hello&quot;}</code>.
Structs are CUE&rsquo;s only way of building up complex values;
lists, which we will see later,
are defined in terms of structs.</p>
<p>All possible values are ordered in a lattice,
a partial order where every two elements have a single greatest lower bound.
A value <code>a</code> is an <em>instance</em> of a value <code>b</code>,
denoted <code>a âŠ‘ b</code>, if <code>b == a</code> or <code>b</code> is more general than <code>a</code>,
that is if <code>a</code> orders before <code>b</code> in the partial order
(<code>âŠ‘</code> is <em>not</em> a CUE operator).
We also say that <code>b</code> <em>subsumes</em> <code>a</code> in this case.
In graphical terms, <code>b</code> is &ldquo;above&rdquo; <code>a</code> in the lattice.</p>
<!-- TODO: link to https://cuelang.org/docs/concepts/logic/ as more reading
material, especially for those new to lattices
-->
<p>At the top of the lattice is the single ancestor of all values, called
<a href="/docs/reference/spec/#top">top</a>, denoted <code>_</code> in CUE.
Every value is an instance of top.</p>
<p>At the bottom of the lattice is the value called <a href="/docs/reference/spec/#bottom">bottom</a>, denoted <code>_|_</code>.
A bottom value usually indicates an error.
Bottom is an instance of every value.</p>
<p>An <em>atom</em> is any value whose only instances are itself and bottom.
Examples of atoms are <code>42.0</code>, <code>&quot;hello&quot;</code>, <code>true</code>, and <code>null</code>.</p>
<p>A value is <em>concrete</em> if it is either an atom, or a struct whose field values
are all concrete, recursively.</p>
<p>CUE&rsquo;s values also include what we normally think of as types, like <code>string</code> and
<code>float</code>.
It does not distinguish between types and values:
only the relationship of values in the lattice is important.
Each CUE &ldquo;type&rdquo; subsumes the concrete values that one would normally think
of as part of that type.
For example, <code>&quot;hello&quot;</code> is an instance of <code>string</code>, and <code>42.0</code> is an instance of
<code>float</code>.
In addition to <code>string</code> and <code>float</code>, CUE has <code>null</code>, <code>int</code>, <code>bool</code>, and <code>bytes</code>.
We informally call these CUE&rsquo;s &ldquo;basic types&rdquo;.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="ZmFsc2Ug4oqRIGJvb2wKdHJ1ZSAg4oqRIGJvb2wKdHJ1ZSAg4oqRIHRydWUKNS4wICAg4oqRIGZsb2F0CmJvb2wgIOKKkSBfCl98XyAgIOKKkSBfCl98XyAgIOKKkSBffF8KCl8gICAgIOKLoiBffF8KXyAgICAg4ouiIGJvb2wKaW50ICAg4ouiIGJvb2wKYm9vbCAg4ouiIGludApmYWxzZSDii6IgdHJ1ZQp0cnVlICDii6IgZmFsc2UKZmxvYXQg4ouiIDUuMAo1ICAgICDii6IgNg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>false âŠ‘ bool
true  âŠ‘ bool
true  âŠ‘ true
5.0   âŠ‘ float
bool  âŠ‘ _
_|_   âŠ‘ _
_|_   âŠ‘ _|_

_     â‹¢ _|_
_     â‹¢ bool
int   â‹¢ bool
bool  â‹¢ int
false â‹¢ true
true  â‹¢ false
float â‹¢ 5.0
5     â‹¢ 6</code></pre></div>
</div>
<h3 id="unification">
    <a href="#unification" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Unification</h3>
<p>The <em>unification</em> of values <code>a</code> and <code>b</code>
is defined as the greatest lower bound of <code>a</code> and <code>b</code>. (That is, the
value <code>u</code> such that <code>u âŠ‘ a</code> and <code>u âŠ‘ b</code>,
and for any other value <code>v</code> for which <code>v âŠ‘ a</code> and <code>v âŠ‘ b</code>
it holds that <code>v âŠ‘ u</code>.)
Since CUE values form a lattice, the unification of two CUE values is
always unique.</p>
<p>These all follow from the definition of unification:</p>
<ul>
<li>The unification of <code>a</code> with itself is always <code>a</code>.</li>
<li>The unification of values <code>a</code> and <code>b</code> where <code>a âŠ‘ b</code> is always <code>a</code>.</li>
<li>The unification of a value with bottom is always bottom.</li>
</ul>
<p>Unification in CUE is a <a href="/docs/reference/spec/#operands">binary expression</a>, written <code>a &amp; b</code>.
It is commutative, associative, and idempotent.
As a consequence, order of evaluation is irrelevant, a property that is key
to many of the constructs in the CUE language as well as the tooling layered
on top of it.</p>
<!-- TODO: explicitly mention that disjunction is not a binary operation
but a definition of a single value?-->
<h3 id="disjunction">
    <a href="#disjunction" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Disjunction</h3>
<p>The <em>disjunction</em> of values <code>a</code> and <code>b</code>
is defined as the least upper bound of <code>a</code> and <code>b</code>.
(That is, the value <code>d</code> such that <code>a âŠ‘ d</code> and <code>b âŠ‘ d</code>,
and for any other value <code>e</code> for which <code>a âŠ‘ e</code> and <code>b âŠ‘ e</code>,
it holds that <code>d âŠ‘ e</code>.)
This style of disjunctions is sometimes also referred to as sum types.
Since CUE values form a lattice, the disjunction of two CUE values is always unique.</p>
<p>These all follow from the definition of disjunction:</p>
<ul>
<li>The disjunction of <code>a</code> with itself is always <code>a</code>.</li>
<li>The disjunction of a value <code>a</code> and <code>b</code> where <code>a âŠ‘ b</code> is always <code>b</code>.</li>
<li>The disjunction of a value <code>a</code> with bottom is always <code>a</code>.</li>
<li>The disjunction of two bottom values is bottom.</li>
</ul>
<p>Disjunction in CUE is a <a href="/docs/reference/spec/#operands">binary expression</a>, written <code>a | b</code>.
It is commutative, associative, and idempotent.</p>
<p>The unification of a disjunction with another value is equal to the disjunction
composed of the unification of this value with all of the original elements
of the disjunction.
In other words, unification distributes over disjunction.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="KGFfMCB8IC4uLiB8YV9uKSAmIGIgPT0&#43;IGFfMCZiIHwgLi4uIHwgYV9uJmIu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>(a_0 | ... |a_n) &amp; b ==&gt; a_0&amp;b | ... | a_n&amp;b.</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgICBSZXN1bHQKKHthOjF9IHwge2I6Mn0pICYge2M6M30gICB7YToxLCBjOjN9IHwge2I6MiwgYzozfQooaW50IHwgc3RyaW5nKSAmICJmb28iICAgICJmb28iCigiYSIgfCAiYiIpICYgImMiICAgICAgICAgX3xf">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression                Result
({a:1} | {b:2}) &amp; {c:3}   {a:1, c:3} | {b:2, c:3}
(int | string) &amp; &#34;foo&#34;    &#34;foo&#34;
(&#34;a&#34; | &#34;b&#34;) &amp; &#34;c&#34;         _|_</code></pre></div>
</div>
<p>A disjunction is <em>normalized</em> if there is no element
<code>a</code> for which there is an element <code>b</code> such that <code>a âŠ‘ b</code>.</p>
<!--
Normalization is important, as we need to account for spurious elements
For instance "tcp" | "tcp" should resolve to "tcp".

Also consider

  ({a:1} | {b:1}) & ({a:1} | {b:2}) -> {a:1} | {a:1,b:1} | {a:1,b:2},

in this case, elements {a:1,b:1} and {a:1,b:2} are subsumed by {a:1} and thus
this expression is logically equivalent to {a:1} and should therefore be
considered to be unambiguous and resolve to {a:1} if a concrete value is needed.

For instance, in

  x: ({a:1} | {b:1}) & ({a:1} | {b:2}) // -> {a:1} | {a:1,b:1} | {a:1,b:2}
  y: x.a // 1

y should resolve to 1, and not an error.

For comparison, in

  x: ({a:1, b:1} | {b:2}) & {a:1} // -> {a:1,b:1} | {a:1,b:2}
  y: x.a // _|_

y should be an error as x is still ambiguous before the selector is applied,
even though `a` resolves to 1 in all cases.
-->
<h4 id="default-values">
    <a href="#default-values" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Default values</h4>
<p>Any value <code>v</code> <em>may</em> be associated with a default value <code>d</code>,
where <code>d</code> must be in instance of <code>v</code> (<code>d âŠ‘ v</code>).</p>
<p>Default values are introduced by means of disjunctions.
Any element of a disjunction can be <em>marked</em> as a default
by prefixing it with an asterisk <code>*</code> (<a href="/docs/reference/spec/#operators">a unary expression</a>).
Syntactically consecutive disjunctions are considered to be
part of a single disjunction,
whereby multiple disjuncts can be marked as default.
A <em>marked disjunction</em> is one where any of its terms are marked.
So <code>a | b | *c | d</code> is a single marked disjunction of four terms,
whereas <code>a | (b | *c | d)</code> is an unmarked disjunction of two terms,
one of which is a marked disjunction of three terms.
During unification, if all the marked disjuncts of a marked disjunction are
eliminated, then the remaining unmarked disjuncts are considered as if they
originated from an unmarked disjunction</p>
<!-- TODO: this formulation should be worked out more.  -->
<p>As explained below, distinguishing the nesting of disjunctions like this
is only relevant when both an outer and nested disjunction are marked.</p>
<p>Intuitively, when an expression needs to be resolved for an operation other
than unification or disjunction,
non-starred elements are dropped in favor of starred ones if the starred ones
do not resolve to bottom.</p>
<p>To define the unification and disjunction operation we use the notation
<code>âŸ¨vâŸ©</code> to denote a CUE value <code>v</code> that is not associated with a default
and the notation <code>âŸ¨v, dâŸ©</code> to denote a value <code>v</code> associated with a default
value <code>d</code>.</p>
<p>The rewrite rules for unifying such values are as follows:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="VTA6IOKfqHYx4p&#43;pICYg4p&#43;odjLin6kgICAgICAgICA9PiDin6h2MSZ2MuKfqQpVMTog4p&#43;odjEsIGQx4p&#43;pICYg4p&#43;odjLin6kgICAgID0&#43;IOKfqHYxJnYyLCBkMSZ2MuKfqQpVMjog4p&#43;odjEsIGQx4p&#43;pICYg4p&#43;odjIsIGQy4p&#43;pID0&#43;IOKfqHYxJnYyLCBkMSZkMuKfqQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>U0: âŸ¨v1âŸ© &amp; âŸ¨v2âŸ©         =&gt; âŸ¨v1&amp;v2âŸ©
U1: âŸ¨v1, d1âŸ© &amp; âŸ¨v2âŸ©     =&gt; âŸ¨v1&amp;v2, d1&amp;v2âŸ©
U2: âŸ¨v1, d1âŸ© &amp; âŸ¨v2, d2âŸ© =&gt; âŸ¨v1&amp;v2, d1&amp;d2âŸ©</code></pre></div>
</div>
<p>The rewrite rules for disjoining terms of unmarked disjunctions are</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RDA6IOKfqHYx4p&#43;pIHwg4p&#43;odjLin6kgICAgICAgICA9PiDin6h2MXx2MuKfqQpEMTog4p&#43;odjEsIGQx4p&#43;pIHwg4p&#43;odjLin6kgICAgID0&#43;IOKfqHYxfHYyLCBkMeKfqQpEMjog4p&#43;odjEsIGQx4p&#43;pIHwg4p&#43;odjIsIGQy4p&#43;pID0&#43;IOKfqHYxfHYyLCBkMXxkMuKfqQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>D0: âŸ¨v1âŸ© | âŸ¨v2âŸ©         =&gt; âŸ¨v1|v2âŸ©
D1: âŸ¨v1, d1âŸ© | âŸ¨v2âŸ©     =&gt; âŸ¨v1|v2, d1âŸ©
D2: âŸ¨v1, d1âŸ© | âŸ¨v2, d2âŸ© =&gt; âŸ¨v1|v2, d1|d2âŸ©</code></pre></div>
</div>
<p>Terms of marked disjunctions are first rewritten according to the following
rules:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="TTA6ICDin6h24p&#43;pICAgID0&#43;IOKfqHbin6kgICAgICAgIGRvbid0IGludHJvZHVjZSBkZWZhdWx0cyBmb3IgdW5tYXJrZWQgdGVybQpNMTogKuKfqHbin6kgICAgPT4g4p&#43;odiwgduKfqSAgICAgaW50cm9kdWNlIGlkZW50aWNhbCBkZWZhdWx0IGZvciBtYXJrZWQgdGVybQpNMjogKuKfqHYsIGTin6kgPT4g4p&#43;odiwgZOKfqSAgICAga2VlcCBleGlzdGluZyBkZWZhdWx0cyBmb3IgbWFya2VkIHRlcm0KTTM6ICDin6h2LCBk4p&#43;pID0&#43;IOKfqHbin6kgICAgICAgIHN0cmlwIGV4aXN0aW5nIGRlZmF1bHRzIGZyb20gdW5tYXJrZWQgdGVybQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>M0:  âŸ¨vâŸ©    =&gt; âŸ¨vâŸ©        don&#39;t introduce defaults for unmarked term
M1: *âŸ¨vâŸ©    =&gt; âŸ¨v, vâŸ©     introduce identical default for marked term
M2: *âŸ¨v, dâŸ© =&gt; âŸ¨v, dâŸ©     keep existing defaults for marked term
M3:  âŸ¨v, dâŸ© =&gt; âŸ¨vâŸ©        strip existing defaults from unmarked term</code></pre></div>
</div>
<p>Note that for any marked disjunction <code>a</code>,
the expressions <code>a|a</code>, <code>*a|a</code> and <code>*a|*a</code> all resolve to <code>a</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgIFZhbHVlLWRlZmF1bHQgcGFpciAgICAgUnVsZXMgYXBwbGllZAoqInRjcCIgfCAidWRwIiAgICAgICAgICAg4p&#43;oInRjcCJ8InVkcCIsICJ0Y3Ai4p&#43;pICAgIE0xLCBEMQpzdHJpbmcgfCAqImZvbyIgICAgICAgICAg4p&#43;oc3RyaW5nLCAiZm9vIuKfqSAgICAgICAgIE0xLCBEMQoKKjEgfCAyIHwgMyAgICAgICAgICAgICAgIOKfqDF8MnwzLCAx4p&#43;pICAgICAgICAgICAgICBNMSwgRDEKCigqMXwyfDMpIHwgKDF8KjJ8MykgICAgICDin6gxfDJ8MywgMXwy4p&#43;pICAgICAgICAgICAgTTEsIEQxLCBEMgooKjF8MnwzKSB8ICooMXwqMnwzKSAgICAg4p&#43;oMXwyfDMsIDLin6kgICAgICAgICAgICAgIE0xLCBNMiwgTTMsIEQxLCBEMgooKjF8MnwzKSB8ICgxfCoyfDMpJjIgICAg4p&#43;oMXwyfDMsIDF8MuKfqSAgICAgICAgICAgIE0xLCBEMSwgVTEsIEQyCgooKjF8MikgJiAoMXwqMikgICAgICAgICAg4p&#43;oMXwyLCBffF/in6kgICAgICAgICAgICAgIE0xLCBEMSwgVTI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression               Value-default pair     Rules applied
*&#34;tcp&#34; | &#34;udp&#34;           âŸ¨&#34;tcp&#34;|&#34;udp&#34;, &#34;tcp&#34;âŸ©    M1, D1
string | *&#34;foo&#34;          âŸ¨string, &#34;foo&#34;âŸ©         M1, D1

*1 | 2 | 3               âŸ¨1|2|3, 1âŸ©              M1, D1

(*1|2|3) | (1|*2|3)      âŸ¨1|2|3, 1|2âŸ©            M1, D1, D2
(*1|2|3) | *(1|*2|3)     âŸ¨1|2|3, 2âŸ©              M1, M2, M3, D1, D2
(*1|2|3) | (1|*2|3)&amp;2    âŸ¨1|2|3, 1|2âŸ©            M1, D1, U1, D2

(*1|2) &amp; (1|*2)          âŸ¨1|2, _|_âŸ©              M1, D1, U2</code></pre></div>
</div>
<!-- TODO: define and consistently use the value-default pair syntax -->
<p>The rules of subsumption for defaults can be derived from the above definitions
and are as follows.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="4p&#43;odjIsIGQy4p&#43;pIOKKkSDin6h2MSwgZDHin6kgIGlmIHYyIOKKkSB2MSBhbmQgZDIg4oqRIGQxCuKfqHYxLCBkMeKfqSDiipEg4p&#43;oduKfqSAgICAgICBpZiB2MSDiipEgdgrin6h24p&#43;pICAgICAg4oqRIOKfqHYxLCBkMeKfqSAgaWYgdiDiipEgZDE=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>âŸ¨v2, d2âŸ© âŠ‘ âŸ¨v1, d1âŸ©  if v2 âŠ‘ v1 and d2 âŠ‘ d1
âŸ¨v1, d1âŸ© âŠ‘ âŸ¨vâŸ©       if v1 âŠ‘ v
âŸ¨vâŸ©      âŠ‘ âŸ¨v1, d1âŸ©  if v âŠ‘ d1</code></pre></div>
</div>
<!--
For the second rule, note that by definition d1 âŠ‘ v1, so d1 âŠ‘ v1 âŠ‘ v.

The last one is so restrictive as v could still be made more specific by
associating it with a default that is not subsumed by d1.

Proof:
  by definition for any d âŠ‘ v, it holds that (v, d) âŠ‘ v,
  where the most general value is (v, v).
  Given the subsumption rule for (v2, d2) âŠ‘ (v1, d1),
  from (v, v) âŠ‘ v âŠ‘ (v1, d1) it follows that v âŠ‘ d1
  exactly defines the boundary of this subsumption.
-->
<!--
(non-normalized entries could also be implicitly marked, allowing writing
int | 1, instead of int | *1, but that can be done in a backwards
compatible way later if really desirable, as long as we require that
disjunction literals be normalized).
-->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgICAgICAgICAgUmVzb2x2ZXMgdG8KInRjcCIgfCAidWRwIiAgICAgICAgICAgICAgICAgICAgInRjcCIgfCAidWRwIgoqInRjcCIgfCAidWRwIiAgICAgICAgICAgICAgICAgICAidGNwIgpmbG9hdCB8ICoxICAgICAgICAgICAgICAgICAgICAgICAxCipzdHJpbmcgfCAxLjAgICAgICAgICAgICAgICAgICAgIHN0cmluZwooKjF8MikgKyAoMnwqMykgICAgICAgICAgICAgICAgICA0CgooKjF8MnwzKSB8ICgxfCoyfDMpICAgICAgICAgICAgICAxfDIKKCoxfDJ8MykgJiAoMXwqMnwzKSAgICAgICAgICAgICAgMXwyfDMgLy8gZGVmYXVsdCBpcyBffF8KCigqID49NSB8IGludCkgJiAoKiA8PTUgfCBpbnQpICAgIDUKCigqInRjcCJ8InVkcCIpICYgKCJ1ZHAifCoidGNwIikgICJ0Y3AiCigqInRjcCJ8InVkcCIpICYgKCJ1ZHAifCJ0Y3AiKSAgICJ0Y3AiCigqInRjcCJ8InVkcCIpICYgInRjcCIgICAgICAgICAgICJ0Y3AiCigqInRjcCJ8InVkcCIpICYgKCoidWRwInwidGNwIikgICJ0Y3AiIHwgInVkcCIgLy8gZGVmYXVsdCBpcyBffF8KCigqdHJ1ZSB8IGZhbHNlKSAmIGJvb2wgICAgICAgICAgIHRydWUKKCp0cnVlIHwgZmFsc2UpICYgKHRydWUgfCBmYWxzZSkgdHJ1ZQoKe2E6IDF9IHwge2I6IDF9ICAgICAgICAgICAgICAgICAge2E6IDF9IHwge2I6IDF9CnthOiAxfSB8ICp7YjogMX0gICAgICAgICAgICAgICAgIHtiOjF9Cip7YTogMX0gfCAqe2I6IDF9ICAgICAgICAgICAgICAgIHthOiAxfSB8IHtiOiAxfQooe2E6IDF9IHwge2I6IDF9KSAmIHthOjF9ICAgICAgICB7YToxfSAgfCB7YTogMSwgYjogMX0KKHthOjF9fCp7YjoxfSkgJiAoe2E6MX18KntiOjF9KSAge2I6MX0=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression                       Resolves to
&#34;tcp&#34; | &#34;udp&#34;                    &#34;tcp&#34; | &#34;udp&#34;
*&#34;tcp&#34; | &#34;udp&#34;                   &#34;tcp&#34;
float | *1                       1
*string | 1.0                    string
(*1|2) + (2|*3)                  4

(*1|2|3) | (1|*2|3)              1|2
(*1|2|3) &amp; (1|*2|3)              1|2|3 // default is _|_

(* &gt;=5 | int) &amp; (* &lt;=5 | int)    5

(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (&#34;udp&#34;|*&#34;tcp&#34;)  &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (&#34;udp&#34;|&#34;tcp&#34;)   &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; &#34;tcp&#34;           &#34;tcp&#34;
(*&#34;tcp&#34;|&#34;udp&#34;) &amp; (*&#34;udp&#34;|&#34;tcp&#34;)  &#34;tcp&#34; | &#34;udp&#34; // default is _|_

(*true | false) &amp; bool           true
(*true | false) &amp; (true | false) true

{a: 1} | {b: 1}                  {a: 1} | {b: 1}
{a: 1} | *{b: 1}                 {b:1}
*{a: 1} | *{b: 1}                {a: 1} | {b: 1}
({a: 1} | {b: 1}) &amp; {a:1}        {a:1}  | {a: 1, b: 1}
({a:1}|*{b:1}) &amp; ({a:1}|*{b:1})  {b:1}</code></pre></div>
</div>
<h3 id="bottom-and-errors">
    <a href="#bottom-and-errors" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Bottom and errors</h3>
<p>Any evaluation error in CUE results in a bottom value, represented by
the token <code>_|_</code>.
Bottom is an instance of every other value.
Any evaluation error is represented as bottom.</p>
<p>Implementations may associate error strings with different instances of bottom;
logically they all remain the same value.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ym90dG9tX2xpdCA9ICJffF8iIC4=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>bottom_lit = &#34;_|_&#34; .</code></pre></div>
</div>
<h3 id="top">
    <a href="#top" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Top</h3>
<p>Top is represented by the underscore character <code>_</code>, lexically an identifier.
Unifying any value <code>v</code> with top results in <code>v</code> itself.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwciAgICAgICAgUmVzdWx0Cl8gJiAgNSAgICAgICAgNQpfICYgIF8gICAgICAgIF8KXyAmIF98XyAgICAgIF98XwpfIHwgX3xfICAgICAgIF8=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expr        Result
_ &amp;  5        5
_ &amp;  _        _
_ &amp; _|_      _|_
_ | _|_       _</code></pre></div>
</div>
<h3 id="null">
    <a href="#null" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Null</h3>
<p>The <em>null value</em> is represented with the keyword <code>null</code>.
It has only one parent, top, and one child, bottom.
It is unordered with respect to any other value.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bnVsbF9saXQgICA9ICJudWxsIiAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>null_lit   = &#34;null&#34; .</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bnVsbCAmIDggICAgIF98XwpudWxsICYgXyAgICAgbnVsbApudWxsICYgX3xfICAgX3xf">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>null &amp; 8     _|_
null &amp; _     null
null &amp; _|_   _|_</code></pre></div>
</div>
<h3 id="boolean-values">
    <a href="#boolean-values" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Boolean values</h3>
<p>A <em>boolean type</em> represents the set of Boolean truth values denoted by
the keywords <code>true</code> and <code>false</code>.
The predeclared boolean type is <code>bool</code>; it is a defined type and a separate
element in the lattice.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ym9vbF9saXQgPSAidHJ1ZSIgfCAiZmFsc2UiIC4=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>bool_lit = &#34;true&#34; | &#34;false&#34; .</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ym9vbCAmIHRydWUgICAgICAgICAgdHJ1ZQp0cnVlICYgdHJ1ZSAgICAgICAgICB0cnVlCnRydWUgJiBmYWxzZSAgICAgICAgIF98Xwpib29sICYgKGZhbHNlfHRydWUpICBmYWxzZSB8IHRydWUKYm9vbCAmICh0cnVlfGZhbHNlKSAgdHJ1ZSB8IGZhbHNl">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>bool &amp; true          true
true &amp; true          true
true &amp; false         _|_
bool &amp; (false|true)  false | true
bool &amp; (true|false)  true | false</code></pre></div>
</div>
<h3 id="numeric-values">
    <a href="#numeric-values" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Numeric values</h3>
<p>The <em>integer type</em> represents the set of all integral numbers.
The <em>decimal floating-point type</em> represents the set of all decimal floating-point
numbers.
They are two distinct types.
Both are instances instances of a generic <code>number</code> type.</p>
<!--
TODO: would be nice to make this a rendered diagram with Mermaid.

                    number
                   /      \
                int      float
-->
<p>The predeclared number, integer, and decimal floating-point types are
<code>number</code>, <code>int</code> and <code>float</code>; they are defined types.</p>
<!--
TODO: should we drop float? It is somewhat preciser and probably a good idea
to have it in the programmatic API, but it may be confusing to have to deal
with it in the language.
-->
<p>A decimal floating-point literal always has type <code>float</code>;
it is not an instance of <code>int</code> even if it is an integral number.</p>
<p>Integer literals are always of type <code>int</code> and don&rsquo;t match type <code>float</code>.</p>
<p>Numeric literals are exact values of arbitrary precision.
If the operation permits it, numbers should be kept in arbitrary precision.</p>
<p>Implementation restriction: although numeric values have arbitrary precision
in the language, implementations may implement them using an internal
representation with limited precision.
That said, every implementation must:</p>
<ul>
<li>Represent integer values with at least 256 bits.</li>
<li>Represent floating-point values with a mantissa of at least 256 bits and
a signed binary exponent of at least 16 bits.</li>
<li>Give an error if unable to represent an integer value precisely.</li>
<li>Give an error if unable to represent a floating-point value due to overflow.</li>
<li>Round to the nearest representable value if unable to represent
a floating-point value due to limits on precision.
These requirements apply to the result of any expression except for builtin
functions, for which an unusual loss of precision must be explicitly documented.</li>
</ul>
<h3 id="strings">
    <a href="#strings" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Strings</h3>
<p>The <em>string type</em> represents the set of UTF-8 strings,
not allowing surrogates.
The predeclared string type is <code>string</code>; it is a defined type.</p>
<p>The length of a string <code>s</code> (its size in bytes) can be discovered using
the builtin function <code>len</code>.</p>
<h3 id="bytes">
    <a href="#bytes" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Bytes</h3>
<p>The <em>bytes type</em> represents the set of byte sequences.
A byte sequence value is a (possibly empty) sequence of bytes.
The number of bytes is called the length of the byte sequence
and is never negative.
The predeclared byte sequence type is <code>bytes</code>; it is a defined type.</p>
<h3 id="bounds">
    <a href="#bounds" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Bounds</h3>
<p>A <em>bound</em>, syntactically a <a href="/docs/reference/spec/#operands">unary expression</a>, defines
a logically infinite disjunction of concrete values represented as a single comparison.
For example, <code>&gt;= 2</code> represents the infinite disjunction <code>2|3|4|5|6|7|â€¦</code>.</p>
<p>For any <a href="/docs/reference/spec/#comparison-operators">comparison operator</a> <code>op</code> except <code>==</code>,
<code>op a</code> is the disjunction of every <code>x</code> such that <code>x op a</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="MiAmID49MiAmIDw9NSAgICAgICAgICAgLy8gMiwgd2hlcmUgMiBpcyBlaXRoZXIgYW4gaW50IG9yIGZsb2F0LgoyLjUgJiA&#43;PTEgJiA8PTUgICAgICAgICAvLyAyLjUKMiAmID49MS4wICYgPDMuMCAgICAgICAgLy8gMi4wCjIgJiA&#43;MSAmIDwzLjAgICAgICAgICAgIC8vIDIuMAoyLjUgJiBpbnQgJiA&#43;MSAmIDw1ICAgICAvLyBffF8KMi41ICYgZmxvYXQgJiA&#43;MSAmIDw1ICAgLy8gMi41CmludCAmIDIgJiA&#43;MS4wICYgPDMuMCAgIC8vIF98XwoyLjUgJiA&#43;PShpbnQgJiAxKSAmIDw1ICAvLyBffF8KPj0wICYgPD03ICYgPj0zICYgPD0xMCAgLy8gPj0zICYgPD03CiE9bnVsbCAmIDEgICAgICAgICAgICAgIC8vIDEKPj01ICYgPD01ICAgICAgICAgICAgICAgLy8gNQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>2 &amp; &gt;=2 &amp; &lt;=5           // 2, where 2 is either an int or float.
2.5 &amp; &gt;=1 &amp; &lt;=5         // 2.5
2 &amp; &gt;=1.0 &amp; &lt;3.0        // 2.0
2 &amp; &gt;1 &amp; &lt;3.0           // 2.0
2.5 &amp; int &amp; &gt;1 &amp; &lt;5     // _|_
2.5 &amp; float &amp; &gt;1 &amp; &lt;5   // 2.5
int &amp; 2 &amp; &gt;1.0 &amp; &lt;3.0   // _|_
2.5 &amp; &gt;=(int &amp; 1) &amp; &lt;5  // _|_
&gt;=0 &amp; &lt;=7 &amp; &gt;=3 &amp; &lt;=10  // &gt;=3 &amp; &lt;=7
!=null &amp; 1              // 1
&gt;=5 &amp; &lt;=5               // 5</code></pre></div>
</div>
<h3 id="structs">
    <a href="#structs" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Structs</h3>
<p>A <em>struct</em> is a set of elements called <em>fields</em>, each of
which has a name, called a <em>label</em>, and value.</p>
<p>We say a label is <em>defined</em> for a struct if the struct has a field with the
corresponding label.
The value for a label <code>f</code> of struct <code>a</code> is denoted <code>a.f</code>.
A struct <code>a</code> is an instance of <code>b</code>, or <code>a âŠ‘ b</code>, if for any label <code>f</code>
defined for <code>b</code>, label <code>f</code> is also defined for <code>a</code> and <code>a.f âŠ‘ b.f</code>.
Note that if <code>a</code> is an instance of <code>b</code> it may have fields with labels that
are not defined for <code>b</code>.</p>
<p>The (unique) struct with no fields, written <code>{}</code>, has every struct as an
instance. It can be considered the type of all structs.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="e2E6IDF9IOKKkSB7fQp7YTogMSwgYjogMX0g4oqRIHthOiAxfQp7YTogMX0g4oqRIHthOiBpbnR9CnthOiAxLCBiOiAxLjB9IOKKkSB7YTogaW50LCBiOiBudW1iZXJ9Cgp7fSDii6Ige2E6IDF9CnthOiAyfSDii6Ige2E6IDF9CnthOiAxfSDii6Ige2I6IDF9">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>{a: 1} âŠ‘ {}
{a: 1, b: 1} âŠ‘ {a: 1}
{a: 1} âŠ‘ {a: int}
{a: 1, b: 1.0} âŠ‘ {a: int, b: number}

{} â‹¢ {a: 1}
{a: 2} â‹¢ {a: 1}
{a: 1} â‹¢ {b: 1}</code></pre></div>
</div>
<p>The successful unification of structs <code>a</code> and <code>b</code> is a new struct <code>c</code> which
has all fields of both <code>a</code> and <code>b</code>, where
the value of a field <code>f</code> in <code>c</code> is <code>a.f &amp; b.f</code> if <code>f</code> is defined in both <code>a</code> and <code>b</code>,
or just <code>a.f</code> or <code>b.f</code> if <code>f</code> is in just <code>a</code> or <code>b</code>, respectively.
Any <a href="/docs/reference/spec/#references">references</a> to <code>a</code> or <code>b</code>
in their respective field values need to be replaced with references to <code>c</code>.
The result of a unification is bottom (<code>_|_</code>) if any of its defined
fields evaluates to bottom, recursively.</p>
<p>A struct literal may contain multiple fields with the same label,
the result of which is the unification of all those fields.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="U3RydWN0TGl0ICAgICAgID0gInsiIHsgRGVjbGFyYXRpb24gIiwiIH0gIn0iIC4KRGVjbGFyYXRpb24gICAgID0gRmllbGQgfCBFbGxpcHNpcyB8IEVtYmVkZGluZyB8IExldENsYXVzZSB8IGF0dHJpYnV0ZSAuCkVsbGlwc2lzICAgICAgICA9ICIuLi4iIFsgRXhwcmVzc2lvbiBdIC4KRW1iZWRkaW5nICAgICAgID0gQ29tcHJlaGVuc2lvbiB8IEFsaWFzRXhwciAuCkZpZWxkICAgICAgICAgICA9IExhYmVsICI6IiB7IExhYmVsICI6IiB9IEFsaWFzRXhwciB7IGF0dHJpYnV0ZSB9IC4KTGFiZWwgICAgICAgICAgID0gWyBpZGVudGlmaWVyICI9IiBdIExhYmVsRXhwciAuCkxhYmVsRXhwciAgICAgICA9IExhYmVsTmFtZSBbICI/IiB8ICIhIiBdIHwgIlsiIEFsaWFzRXhwciAiXSIgLgpMYWJlbE5hbWUgICAgICAgPSBpZGVudGlmaWVyIHwgc2ltcGxlX3N0cmluZ19saXQgfCAiKCIgQWxpYXNFeHByICIpIiAuCgphdHRyaWJ1dGUgICAgICAgPSAiQCIgaWRlbnRpZmllciAiKCIgYXR0cl90b2tlbnMgIikiIC4KYXR0cl90b2tlbnMgICAgID0geyBhdHRyX3Rva2VuIHwKICAgICAgICAgICAgICAgICAgICAiKCIgYXR0cl90b2tlbnMgIikiIHwKICAgICAgICAgICAgICAgICAgICAiWyIgYXR0cl90b2tlbnMgIl0iIHwKICAgICAgICAgICAgICAgICAgICAieyIgYXR0cl90b2tlbnMgIn0iIH0gLgphdHRyX3Rva2VuICAgICAgPSAvKiBhbnkgdG9rZW4gZXhjZXB0ICcoJywgJyknLCAnWycsICddJywgJ3snLCBvciAnfScgKi8=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>StructLit       = &#34;{&#34; { Declaration &#34;,&#34; } &#34;}&#34; .
Declaration     = Field | Ellipsis | Embedding | LetClause | attribute .
Ellipsis        = &#34;...&#34; [ Expression ] .
Embedding       = Comprehension | AliasExpr .
Field           = Label &#34;:&#34; { Label &#34;:&#34; } AliasExpr { attribute } .
Label           = [ identifier &#34;=&#34; ] LabelExpr .
LabelExpr       = LabelName [ &#34;?&#34; | &#34;!&#34; ] | &#34;[&#34; AliasExpr &#34;]&#34; .
LabelName       = identifier | simple_string_lit | &#34;(&#34; AliasExpr &#34;)&#34; .

attribute       = &#34;@&#34; identifier &#34;(&#34; attr_tokens &#34;)&#34; .
attr_tokens     = { attr_token |
                    &#34;(&#34; attr_tokens &#34;)&#34; |
                    &#34;[&#34; attr_tokens &#34;]&#34; |
                    &#34;{&#34; attr_tokens &#34;}&#34; } .
attr_token      = /* any token except &#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, or &#39;}&#39; */</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzdWx0CnthOiBpbnQsIGE6IDF9ICAgICAgICAgICAgICAgICAgICAgICAgIHthOiAxfQp7YTogaW50fSAmIHthOiAxfSAgICAgICAgICAgICAgICAgICAgICB7YTogMX0Ke2E6ID49MSAmIDw9N30gJiB7YTogPj01ICYgPD05fSAgICAgICAge2E6ID49NSAmIDw9N30Ke2E6ID49MSAmIDw9NywgYTogPj01ICYgPD05fSAgICAgICAgICAge2E6ID49NSAmIDw9N30KCnthOiAxfSAmIHtiOiAyfSAgICAgICAgICAgICAgICAgICAgICAgIHthOiAxLCBiOiAyfQp7YTogMSwgYjogaW50fSAmIHtiOiAyfSAgICAgICAgICAgICAgICB7YTogMSwgYjogMn0KCnthOiAxfSAmIHthOiAyfSAgICAgICAgICAgICAgICAgICAgICAgIF98Xw==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression                             Result
{a: int, a: 1}                         {a: 1}
{a: int} &amp; {a: 1}                      {a: 1}
{a: &gt;=1 &amp; &lt;=7} &amp; {a: &gt;=5 &amp; &lt;=9}        {a: &gt;=5 &amp; &lt;=7}
{a: &gt;=1 &amp; &lt;=7, a: &gt;=5 &amp; &lt;=9}           {a: &gt;=5 &amp; &lt;=7}

{a: 1} &amp; {b: 2}                        {a: 1, b: 2}
{a: 1, b: int} &amp; {b: 2}                {a: 1, b: 2}

{a: 1} &amp; {a: 2}                        _|_</code></pre></div>
</div>
<h4 id="field-constraints">
    <a href="#field-constraints" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Field constraints</h4>
<p>A struct may declare <em>field constraints</em> which define values
that should be unified with a given field once it is defined.
The existence of a field constraint declares, but does not define, that field.</p>
<p>Syntactically, a field is marked as a constraint
by following its label with an <em>optional</em> marker <code>?</code>
or <em>required</em> marker <code>!</code>.
These markers are not part of the field name.</p>
<p>A struct that has a required field constraint with a bottom value
evaluates to bottom.
An optional field constraint with a bottom value does <em>not</em> invalidate
the struct that contains it
as long as it is not unified with a defined field.</p>
<p>The subsumption relation for fields with the various markers is defined as</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="e2E6IHh9IOKKkSB7YSE6IHh9IOKKkSB7YT86IHh9">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>{a: x} âŠ‘ {a!: x} âŠ‘ {a?: x}</code></pre></div>
</div>
<p>for any given <code>x</code>.</p>
<p>Implementations may error upon encountering a required field constraint
when manifesting CUE as data.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzdWx0Cntmb28/OiAzfSAmIHtmb286IDN9ICAgICAgICAgICAgICAgICAgIHtmb286IDN9Cntmb28hOiAzfSAmIHtmb286IDN9ICAgICAgICAgICAgICAgICAgIHtmb286IDN9Cgp7Zm9vITogaW50fSAmIHtmb286IGludH0gICAgICAgICAgICAgICB7Zm9vOiAgaW50fQp7Zm9vITogaW50fSAmIHtmb28/OiA8MX0gICAgICAgICAgICAgICB7Zm9vITogPDF9Cntmb28hOiBpbnR9ICYge2ZvbzogPD0zfSAgICAgICAgICAgICAgIHtmb286ICA8PTN9Cntmb28hOiBpbnR9ICYge2ZvbzogM30gICAgICAgICAgICAgICAgIHtmb286ICAzfQoKe2ZvbyE6IDN9ICYge2ZvbzogaW50fSAgICAgICAgICAgICAgICAge2ZvbzogM30Ke2ZvbyE6IDN9ICYge2ZvbzogPD00fSAgICAgICAgICAgICAgICAge2ZvbzogM30KCntmb28/OiAxfSAmIHtmb28/OiAyfSAgICAgICAgICAgICAgICAgIHtmb28/OiBffF99IC8vIE5vIGVycm9yCntmb28/OiAxfSAmIHtmb28hOiAyfSAgICAgICAgICAgICAgICAgIF98Xwp7Zm9vPzogMX0gJiB7Zm9vOiAyfSAgICAgICAgICAgICAgICAgICBffF8=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression                             Result
{foo?: 3} &amp; {foo: 3}                   {foo: 3}
{foo!: 3} &amp; {foo: 3}                   {foo: 3}

{foo!: int} &amp; {foo: int}               {foo:  int}
{foo!: int} &amp; {foo?: &lt;1}               {foo!: &lt;1}
{foo!: int} &amp; {foo: &lt;=3}               {foo:  &lt;=3}
{foo!: int} &amp; {foo: 3}                 {foo:  3}

{foo!: 3} &amp; {foo: int}                 {foo: 3}
{foo!: 3} &amp; {foo: &lt;=4}                 {foo: 3}

{foo?: 1} &amp; {foo?: 2}                  {foo?: _|_} // No error
{foo?: 1} &amp; {foo!: 2}                  _|_
{foo?: 1} &amp; {foo: 2}                   _|_</code></pre></div>
</div>
<!-- see https://github.com/cue-lang/proposal/blob/main/designs/1951-required-fields-v2.md -->
<!--NOTE: About bottom values for optional fields being okay.

The proposition Â¬P is a close cousin of P â†’ âŠ¥ and is often used
as an approximation to avoid the issues of using not.
Bottom (âŠ¥) is also frequently used to mean undefined. This makes sense.
Consider `{a?: 2} & {a?: 3}`.
Both structs say `a` is optional; in other words, it may be omitted.
So we can still get a valid result by omitting `a`, even in
case of a conflict.

Granted, this definition may lead to confusing results, especially in
definitions, when tightening an optional field leads to unintentionally
discarding it.
It could be a role of vet checkers to identify such cases (and suggest users
to explicitly use `_|_` to discard a field, for instance).

TODO: These examples show also how field constraints interact with defaults.
Should we included this? Probably not necessary, as this is an orthogonal
concern.
```
Expression                             Result
a: { foo?: string }                    a: { foo?: string }
b: { foo: "bar" }                      b: { foo: "bar" }
c: { foo?: *"baz" | string }           c: { foo?: *"baz" | string }

d: a & b                               { foo: "bar" }
e: b & c                               { foo: "bar" }
f: a & c                               { foo?: *"baz" | string }
g: a & { foo?: number }                { foo?: _|_ } // This is fine
h: b & { foo?: number }                _|_
i: c & { foo: string }                 { foo: *"baz" | string }
```
-->
<h4 id="dynamic-fields">
    <a href="#dynamic-fields" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Dynamic fields</h4>
<p>A <em>dynamic field</em> is a field whose label is determined by
an expression wrapped in parentheses.
A dynamic field may be marked as optional or required.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzdWx0CmE6ICAgImZvbyIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6ICAgImZvbyIKYjogICAiYmFyIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjogICAiYmFyIgooYSk6ICJiYXoiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb286ICJiYXoiCgooYStiKTogInF1eCIgICAgICAgICAgICAgICAgICAgICAgICAgICBmb29iYXI6ICJxdXgiCgooYSk/OiBzdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICBmb28/OiBzdHJpbmcKKGIpITogc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFyITogc3RyaW5n">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression                             Result
a:   &#34;foo&#34;                             a:   &#34;foo&#34;
b:   &#34;bar&#34;                             b:   &#34;bar&#34;
(a): &#34;baz&#34;                             foo: &#34;baz&#34;

(a+b): &#34;qux&#34;                           foobar: &#34;qux&#34;

(a)?: string                           foo?: string
(b)!: string                           bar!: string</code></pre></div>
</div>
<h4 id="pattern-and-default-constraints">
    <a href="#pattern-and-default-constraints" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Pattern and default constraints</h4>
<p>A struct may define constraints that apply to a collection of fields.</p>
<p>A <em>pattern constraint</em>, denoted <code>[pattern]: value</code>, defines a pattern, which
is a value of type string, and a value to unify with fields whose label
unifies with the pattern.
For a given struct <code>a</code> with pattern constraint <code>[p]: v</code>, <code>v</code> is unified
with any field with name <code>f</code> in <code>a</code> for which <code>p &amp; f</code> is not bottom.
When unifying struct <code>a</code> and <code>b</code>,
any pattern constraint declared in <code>a</code> and <code>b</code>
are also declared in the result of unification.</p>
<!-- TODO: Update grammar and support this.
A pattern constraints with a pattern preceded by `...` indicates
the pattern can only matches fields in `b` for which there
exists no field in `a` with the same label.
-->
<p>Additionally, a <em>default constraint</em>, denoted <code>...value</code>, defines a value
to unify with any field for which there is no other declaration in a struct.
When unifying structs <code>a</code> and <code>b</code>,
a default constraint <code>...v</code> declared in <code>a</code>
defines that the value <code>v</code> should unify with any field in the resulting struct <code>c</code>
whose label does not unify with any of the patterns of the pattern
constraints defined for <code>a</code> <em>and</em> for which there exists no field declaration
in <code>a</code> with that label.
The token <code>...</code> is a shorthand for <code>..._</code>.
<em>Note</em>: default constraints of the form <code>..._</code> are not yet implemented.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogewogICAgZm9vOiAgICAgIHN0cmluZyAgLy8gZm9vIGlzIGEgc3RyaW5nCiAgICBbPX4iXmkiXTogaW50ICAgICAvLyBhbGwgb3RoZXIgZmllbGRzIHN0YXJ0aW5nIHdpdGggaSBhcmUgaW50ZWdlcnMKICAgIFs9fiJeYiJdOiBib29sICAgIC8vIGFsbCBvdGhlciBmaWVsZHMgc3RhcnRpbmcgd2l0aCBiIGFyZSBib29sZWFucwogICAgWz4iYyJdOiAgIHN0cmluZyAgLy8gYWxsIG90aGVyIGZpZWxkcyBsZXhpY2FsbHkgYWZ0ZXIgYyBhcmUgc3RyaW5ncwoKICAgIC4uLnN0cmluZyAgICAgICAgIC8vIGFsbCBvdGhlciBmaWVsZHMgbXVzdCBiZSBhIHN0cmluZy4gTm90ZTogZGVmYXVsdCBjb25zdHJhaW50cyBhcmUgbm90IHlldCBpbXBsZW1lbnRlZC4KfQoKYjogYSAmIHsKICAgIGkzOiAgICAzCiAgICBiYXI6ICAgdHJ1ZQogICAgb3RoZXI6ICJhIHN0cmluZyIKfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: {
    foo:      string  // foo is a string
    [=~&#34;^i&#34;]: int     // all other fields starting with i are integers
    [=~&#34;^b&#34;]: bool    // all other fields starting with b are booleans
    [&gt;&#34;c&#34;]:   string  // all other fields lexically after c are strings

    ...string         // all other fields must be a string. Note: default constraints are not yet implemented.
}

b: a &amp; {
    i3:    3
    bar:   true
    other: &#34;a string&#34;
}</code></pre></div>
</div>
<!--
TODO: are these two equivalent? Rog says that maybe you'll be able to refer
to optional fields at some point, which will never make sense for patterns.
Marcel says this is already mentioned elsewhere.

a: {
	["foo"]: int
	foo?: int
}
-->
<p>Concrete field labels may be an identifier or string, the latter of which may be
interpolated.
Fields with identifier labels can be referred to within the scope they are
defined, string labels cannot.
References within such interpolated strings are resolved within
the scope of the struct in which the label sequence is
defined and can reference concrete labels lexically preceding
the label within a label sequence.</p>
<!-- We allow this so that rewriting a CUE file to collapse or expand
field sequences has no impact on semantics.
-->
<!--TODO: first implementation round will not yet have expression labels

An ExpressionLabel sets a collection of optional fields to a field value.
By default it defines this value for all possible string labels.
An optional expression limits this to the set of optional fields which
labels match the expression.
-->
<!-- NOTE: if we allow ...Expr, as in list, it would mean something different. -->
<!-- NOTE:
A DefinitionDecl does not allow repeated labels. This is to avoid
any ambiguity or confusion about whether earlier path components
are to be interpreted as declarations or normal fields (they should
always be normal fields.)
-->
<!--NOTE:
The syntax has been deliberately restricted to allow for the following
future extensions and relaxations:
  - Allow omitting a "?" in an expression label to indicate a concrete
    string value (but maybe we want to use () for that).
  - Make the "?" in expression label optional if expression labels
    are always optional.
  - Or allow eliding the "?" if the expression has no references and
    is obviously not concrete (such as `[string]`).
  - The expression of an expression label may also indicate a struct with
    integer or even number labels
    (beware of imprecise computation in the latter).
      e.g. `{ [int]: string }` is a map of integers to strings.
  - Allow for associative lists (`foo [@.field]: {field: string}`)
  - The `...` notation can be extended analogously to that of a ListList,
    by allowing it to follow with an expression for the remaining properties.
    In that case it is no longer a shorthand for `[string]: _`, but rather
    would define the value for any other value for which there is no field
    defined.
    Like the definition with List, this is somewhat odd, but it allows the
    encoding of JSON schema's and (non-structural) OpenAPI's
    additionalProperties and additionalItems.
-->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="aW50TWFwOiBbc3RyaW5nXTogaW50CmludE1hcDogewogICAgdDE6IDQzCiAgICB0MjogMi40ICAvLyBlcnJvcjogMi40IGlzIG5vdCBhbiBpbnRlZ2VyCn0KCm5hbWVNYXA6IFtzdHJpbmddOiB7CiAgICBmaXJzdE5hbWU6IHN0cmluZwogICAgbmlja05hbWU6ICAqZmlyc3ROYW1lIHwgc3RyaW5nCn0KCm5hbWVNYXA6IGhhbms6IGZpcnN0TmFtZTogIkhhbmsi">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>intMap: [string]: int
intMap: {
    t1: 43
    t2: 2.4  // error: 2.4 is not an integer
}

nameMap: [string]: {
    firstName: string
    nickName:  *firstName | string
}

nameMap: hank: firstName: &#34;Hank&#34;</code></pre></div>
</div>
<p>The optional field set defined by <code>nameMap</code> matches every field,
in this case just <code>hank</code>, and unifies the associated constraint
with the matched field, resulting in:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bmFtZU1hcDogaGFuazogewogICAgZmlyc3ROYW1lOiAiSGFuayIKICAgIG5pY2tOYW1lOiAgIkhhbmsiCn0=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>nameMap: hank: {
    firstName: &#34;Hank&#34;
    nickName:  &#34;Hank&#34;
}</code></pre></div>
</div>
<h4 id="closed-structs">
    <a href="#closed-structs" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Closed structs</h4>
<p>By default, structs are open to adding fields.
Instances of an open struct <code>p</code> may contain fields not defined in <code>p</code>.
This is makes it easy to add fields, but can lead to bugs:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UzogewogICAgZmllbGQxOiBzdHJpbmcKfQoKUzE6IFMgJiB7IGZpZWxkMjogImZvbyIgfQoKLy8gUzEgaXMgeyBmaWVsZDE6IHN0cmluZywgZmllbGQyOiAiZm9vIiB9CgoKQTogewogICAgZmllbGQxOiBzdHJpbmcKICAgIGZpZWxkMjogc3RyaW5nCn0KCkExOiBBICYgewogICAgZmVpbGQxOiAiZm9vIiAgLy8gImZpZWxkMSIgd2FzIGFjY2lkZW50YWxseSBtaXNzcGVsbGVkCn0KCi8vIEExIGlzCi8vICAgIHsgZmllbGQxOiBzdHJpbmcsIGZpZWxkMjogc3RyaW5nLCBmZWlsZDE6ICJmb28iIH0KLy8gbm90IHRoZSBpbnRlbmRlZAovLyAgICB7IGZpZWxkMTogImZvbyIsIGZpZWxkMjogc3RyaW5nIH0=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>S: {
    field1: string
}

S1: S &amp; { field2: &#34;foo&#34; }

// S1 is { field1: string, field2: &#34;foo&#34; }


A: {
    field1: string
    field2: string
}

A1: A &amp; {
    feild1: &#34;foo&#34;  // &#34;field1&#34; was accidentally misspelled
}

// A1 is
//    { field1: string, field2: string, feild1: &#34;foo&#34; }
// not the intended
//    { field1: &#34;foo&#34;, field2: string }</code></pre></div>
</div>
<p>A <em>closed struct</em> <code>c</code> is a struct whose instances may not declare any field
with a name that does not match the name of a field
or the pattern of a pattern constraint defined in <code>c</code>.
Hidden fields are excluded from this limitation.
A struct that is the result of unifying any struct with a <a href="/docs/reference/spec/#structs"><code>...</code></a>
declaration is defined for all regular fields.
Closing a struct is equivalent to adding <code>..._|_</code> to it.</p>
<p>Syntactically, structs are closed explicitly with the <code>close</code> builtin or
implicitly and recursively by <a href="/docs/reference/spec/#definitions-and-hidden-fields">definitions</a>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="QTogY2xvc2UoewogICAgZmllbGQxOiBzdHJpbmcKICAgIGZpZWxkMjogc3RyaW5nCn0pCgpBMTogQSAmIHsKICAgIGZlaWxkMTogc3RyaW5nCn0gLy8gX3xfIGZlaWxkMSBub3QgZGVmaW5lZCBmb3IgQQoKQTI6IEEgJiB7CiAgICBmb3Igayx2IGluIHsgZmVpbGQxOiBzdHJpbmcgfSB7CiAgICAgICAgazogdgogICAgfQp9ICAvLyBffF8gZmVpbGQxIG5vdCBkZWZpbmVkIGZvciBBCgpDOiBjbG9zZSh7CiAgICBbX106IF8KfSkKCkMyOiBDICYgewogICAgZm9yIGssdiBpbiB7IHRoaXNJc0ZpbmU6IHN0cmluZyB9IHsKICAgICAgICAiXChrKSI6IHYKICAgIH0KfQoKRDogY2xvc2UoewogICAgLy8gVmFsdWVzIGdlbmVyYXRlZCBieSBjb21wcmVoZW5zaW9ucyBhcmUgdHJlYXRlZCBhcyBlbWJlZGRpbmdzLgogICAgZm9yIGssdiBpbiB7IHg6IHN0cmluZyB9IHsKICAgICAgICAiXChrKSI6IHYKICAgIH0KfSk=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>A: close({
    field1: string
    field2: string
})

A1: A &amp; {
    feild1: string
} // _|_ feild1 not defined for A

A2: A &amp; {
    for k,v in { feild1: string } {
        k: v
    }
}  // _|_ feild1 not defined for A

C: close({
    [_]: _
})

C2: C &amp; {
    for k,v in { thisIsFine: string } {
        &#34;\(k)&#34;: v
    }
}

D: close({
    // Values generated by comprehensions are treated as embeddings.
    for k,v in { x: string } {
        &#34;\(k)&#34;: v
    }
})</code></pre></div>
</div>
<!-- (jba) Somewhere it should be said that optional fields are only
     interesting inside closed structs. -->
<!-- TODO: move embedding section to above the previous one -->
<h4 id="embedding">
    <a href="#embedding" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Embedding</h4>
<p>A struct may contain an <em>embedded value</em>, an operand used as a declaration.
An embedded value of type struct is unified with the struct in which it is
embedded, but disregarding the restrictions imposed by closed structs.
So if an embedding resolves to a closed struct, the corresponding enclosing
struct will also be closed, but may have fields that are not allowed if
normal rules for closed structs were observed.</p>
<p>If an embedded value is not of type struct, the struct may only have
definitions or hidden fields. Regular fields are not allowed in such case.</p>
<p>The result of <code>{ A }</code> is <code>A</code> for any <code>A</code> (including definitions).</p>
<p>Syntactically, embeddings may be any expression.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UzE6IHsKICAgIGE6IDEKICAgIGI6IDIKICAgIHsKICAgICAgICBjOiAzCiAgICB9Cn0KLy8gUzEgaXMgeyBhOiAxLCBiOiAyLCBjOiAzIH0KClMyOiBjbG9zZSh7CiAgICBhOiAxCiAgICBiOiAyCiAgICB7CiAgICAgICAgYzogMwogICAgfQp9KQovLyBzYW1lIGFzIGNsb3NlKFMxKQoKUzM6IHsKICAgIGE6IDEKICAgIGI6IDIKICAgIGNsb3NlKHsKICAgICAgICBjOiAzCiAgICB9KQp9Ci8vIHNhbWUgYXMgUzI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>S1: {
    a: 1
    b: 2
    {
        c: 3
    }
}
// S1 is { a: 1, b: 2, c: 3 }

S2: close({
    a: 1
    b: 2
    {
        c: 3
    }
})
// same as close(S1)

S3: {
    a: 1
    b: 2
    close({
        c: 3
    })
}
// same as S2</code></pre></div>
</div>
<h4 id="definitions-and-hidden-fields">
    <a href="#definitions-and-hidden-fields" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Definitions and hidden fields</h4>
<p>A field is a <em>definition</em> if its identifier starts with <code>#</code> or <code>_#</code>.
A field is <em>hidden</em> if its identifier starts with a <code>_</code>.
All other fields are <em>regular</em>.</p>
<p>Definitions and hidden fields are not emitted when converting a CUE program
to data and are never required to be concrete.</p>
<p>Referencing a definition will recursively <a href="/docs/reference/spec/#closed-structs">close</a> it.
That is, a referenced definition will not unify with a struct
that would add a field anywhere within the definition that it does not
already define or explicitly allow with a pattern constraint or <code>...</code>.
<a href="/docs/reference/spec/#embedding">Embedding</a> allows bypassing this check.</p>
<p>If referencing a definition would always result in an error, implementations
may report this inconsistency at the point of its declaration.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="I015U3RydWN0OiB7CiAgICBzdWI6IGZpZWxkOiAgICBzdHJpbmcKfQoKI015U3RydWN0OiB7CiAgICBzdWI6IGVuYWJsZWQ/OiBib29sCn0KCm15VmFsdWU6ICNNeVN0cnVjdCAmIHsKICAgIHN1YjogZmVpbGQ6ICAgMiAgICAgLy8gZXJyb3IsIGZlaWxkIG5vdCBkZWZpbmVkIGluICNNeVN0cnVjdAogICAgc3ViOiBlbmFibGVkOiB0cnVlICAvLyBva2F5Cn0KCiNEOiB7CiAgICAjT25lT2YKCiAgICBjOiBpbnQgLy8gYWRkcyB0aGlzIGZpZWxkLgp9CgojT25lT2Y6IHsgYTogaW50IH0gfCB7IGI6IGludCB9CgoKRDE6ICNEICYgeyBhOiAxMiwgYzogMjIgfSAgLy8geyBhOiAxMiwgYzogMjIgfQpEMjogI0QgJiB7IGE6IDEyLCBiOiAzMyB9ICAvLyBffF8gLy8gY2Fubm90IGRlZmluZSBib3RoIGBhYCBhbmQgYGJg">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>#MyStruct: {
    sub: field:    string
}

#MyStruct: {
    sub: enabled?: bool
}

myValue: #MyStruct &amp; {
    sub: feild:   2     // error, feild not defined in #MyStruct
    sub: enabled: true  // okay
}

#D: {
    #OneOf

    c: int // adds this field.
}

#OneOf: { a: int } | { b: int }


D1: #D &amp; { a: 12, c: 22 }  // { a: 12, c: 22 }
D2: #D &amp; { a: 12, b: 33 }  // _|_ // cannot define both `a` and `b`</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="I0E6IHthOiBpbnR9CgpCOiB7CiAgICAjQQogICAgYjogYzogaW50Cn0KCng6IEIKeDogZDogMyAgLy8gbm90IGFsbG93ZWQsIGFzIGNsb3NlZCBieSBlbWJlZGRlZCAjQQoKeTogQi5iCnk6IGQ6IDMgIC8vIGFsbG93ZWQgYXMgbm90aGluZyBjbG9zZXMgYgoKI0I6IHsKICAgICNBCiAgICBiOiBjOiBpbnQKfQoKejogI0IuYgp6OiBkOiAzICAvLyBub3QgYWxsb3dlZCwgYXMgcmVmZXJlbmNpbmcgI0IgY2xvc2VzIGI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>#A: {a: int}

B: {
    #A
    b: c: int
}

x: B
x: d: 3  // not allowed, as closed by embedded #A

y: B.b
y: d: 3  // allowed as nothing closes b

#B: {
    #A
    b: c: int
}

z: #B.b
z: d: 3  // not allowed, as referencing #B closes b</code></pre></div>
</div>
<!---
JSON fields are usual camelCase. Clashes can be avoided by adopting the
convention that definitions be TitleCase. Unexported definitions are still
subject to clashes, but those are likely easier to resolve because they are
package internal.
--->
<h4 id="attributes">
    <a href="#attributes" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Attributes</h4>
<p>Attributes allow associating meta information with values.
Their primary purpose is to define mappings between CUE and
other representations.
Attributes do not influence the evaluation of CUE.</p>
<p>An attribute associates an identifier with a value, a balanced token sequence,
which is a sequence of CUE tokens with balanced brackets (<code>()</code>, <code>[]</code>, and <code>{}</code>).
The sequence may not contain interpolations.</p>
<p>Fields, structs and packages can be associated with a set of attributes.
Attributes accumulate during unification, but implementations may remove
duplicates that have the same source string representation.
The interpretation of an attribute, including the handling of multiple
attributes for a given identifier, is up to the consumer of the attribute.</p>
<p>Field attributes define additional information about a field,
such as a mapping to a protocol buffer <!-- TODO: add link --> tag or alternative
name of the field when mapping to a different language.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gUGFja2FnZSBhdHRyaWJ1dGUKQHByb3RvYnVmKHByb3RvMykKCm15U3RydWN0MTogewogICAgLy8gU3RydWN0IGF0dHJpYnV0ZToKICAgIEBqc29uc2NoZW1hKGlkPSJodHRwczovL2V4YW1wbGUub3JnL215c3RydWN0MS5qc29uIikKCiAgICAvLyBGaWVsZCBhdHRyaWJ1dGVzCiAgICBmaWVsZDogc3RyaW5nIEBnbyhGaWVsZCkKICAgIGF0dHI6ICBpbnQgICAgQHhtbCgsYXR0cikgQGdvKEF0dHIpCn0KCm15U3RydWN0MjogewogICAgZmllbGQ6IHN0cmluZyBAZ28oRmllbGQpCiAgICBhdHRyOiAgaW50ICAgIEB4bWwoYTEsYXR0cikgQGdvKEF0dHIpCn0KCkNvbWJpbmVkOiBteVN0cnVjdDEgJiBteVN0cnVjdDIKLy8gZmllbGQ6IHN0cmluZyBAZ28oRmllbGQpCi8vIGF0dHI6ICBpbnQgICAgQHhtbCgsYXR0cikgQHhtbChhMSxhdHRyKSBAZ28oQXR0cik=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// Package attribute
@protobuf(proto3)

myStruct1: {
    // Struct attribute:
    @jsonschema(id=&#34;https://example.org/mystruct1.json&#34;)

    // Field attributes
    field: string @go(Field)
    attr:  int    @xml(,attr) @go(Attr)
}

myStruct2: {
    field: string @go(Field)
    attr:  int    @xml(a1,attr) @go(Attr)
}

Combined: myStruct1 &amp; myStruct2
// field: string @go(Field)
// attr:  int    @xml(,attr) @xml(a1,attr) @go(Attr)</code></pre></div>
</div>
<h4 id="aliases">
    <a href="#aliases" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Aliases</h4>
<p>Aliases name values that can be referred to
within the <a href="/docs/reference/spec/#declarations-and-scopes">scope</a> in which they are declared.
The name of an alias must be unique within its scope.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="QWxpYXNFeHByICA9IFsgaWRlbnRpZmllciAiPSIgXSBFeHByZXNzaW9uIC4=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>AliasExpr  = [ identifier &#34;=&#34; ] Expression .</code></pre></div>
</div>
<p>Aliases can appear in several positions:</p>
<!--- TODO: consider allowing this. It should be considered whether
having field aliases isn't already sufficient.

As a declaration in a struct (`X=value`):

- binds identifier `X` to a value embedded within the struct.
--->
<p>In front of a Label (<code>X=label: value</code>):</p>
<ul>
<li>binds the identifier to the same value as <code>label</code> would be bound
to if it were a valid identifier.</li>
</ul>
<p>In front of a dynamic field (<code>X=(label): value</code>):</p>
<ul>
<li>binds the identifier to the same value as <code>label</code> if it were a valid
static identifier.</li>
</ul>
<p>In front of a dynamic field expression (<code>(X=expr): value</code>):</p>
<ul>
<li>binds the identifier to the concrete label resulting from evaluating <code>expr</code>.</li>
</ul>
<p>In front of a pattern constraint (<code>X=[expr]: value</code>):</p>
<ul>
<li>binds the identifier to the same field as the matched by the pattern
within the instance of the field value (<code>value</code>).</li>
</ul>
<p>In front of a pattern constraint expression (<code>[X=expr]: value</code>):</p>
<ul>
<li>binds the identifier to the concrete label that matches <code>expr</code>
within the instances of the field value (<code>value</code>).</li>
</ul>
<p>Before a value (<code>foo: X=x</code>)</p>
<ul>
<li>binds the identifier to the value it precedes within the scope of that value.</li>
</ul>
<p>Before a list element (<code>[ X=value, X+1 ]</code>) (Not yet implemented)</p>
<ul>
<li>binds the identifier to the list element it precedes within the scope of the
list expression.</li>
</ul>
<!-- TODO: explain the difference between aliases and definitions.
     Now that you have definitions, are aliases really necessary?
     Consider removing.
-->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gQSBmaWVsZCBhbGlhcwpmb286IFggIC8vIDQKWD0ibm90IGFuIGlkZW50aWZpZXIiOiA0CgovLyBBIHZhbHVlIGFsaWFzCmZvbzogWD17eDogWC5hfQpiYXI6IGZvbyAmIHthOiAxfSAgLy8ge2E6IDEsIHg6IDF9CgovLyBBIGxhYmVsIGFsaWFzCltZPXN0cmluZ106IHsgbmFtZTogWSB9CmZvbzogeyB2YWx1ZTogMSB9IC8vIG91dHB1dHM6IGZvbzogeyBuYW1lOiAiZm9vIiwgdmFsdWU6IDEgfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// A field alias
foo: X  // 4
X=&#34;not an identifier&#34;: 4

// A value alias
foo: X={x: X.a}
bar: foo &amp; {a: 1}  // {a: 1, x: 1}

// A label alias
[Y=string]: { name: Y }
foo: { value: 1 } // outputs: foo: { name: &#34;foo&#34;, value: 1 }</code></pre></div>
</div>
<!-- TODO: also allow aliases as lists -->
<h4 id="let-declarations">
    <a href="#let-declarations" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Let declarations</h4>
<p><em>Let declarations</em> bind an identifier to an expression.
The identifier is only visible within the <a href="/docs/reference/spec/#declarations-and-scopes">scope</a>
in which it is declared.
The identifier must be unique within its scope.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bGV0IHggPSBleHByCgphOiB4ICsgMQpiOiB4ICsgMg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>let x = expr

a: x + 1
b: x + 2</code></pre></div>
</div>
<h4 id="shorthand-notation-for-nested-structs">
    <a href="#shorthand-notation-for-nested-structs" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Shorthand notation for nested structs</h4>
<p>A field whose value is a struct with a single field may be written as
a colon-separated sequence of the two field names,
followed by a colon and the value of that single field.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="am9iOiBteVRhc2s6IHJlcGxpY2FzOiAy">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>job: myTask: replicas: 2</code></pre></div>
</div>
<p>expands to</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="am9iOiB7CiAgICBteVRhc2s6IHsKICAgICAgICByZXBsaWNhczogMgogICAgfQp9">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>job: {
    myTask: {
        replicas: 2
    }
}</code></pre></div>
</div>
<!-- OPTIONAL FIELDS:

The optional marker solves the issue of having to print large amounts of
boilerplate when dealing with large types with many optional or default
values (such as Kubernetes).
Writing such optional values in terms of *null | value is tedious,
unpleasant to read, and as it is not well defined what can be dropped or not,
all null values have to be emitted from the output, even if the user
doesn't override them.
Part of the issue is how null is defined. We could adopt a Typescript-like
approach of introducing "void" or "undefined" to mean "not defined and not
part of the output". But having all of null, undefined, and void can be
confusing. If these ever are introduced anyway, the ? operator could be
expressed along the lines of
   foo?: bar
being a shorthand for
   foo: void | bar
where void is the default if no other default is given.

The current mechanical definition of "?" is straightforward, though, and
probably avoids the need for void, while solving a big issue.

Caveats:
[1] this definition requires explicitly defined fields to be emitted, even
if they could be elided (for instance if the explicit value is the default
value defined an optional field). This is probably a good thing.

[2] a default value may still need to be included in an output if it is not
the zero value for that field and it is not known if any outside system is
aware of defaults. For instance, which defaults are specified by the user
and which by the schema understood by the receiving system.
The use of "?" together with defaults should therefore be used carefully
in non-schema definitions.
Problematic cases should be easy to detect by a vet-like check, though.

[3] It should be considered how this affects the trim command.
Should values implied by optional fields be allowed to be removed?
Probably not. This restriction is unlikely to limit the usefulness of trim,
though.

[4] There should be an option to emit all concrete optional values.
```
-->
<h3 id="lists">
    <a href="#lists" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Lists</h3>
<p>A list literal defines a new value of type list.
A list may be open or closed.
An open list is indicated with a <code>...</code> at the end of an element list,
optionally followed by a value for the remaining elements.</p>
<p>The length of a closed list is the number of elements it contains.
The length of an open list is the number of elements as a lower bound
and an unlimited number of elements as its upper bound.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="TGlzdExpdCAgICAgICA9ICJbIiBbIEVsZW1lbnRMaXN0IFsgIiwiIF0gXSAiXSIgLgpFbGVtZW50TGlzdCAgID0gRWxsaXBzaXMgfCBFbWJlZGRpbmcgeyAiLCIgRW1iZWRkaW5nIH0gWyAiLCIgRWxsaXBzaXMgXSAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>ListLit       = &#34;[&#34; [ ElementList [ &#34;,&#34; ] ] &#34;]&#34; .
ElementList   = Ellipsis | Embedding { &#34;,&#34; Embedding } [ &#34;,&#34; Ellipsis ] .</code></pre></div>
</div>
<p>Lists can be thought of as structs:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="TGlzdDogKm51bGwgfCB7CiAgICBFbGVtOiBfCiAgICBUYWlsOiBMaXN0Cn0=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>List: *null | {
    Elem: _
    Tail: List
}</code></pre></div>
</div>
<p>For closed lists, <code>Tail</code> is <code>null</code> for the last element, for open lists it is
<code>*null | List</code>, defaulting to the shortest variant.
For instance, the open list [ 1, 2, &hellip; ] can be represented as:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="b3BlbjogTGlzdCAmIHsgRWxlbTogMSwgVGFpbDogeyBFbGVtOiAyIH0gfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>open: List &amp; { Elem: 1, Tail: { Elem: 2 } }</code></pre></div>
</div>
<p>and the closed version of this list, [ 1, 2 ], as</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Y2xvc2VkOiBMaXN0ICYgeyBFbGVtOiAxLCBUYWlsOiB7IEVsZW06IDIsIFRhaWw6IG51bGwgfSB9">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>closed: List &amp; { Elem: 1, Tail: { Elem: 2, Tail: null } }</code></pre></div>
</div>
<p>Using this representation, the subsumption rule for lists can
be derived from those of structs.
Implementations are not required to implement lists as structs.
The <code>Elem</code> and <code>Tail</code> fields are not special and <code>len</code> will not work as
expected in these cases.</p>
<h2 id="declarations-and-scopes">
    <a href="#declarations-and-scopes" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Declarations and Scopes</h2>
<h3 id="blocks">
    <a href="#blocks" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Blocks</h3>
<p>A <em>block</em> is a possibly empty sequence of declarations.
The braces of a struct literal <code>{ ... }</code> form a block, but there are
others as well:</p>
<ul>
<li>The <em>universe block</em> encompasses all CUE source text.</li>
<li>Each <a href="/docs/reference/spec/#modules-instances-and-packages">package</a> has a <em>package block</em>
containing all CUE source text in that package.</li>
<li>Each file has a <em>file block</em> containing all CUE source text in that file.</li>
<li>Each <code>for</code> and <code>let</code> clause in a <a href="/docs/reference/spec/#comprehensions">comprehension</a>
is considered to be its own implicit block.</li>
</ul>
<p>Blocks nest and influence scoping.</p>
<h3 id="declarations-and-scope">
    <a href="#declarations-and-scope" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Declarations and scope</h3>
<p>A <em>declaration</em>  may bind an identifier to a field, alias, or package.
Every identifier in a program must be declared.
Other than for fields,
no identifier may be declared twice within the same block.
For fields, an identifier may be declared more than once within the same block,
resulting in a field with a value that is the result of unifying the values
of all fields with the same identifier.
String labels do not bind an identifier to the respective field.</p>
<p>The <em>scope</em> of a declared identifier is the extent of source text in which the
identifier denotes the specified field, alias, or package.</p>
<p>CUE is lexically scoped using blocks:</p>
<ol>
<li>The scope of a <a href="/docs/reference/spec/#predeclared-identifiers">predeclared identifier</a> is the universe block.</li>
<li>The scope of an identifier denoting a field
declared at top level (outside any struct literal) is the package block.</li>
<li>The scope of an identifier denoting an alias
declared at top level (outside any struct literal) is the file block.</li>
<li>The scope of a let identifier
declared at top level (outside any struct literal) is the file block.</li>
<li>The scope of the package name of an imported package is the file block of the
file containing the import declaration.</li>
<li>The scope of a field, alias or let identifier declared inside a struct
literal is the innermost containing block.</li>
</ol>
<p>An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes the entity
declared by the inner declaration.</p>
<p>The package clause is not a declaration;
the package name does not appear in any scope.
Its purpose is to identify the files belonging to the same package
and to specify the default name for import declarations.</p>
<h3 id="predeclared-identifiers">
    <a href="#predeclared-identifiers" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Predeclared identifiers</h3>
<p>CUE predefines a set of types and builtin functions.
For each of these there is a corresponding keyword which is the name
of the predefined identifier, prefixed with <code>__</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RnVuY3Rpb25zCmxlbiBjbG9zZSBhbmQgb3IKClR5cGVzCm51bGwgICAgICBUaGUgbnVsbCB0eXBlIGFuZCB2YWx1ZQpib29sICAgICAgQWxsIGJvb2xlYW4gdmFsdWVzCmludCAgICAgICBBbGwgaW50ZWdyYWwgbnVtYmVycwpmbG9hdCAgICAgQWxsIGRlY2ltYWwgZmxvYXRpbmctcG9pbnQgbnVtYmVycwpzdHJpbmcgICAgQW55IHZhbGlkIFVURi04IHNlcXVlbmNlCmJ5dGVzICAgICBBbnkgdmFsaWQgYnl0ZSBzZXF1ZW5jZQoKRGVyaXZlZCAgIFZhbHVlCm51bWJlciAgICBpbnQgfCBmbG9hdAp1aW50ICAgICAgPj0wCnVpbnQ4ICAgICA&#43;PTAgJiA8PTI1NQppbnQ4ICAgICAgPj0tMTI4ICYgPD0xMjcKdWludDE2ICAgID49MCAmIDw9NjU1MzUKaW50MTYgICAgID49LTMyXzc2OCAmIDw9MzJfNzY3CnJ1bmUgICAgICA&#43;PTAgJiA8PTB4MTBGRkZGCnVpbnQzMiAgICA&#43;PTAgJiA8PTRfMjk0Xzk2N18yOTUKaW50MzIgICAgID49LTJfMTQ3XzQ4M182NDggJiA8PTJfMTQ3XzQ4M182NDcKdWludDY0ICAgID49MCAmIDw9MThfNDQ2Xzc0NF8wNzNfNzA5XzU1MV82MTUKaW50NjQgICAgID49LTlfMjIzXzM3Ml8wMzZfODU0Xzc3NV84MDggJiA8PTlfMjIzXzM3Ml8wMzZfODU0Xzc3NV84MDcKdWludDEyOCAgID49MCAmIDw9MzQwXzI4Ml8zNjZfOTIwXzkzOF80NjNfNDYzXzM3NF82MDdfNDMxXzc2OF8yMTFfNDU1CmludDEyOCAgICA&#43;PS0xNzBfMTQxXzE4M180NjBfNDY5XzIzMV83MzFfNjg3XzMwM183MTVfODg0XzEwNV83MjggJgogICAgICAgICAgIDw9MTcwXzE0MV8xODNfNDYwXzQ2OV8yMzFfNzMxXzY4N18zMDNfNzE1Xzg4NF8xMDVfNzI3CmZsb2F0MzIgICA&#43;PS0zLjQwMjgyMzQ2NjM4NTI4ODU5ODExNzA0MTgzNDg0NTE2OTI1NDQwZSszOCAmCiAgICAgICAgICA8PTMuNDAyODIzNDY2Mzg1Mjg4NTk4MTE3MDQxODM0ODQ1MTY5MjU0NDBlKzM4CmZsb2F0NjQgICA&#43;PS0xLjc5NzY5MzEzNDg2MjMxNTcwODE0NTI3NDIzNzMxNzA0MzU2Nzk4MWUrMzA4ICYKICAgICAgICAgIDw9MS43OTc2OTMxMzQ4NjIzMTU3MDgxNDUyNzQyMzczMTcwNDM1Njc5ODFlKzMwOA==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Functions
len close and or

Types
null      The null type and value
bool      All boolean values
int       All integral numbers
float     All decimal floating-point numbers
string    Any valid UTF-8 sequence
bytes     Any valid byte sequence

Derived   Value
number    int | float
uint      &gt;=0
uint8     &gt;=0 &amp; &lt;=255
int8      &gt;=-128 &amp; &lt;=127
uint16    &gt;=0 &amp; &lt;=65535
int16     &gt;=-32_768 &amp; &lt;=32_767
rune      &gt;=0 &amp; &lt;=0x10FFFF
uint32    &gt;=0 &amp; &lt;=4_294_967_295
int32     &gt;=-2_147_483_648 &amp; &lt;=2_147_483_647
uint64    &gt;=0 &amp; &lt;=18_446_744_073_709_551_615
int64     &gt;=-9_223_372_036_854_775_808 &amp; &lt;=9_223_372_036_854_775_807
uint128   &gt;=0 &amp; &lt;=340_282_366_920_938_463_463_374_607_431_768_211_455
int128    &gt;=-170_141_183_460_469_231_731_687_303_715_884_105_728 &amp;
           &lt;=170_141_183_460_469_231_731_687_303_715_884_105_727
float32   &gt;=-3.40282346638528859811704183484516925440e+38 &amp;
          &lt;=3.40282346638528859811704183484516925440e+38
float64   &gt;=-1.797693134862315708145274237317043567981e+308 &amp;
          &lt;=1.797693134862315708145274237317043567981e+308</code></pre></div>
</div>
<h3 id="exported-identifiers">
    <a href="#exported-identifiers" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Exported identifiers</h3>
<!-- move to a more logical spot -->
<p>An identifier of a package may be exported to permit access to it
from another package.
All identifiers not starting with <code>_</code> (so all regular fields and definitions
starting with <code>#</code>) are exported.
Any identifier starting with <code>_</code> is not visible outside the package and resides
in a separate namespace than namesake identifiers of other packages.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="cGFja2FnZSBteXBhY2thZ2UKCmZvbzogICBzdHJpbmcgIC8vIHZpc2libGUgb3V0c2lkZSBteXBhY2thZ2UKImJhciI6IHN0cmluZyAgLy8gdmlzaWJsZSBvdXRzaWRlIG15cGFja2FnZQoKI0ZvbzogeyAgICAgIC8vIHZpc2libGUgb3V0c2lkZSBteXBhY2thZ2UKICAgIGE6ICAxICAgIC8vIHZpc2libGUgb3V0c2lkZSBteXBhY2thZ2UKICAgIF9iOiAyICAgIC8vIG5vdCB2aXNpYmxlIG91dHNpZGUgbXlwYWNrYWdlCgogICAgI0M6IHsgICAgLy8gdmlzaWJsZSBvdXRzaWRlIG15cGFja2FnZQogICAgICAgIGQ6IDQgLy8gdmlzaWJsZSBvdXRzaWRlIG15cGFja2FnZQogICAgfQogICAgXyNFOiBmb28gLy8gbm90IHZpc2libGUgb3V0c2lkZSBteXBhY2thZ2UKfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>package mypackage

foo:   string  // visible outside mypackage
&#34;bar&#34;: string  // visible outside mypackage

#Foo: {      // visible outside mypackage
    a:  1    // visible outside mypackage
    _b: 2    // not visible outside mypackage

    #C: {    // visible outside mypackage
        d: 4 // visible outside mypackage
    }
    _#E: foo // not visible outside mypackage
}</code></pre></div>
</div>
<h3 id="uniqueness-of-identifiers">
    <a href="#uniqueness-of-identifiers" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Uniqueness of identifiers</h3>
<p>Given a set of identifiers, an identifier is called unique if it is different
from every other in the set, after applying normalization following
<a href="https://unicode.org/reports/tr31/">Unicode Annex #31</a>.
Two identifiers are different if they are spelled differently
or if they appear in different packages and are not exported.
Otherwise, they are the same.</p>
<h3 id="field-declarations">
    <a href="#field-declarations" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Field declarations</h3>
<p>A field associates the value of an expression to a label within a struct.
If this label is an identifier, it binds the field to that identifier,
so the field&rsquo;s value can be referenced by writing the identifier.
String labels are not bound to fields.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogewogICAgYjogMgogICAgInMiOiAzCgogICAgYzogYiAgIC8vIDIKICAgIGQ6IHMgICAvLyBffF8gdW5yZXNvbHZlZCBpZGVudGlmaWVyICJzIgogICAgZTogYS5zIC8vIDMKfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: {
    b: 2
    &#34;s&#34;: 3

    c: b   // 2
    d: s   // _|_ unresolved identifier &#34;s&#34;
    e: a.s // 3
}</code></pre></div>
</div>
<p>If an expression may result in a value associated with a default value
as described in <a href="/docs/reference/spec/#default-values">default values</a>, the field binds to this
value-default pair.</p>
<!-- TODO: disallow creating identifiers starting with __
...and reserve them for builtin values.

The issue is with code generation. As no guarantee can be given that
a predeclared identifier is not overridden in one of the enclosing scopes,
code will have to handle detecting such cases and renaming them.
An alternative is to have the predeclared identifiers be aliases for namesake
equivalents starting with a double underscore (e.g. string -> __string),
allowing generated code (normal code would keep using `string`) to refer
to these directly.
-->
<h3 id="let-declarations-1">
    <a href="#let-declarations-1" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Let declarations</h3>
<!--
TODO: why are there two "Let declarations" sections?
-->
<p>Within a struct, a let clause binds an identifier to the given expression.</p>
<p>Within the scope of the identifier, the identifier refers to the
<em>locally declared</em> expression.
The expression is evaluated in the scope it was declared.</p>
<h2 id="expressions">
    <a href="#expressions" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Expressions</h2>
<p>An expression specifies the computation of a value by applying operators and
builtin functions to operands.</p>
<p>Expressions that require concrete values are called <em>incomplete</em> if any of
their operands are not concrete, but define a value that would be legal for
that expression.
Incomplete expressions may be left unevaluated until a concrete value is
requested at the application level.</p>
<h3 id="operands">
    <a href="#operands" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Operands</h3>
<p>Operands denote the elementary values in an expression.
An operand may be a literal, a (possibly qualified) identifier denoting
a field, alias, or let declaration, or a parenthesized expression.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="T3BlcmFuZCAgICAgPSBMaXRlcmFsIHwgT3BlcmFuZE5hbWUgfCAiKCIgRXhwcmVzc2lvbiAiKSIgLgpMaXRlcmFsICAgICA9IEJhc2ljTGl0IHwgTGlzdExpdCB8IFN0cnVjdExpdCAuCkJhc2ljTGl0ICAgID0gaW50X2xpdCB8IGZsb2F0X2xpdCB8IHN0cmluZ19saXQgfAogICAgICAgICAgICAgIG51bGxfbGl0IHwgYm9vbF9saXQgfCBib3R0b21fbGl0IC4KT3BlcmFuZE5hbWUgPSBpZGVudGlmaWVyIHwgUXVhbGlmaWVkSWRlbnQgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Operand     = Literal | OperandName | &#34;(&#34; Expression &#34;)&#34; .
Literal     = BasicLit | ListLit | StructLit .
BasicLit    = int_lit | float_lit | string_lit |
              null_lit | bool_lit | bottom_lit .
OperandName = identifier | QualifiedIdent .</code></pre></div>
</div>
<h3 id="qualified-identifiers">
    <a href="#qualified-identifiers" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Qualified identifiers</h3>
<p>A qualified identifier is an identifier qualified with a package name prefix.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UXVhbGlmaWVkSWRlbnQgPSBQYWNrYWdlTmFtZSAiLiIgaWRlbnRpZmllciAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>QualifiedIdent = PackageName &#34;.&#34; identifier .</code></pre></div>
</div>
<p>A qualified identifier accesses an identifier in a different package,
which must be <a href="/docs/reference/spec/#import-declarations">imported</a>.
The identifier must be declared in the <a href="/docs/reference/spec/#blocks">package block</a> of that package.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="bWF0aC5TaW4gICAgLy8gZGVub3RlcyB0aGUgU2luIGZ1bmN0aW9uIGluIHBhY2thZ2UgbWF0aA==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>math.Sin    // denotes the Sin function in package math</code></pre></div>
</div>
<h3 id="references">
    <a href="#references" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>References</h3>
<p>An identifier operand refers to a field and is called a reference.
The value of a reference is a copy of the expression associated with the field
that it is bound to,
with any references within that expression bound to the respective copies of
the fields they were originally bound to.
Implementations may use a different mechanism to evaluate as long as
these semantics are maintained.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogewogICAgcGxhY2U6ICAgIHN0cmluZwogICAgZ3JlZXRpbmc6ICJIZWxsbywgXChwbGFjZSkhIgp9CgpiOiBhICYgeyBwbGFjZTogIndvcmxkIiB9CmM6IGEgJiB7IHBsYWNlOiAieW91IiB9CgpkOiBiLmdyZWV0aW5nICAvLyAiSGVsbG8sIHdvcmxkISIKZTogYy5ncmVldGluZyAgLy8gIkhlbGxvLCB5b3UhIg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: {
    place:    string
    greeting: &#34;Hello, \(place)!&#34;
}

b: a &amp; { place: &#34;world&#34; }
c: a &amp; { place: &#34;you&#34; }

d: b.greeting  // &#34;Hello, world!&#34;
e: c.greeting  // &#34;Hello, you!&#34;</code></pre></div>
</div>
<h3 id="primary-expressions">
    <a href="#primary-expressions" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Primary expressions</h3>
<p>Primary expressions are the operands for unary and binary expressions.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UHJpbWFyeUV4cHIgPQoJT3BlcmFuZCB8CglQcmltYXJ5RXhwciBTZWxlY3RvciB8CglQcmltYXJ5RXhwciBJbmRleCB8CglQcmltYXJ5RXhwciBBcmd1bWVudHMgLgoKU2VsZWN0b3IgICAgICAgPSAiLiIgKGlkZW50aWZpZXIgfCBzaW1wbGVfc3RyaW5nX2xpdCkgLgpJbmRleCAgICAgICAgICA9ICJbIiBFeHByZXNzaW9uICJdIiAuCkFyZ3VtZW50ICAgICAgID0gRXhwcmVzc2lvbiAuCkFyZ3VtZW50cyAgICAgID0gIigiIFsgKCBBcmd1bWVudCB7ICIsIiBBcmd1bWVudCB9ICkgWyAiLCIgXSBdICIpIiAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>PrimaryExpr =
	Operand |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Arguments .

Selector       = &#34;.&#34; (identifier | simple_string_lit) .
Index          = &#34;[&#34; Expression &#34;]&#34; .
Argument       = Expression .
Arguments      = &#34;(&#34; [ ( Argument { &#34;,&#34; Argument } ) [ &#34;,&#34; ] ] &#34;)&#34; .</code></pre></div>
</div>
<!---
TODO:
	PrimaryExpr Query |
Query          = "." Filters .
Filters        = Filter { Filter } .
Filter         = "[" [ "?" ] AliasExpr "]" .

TODO: maybe reintroduce slices, as they are useful in queries, probably this
time with Python semantics.
	PrimaryExpr Slice |
Slice          = "[" [ Expression ] ":" [ Expression ] [ ":" [Expression] ] "]" .

Argument       = Expression | ( identifier ":" Expression ).

// & expression type
// string_lit: same as label. Arguments is current node.
// If selector is applied to list, it performs the operation for each
// element.

TODO: considering allowing decimal_lit for selectors.
--->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="eAoyCihzICsgIi50eHQiKQpmKDMuMTQxNSwgdHJ1ZSkKbVsiZm9vIl0Kb2JqLmNvbG9yCmYucFtpXS54">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>x
2
(s + &#34;.txt&#34;)
f(3.1415, true)
m[&#34;foo&#34;]
obj.color
f.p[i].x</code></pre></div>
</div>
<h3 id="selectors">
    <a href="#selectors" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Selectors</h3>
<p>For a <a href="/docs/reference/spec/#primary-expressions">primary expression</a> <code>x</code> that is not a <a href="/docs/reference/spec/#package-clause">package name</a>,
the selector expression</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="eC5m">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>x.f</code></pre></div>
</div>
<p>denotes the element of a <!--list or -->struct <code>x</code> identified by <code>f</code>.</p>
<!--For structs, -->
<p><code>f</code> must be an identifier or a string literal identifying
any definition or regular non-optional field.
The identifier <code>f</code> is called the field selector.</p>
<!--
Allowing strings to be used as field selectors obviates the need for
backquoted identifiers. Note that some standards use names for structs that
are not standard identifiers (such "Fn::Foo"). Note that indexing does not
allow access to identifiers.
-->
<!--
For lists, `f` must be an integer and follows the same lookup rules as
for the index operation.
The type of the selector expression is the type of `f`.
-->
<p>If <code>x</code> is a package name, see the section on <a href="/docs/reference/spec/#qualified-identifiers">qualified identifiers</a>.</p>
<!--
TODO: consider allowing this and also for selectors. It needs to be considered
how defaults are carried forward in cases like:

    x: { a: string | *"foo" } | *{ a: int | *4 }
    y: x.a & string

What is y in this case?
   (x.a & string, _|_)
   (string|"foo", _|_)
   (string|"foo", "foo)
If the latter, then why?

For a disjunction of the form `x1 | ... | xn`,
the selector is applied to each element `x1.f | ... | xn.f`.
-->
<p>Otherwise, if <code>x</code> is not a <!--list or -->struct,
or if <code>f</code> does not exist in <code>x</code>,
the result of the expression is bottom (an error).
In the latter case the expression is incomplete.
The operand of a selector may be associated with a default.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="VDogewogICAgeDogICAgIGludAogICAgeTogICAgIDMKICAgICJ4LXkiOiA0Cn0KCmE6IFQueCAgICAgLy8gaW50CmI6IFQueSAgICAgLy8gMwpjOiBULnogICAgIC8vIF98XyAvLyBmaWVsZCAneicgbm90IGZvdW5kIGluIFQKZDogVC4ieC15IiAvLyA0CgplOiB7YTogMXwqMn0gfCAqe2E6IDN8KjR9CmY6IGUuYSAgLy8gNCAoZGVmYXVsdCB2YWx1ZSk=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>T: {
    x:     int
    y:     3
    &#34;x-y&#34;: 4
}

a: T.x     // int
b: T.y     // 3
c: T.z     // _|_ // field &#39;z&#39; not found in T
d: T.&#34;x-y&#34; // 4

e: {a: 1|*2} | *{a: 3|*4}
f: e.a  // 4 (default value)</code></pre></div>
</div>
<!--
```
(v, d).f  =>  (v.f, d.f)

e: {a: 1|*2} | *{a: 3|*4}
f: e.a  // 4 after selecting default from (({a: 1|*2} | {a: 3|*4}).a, 4)

```
-->
<h3 id="index-expressions">
    <a href="#index-expressions" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Index expressions</h3>
<p>A primary expression of the form</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YVt4XQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a[x]</code></pre></div>
</div>
<p>denotes the element of a list or struct <code>a</code> indexed by <code>x</code>.
The value <code>x</code> is called the index or field name, respectively.
The following rules apply:</p>
<p>If <code>a</code> is not a struct:</p>
<ul>
<li><code>a</code> is a list (which need not be complete)</li>
<li>the index <code>x</code> unified with <code>int</code> must be concrete.</li>
<li>the index <code>x</code> is in range if <code>0 &lt;= x &lt; len(a)</code>, where only the
explicitly defined values of an open-ended list are considered,
otherwise it is out of range</li>
</ul>
<p>The result of <code>a[x]</code> is</p>
<p>for <code>a</code> of list type:</p>
<ul>
<li>the list element at index <code>x</code>, if <code>x</code> is within range</li>
<li>bottom (an error), otherwise</li>
</ul>
<p>for <code>a</code> of struct type:</p>
<ul>
<li>the index <code>x</code> unified with <code>string</code> must be concrete.</li>
<li>the value of the regular and non-optional field named <code>x</code> of struct <code>a</code>,
if this field exists</li>
<li>bottom (an error), otherwise</li>
</ul>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogWyAxLCAyIF1bMV0gICAgIC8vIDIKYjogWyAxLCAyIF1bMl0gICAgIC8vIF98XwpjOiBbIDEsIDIsIC4uLl1bMl0gLy8gX3xfCgovLyBEZWZhdWx0cyBhcmUgc2VsZWN0ZWQgZm9yIGJvdGggb3BlcmFuZCBhbmQgaW5kZXg6Cng6IFsxLCAyXSB8ICpbMywgNF0KeTogaW50IHwgKjEKejogeFt5XSAgLy8gNA==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: [ 1, 2 ][1]     // 2
b: [ 1, 2 ][2]     // _|_
c: [ 1, 2, ...][2] // _|_

// Defaults are selected for both operand and index:
x: [1, 2] | *[3, 4]
y: int | *1
z: x[y]  // 4</code></pre></div>
</div>
<h3 id="operators">
    <a href="#operators" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Operators</h3>
<p>Operators combine operands into expressions.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiA9IFVuYXJ5RXhwciB8IEV4cHJlc3Npb24gYmluYXJ5X29wIEV4cHJlc3Npb24gLgpVbmFyeUV4cHIgID0gUHJpbWFyeUV4cHIgfCB1bmFyeV9vcCBVbmFyeUV4cHIgLgoKYmluYXJ5X29wICA9ICJ8IiB8ICImIiB8ICJ8fCIgfCAiJiYiIHwgIj09IiB8IHJlbF9vcCB8IGFkZF9vcCB8IG11bF9vcCAgLgpyZWxfb3AgICAgID0gIiE9IiB8ICI8IiB8ICI8PSIgfCAiPiIgfCAiPj0iIHwgIj1&#43;IiB8ICIhfiIgLgphZGRfb3AgICAgID0gIisiIHwgIi0iIC4KbXVsX29wICAgICA9ICIqIiB8ICIvIiAuCnVuYXJ5X29wICAgPSAiKyIgfCAiLSIgfCAiISIgfCAiKiIgfCByZWxfb3AgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &#34;|&#34; | &#34;&amp;&#34; | &#34;||&#34; | &#34;&amp;&amp;&#34; | &#34;==&#34; | rel_op | add_op | mul_op  .
rel_op     = &#34;!=&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;=~&#34; | &#34;!~&#34; .
add_op     = &#34;+&#34; | &#34;-&#34; .
mul_op     = &#34;*&#34; | &#34;/&#34; .
unary_op   = &#34;+&#34; | &#34;-&#34; | &#34;!&#34; | &#34;*&#34; | rel_op .</code></pre></div>
</div>
<p>Comparisons are discussed <a href="/docs/reference/spec/#comparison-operators">elsewhere</a>.
For any binary operators, the operand types must unify.</p>
<!-- TODO: durations
 unless the operation involves durations.

Except for duration operations, if one operand is an untyped [literal] and the
other operand is not, the constant is [converted] to the type of the other
operand.
-->
<!--
Operands of unary and binary expressions may be associated with a default using
the following:

```
O1: op (v1, d1)          => (op v1, op d1)

O2: (v1, d1) op (v2, d2) => (v1 op v2, d1 op d2)
and because v => (v, v)
O3: v1       op (v2, d2) => (v1 op v2, v1 op d2)
O4: (v1, d1) op v2       => (v1 op v2, d1 op v2)
```

```
Field               Resulting Value-Default pair
a: *1|2             (1|2, 1)
b: -a               (-a, -1)

c: a + 2            (a+2, 3)
d: a + a            (a+a, 2)
```
-->
<h4 id="operator-precedence">
    <a href="#operator-precedence" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Operator precedence</h4>
<p>Unary operators have the highest precedence.</p>
<p>There are eight precedence levels for binary operators.
Multiplication operators binds strongest, followed by
addition operators, comparison operators,
<code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), <code>&amp;</code> (unification),
and finally <code>|</code> (disjunction):</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UHJlY2VkZW5jZSAgICBPcGVyYXRvcgogICAgNyAgICAgICAgICAgICAqICAvCiAgICA2ICAgICAgICAgICAgICsgIC0KICAgIDUgICAgICAgICAgICAgPT0gICE9ICA8ICA8PSAgPiAgPj0gPX4gIX4KICAgIDQgICAgICAgICAgICAgJiYKICAgIDMgICAgICAgICAgICAgfHwKICAgIDIgICAgICAgICAgICAgJgogICAgMSAgICAgICAgICAgICB8">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Precedence    Operator
    7             *  /
    6             +  -
    5             ==  !=  &lt;  &lt;=  &gt;  &gt;= =~ !~
    4             &amp;&amp;
    3             ||
    2             &amp;
    1             |</code></pre></div>
</div>
<p>Binary operators of the same precedence associate from left to right.
For instance, <code>x / y * z</code> is the same as <code>(x / y) * z</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="K3gKMjMgKyAzKnhbaV0KeCA8PSBmKCkKZigpIHx8IGcoKQp4ID09IHkrMSAmJiB5ID09IHotMQoyIHwgaW50CnsgYTogMSB9ICYgeyBiOiAyIH0=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>+x
23 + 3*x[i]
x &lt;= f()
f() || g()
x == y+1 &amp;&amp; y == z-1
2 | int
{ a: 1 } &amp; { b: 2 }</code></pre></div>
</div>
<h4 id="arithmetic-operators">
    <a href="#arithmetic-operators" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Arithmetic operators</h4>
<p>Arithmetic operators apply to numeric values and yield a result of the same type
as the first operand. The four standard arithmetic operators
<code>(+, -, *, /)</code> apply to integer and decimal floating-point types;
<code>+</code> and <code>*</code> also apply to strings and bytes.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="KyAgICBzdW0gICAgICAgICAgICAgICAgICAgIGludGVnZXJzLCBmbG9hdHMsIHN0cmluZ3MsIGJ5dGVzCi0gICAgZGlmZmVyZW5jZSAgICAgICAgICAgICBpbnRlZ2VycywgZmxvYXRzCiogICAgcHJvZHVjdCAgICAgICAgICAgICAgICBpbnRlZ2VycywgZmxvYXRzLCBzdHJpbmdzLCBieXRlcwovICAgIHF1b3RpZW50ICAgICAgICAgICAgICAgaW50ZWdlcnMsIGZsb2F0cw==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>+    sum                    integers, floats, strings, bytes
-    difference             integers, floats
*    product                integers, floats, strings, bytes
/    quotient               integers, floats</code></pre></div>
</div>
<p>For any operator that accepts operands of type <code>float</code>, any operand may be
of type <code>int</code> or <code>float</code>, in which case the result will be <code>float</code>
if it cannot be represented as an <code>int</code> or if any of the operands are <code>float</code>,
or <code>int</code> otherwise.
So the result of <code>1 / 2</code> is <code>0.5</code> and is of type <code>float</code>.</p>
<p>The result of division by zero is bottom (an error).</p>
<!-- TODO: consider making it +/- Inf -->
<p>Integer division is implemented through the builtin functions
<code>quo</code>, <code>rem</code>, <code>div</code>, and <code>mod</code>.</p>
<p>The unary operators <code>+</code> and <code>-</code> are defined for numeric values as follows:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="K3ggICAgICAgICAgICAgICAgICAgICAgICAgIGlzIDAgKyB4Ci14ICAgIG5lZ2F0aW9uICAgICAgICAgICAgICBpcyAwIC0geA==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>+x                          is 0 + x
-x    negation              is 0 - x</code></pre></div>
</div>
<h4 id="string-operators">
    <a href="#string-operators" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>String operators</h4>
<p>Strings can be concatenated using the <code>+</code> operator:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="czogImhpICIgKyBuYW1lICsgIiBhbmQgZ29vZCBieWUi">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>s: &#34;hi &#34; + name + &#34; and good bye&#34;</code></pre></div>
</div>
<p>String addition creates a new string by concatenating the operands.</p>
<p>A string can be repeated by multiplying it:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="czogImV0Yy4gIiozICAvLyAiZXRjLiBldGMuIGV0Yy4gIg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>s: &#34;etc. &#34;*3  // &#34;etc. etc. etc. &#34;</code></pre></div>
</div>
<!-- jba: Do these work for byte sequences? If not, why not? -->
<h5 id="comparison-operators">
    <a href="#comparison-operators" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Comparison operators</h5>
<p>Comparison operators compare two operands and yield an untyped boolean value.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="PT0gICAgZXF1YWwKIT0gICAgbm90IGVxdWFsCjwgICAgIGxlc3MKPD0gICAgbGVzcyBvciBlcXVhbAo&#43;ICAgICBncmVhdGVyCj49ICAgIGdyZWF0ZXIgb3IgZXF1YWwKPX4gICAgbWF0Y2hlcyByZWd1bGFyIGV4cHJlc3Npb24KIX4gICAgZG9lcyBub3QgbWF0Y2ggcmVndWxhciBleHByZXNzaW9u">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
=~    matches regular expression
!~    does not match regular expression</code></pre></div>
</div>
<!-- regular expression operator inspired by Bash, Perl, and Ruby. -->
<p>In any comparison, the types of the two operands must unify or one of the
operands must be null.</p>
<p>The equality operators <code>==</code> and <code>!=</code> apply to operands that are comparable.
The ordering operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> apply to operands that are ordered.
The matching operators <code>=~</code> and <code>!~</code> apply to a string and a regular
expression operand.
These terms and the result of the comparisons are defined as follows:</p>
<ul>
<li>Null is comparable with itself and any other type.
Two null values are always equal, null is unequal with anything else.</li>
<li>Boolean values are comparable.
Two boolean values are equal if they are either both true or both false.</li>
<li>Integer values are comparable and ordered, in the usual way.</li>
<li>Floating-point values are comparable and ordered, as per the definitions
for binary coded decimals in the IEEE-754-2008 standard.</li>
<li>Floating point numbers may be compared with integers.</li>
<li>String and bytes values are comparable and ordered lexically byte-wise.</li>
<li>Struct are not comparable.</li>
<li>Lists are not comparable.</li>
<li>The regular expression syntax is the one accepted by RE2,
described in <a href="https://github.com/google/re2/wiki/Syntax">https://github.com/google/re2/wiki/Syntax</a>,
except for <code>\C</code>.</li>
<li><code>s =~ r</code> is true if <code>s</code> matches the regular expression <code>r</code>.</li>
<li><code>s !~ r</code> is true if <code>s</code> does not match regular expression <code>r</code>.</li>
</ul>
<!--- TODO: consider the following
- For regular expression, named capture groups are interpreted as CUE references
  that must unify with the strings matching this capture group.
--->
<!-- TODO: Implementations should adopt an algorithm that runs in linear time? -->
<!-- Consider implementing Level 2 of Unicode regular expression. -->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="MyA8IDQgICAgICAgLy8gdHJ1ZQozIDwgNC4wICAgICAvLyB0cnVlCm51bGwgPT0gMiAgIC8vIGZhbHNlCm51bGwgIT0ge30gIC8vIHRydWUKe30gPT0ge30gICAgLy8gX3xfOiBzdHJ1Y3RzIGFyZSBub3QgY29tcGFyYWJsZSBhZ2FpbnN0IHN0cnVjdHMKCiJXaWxkIGNhdHMiID1&#43;ICJjYXQiICAgLy8gdHJ1ZQoiV2lsZCBjYXRzIiAhfiAiZG9nIiAgIC8vIHRydWUKCiJmb28iID1&#43;ICJeW2Etel17M30kIiAgLy8gdHJ1ZQoiZm9vIiA9fiAiXlthLXpdezR9JCIgIC8vIGZhbHNl">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>3 &lt; 4       // true
3 &lt; 4.0     // true
null == 2   // false
null != {}  // true
{} == {}    // _|_: structs are not comparable against structs

&#34;Wild cats&#34; =~ &#34;cat&#34;   // true
&#34;Wild cats&#34; !~ &#34;dog&#34;   // true

&#34;foo&#34; =~ &#34;^[a-z]{3}$&#34;  // true
&#34;foo&#34; =~ &#34;^[a-z]{4}$&#34;  // false</code></pre></div>
</div>
<!-- jba
I think I know what `3 < a` should mean if

    a: >=1 & <=5

It should be a constraint on `a` that can be evaluated once `a`'s value is known more precisely.

But what does `3 < (>=1 & <=5)` mean? We'll never get more information, so it must have a definite value.
-->
<h4 id="logical-operators">
    <a href="#logical-operators" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Logical operators</h4>
<p>Logical operators apply to boolean values and yield a result of the same type
as the operands. The right operand is evaluated conditionally.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="JiYgICAgY29uZGl0aW9uYWwgQU5EICAgIHAgJiYgcSAgaXMgICJpZiBwIHRoZW4gcSBlbHNlIGZhbHNlIgp8fCAgICBjb25kaXRpb25hbCBPUiAgICAgcCB8fCBxICBpcyAgImlmIHAgdGhlbiB0cnVlIGVsc2UgcSIKISAgICAgTk9UICAgICAgICAgICAgICAgICFwICAgICAgaXMgICJub3QgcCI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&amp;&amp;    conditional AND    p &amp;&amp; q  is  &#34;if p then q else false&#34;
||    conditional OR     p || q  is  &#34;if p then true else q&#34;
!     NOT                !p      is  &#34;not p&#34;</code></pre></div>
</div>
<!--
### TODO TODO TODO

3.14 / 0.0   // illegal: division by zero
Illegal conversions always apply to CUE.

Implementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.
-->
<!--- TODO(mpvl): conversions
### Conversions
Conversions are expressions of the form `T(x)` where `T` and `x` are
expressions.
The result is always an instance of `T`.

```
Conversion = Expression "(" Expression [ "," ] ")" .
```
--->
<!---

A literal value `x` can be converted to type T if `x` is representable by a
value of `T`.

As a special case, an integer literal `x` can be converted to a string type
using the same rule as for non-constant x.

Converting a literal yields a typed value as result.

```
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
float32(0.49999999)      // 0.5 of type float32
float64(-1e-1000)        // 0.0 of type float64
string('x')              // "x" of type string
string(0x266c)           // "â™¬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
```
--->
<!---

A conversion is always allowed if `x` is an instance of `T`.

If `T` and `x` of different underlying type, a conversion is allowed if
`x` can be converted to a value `x'` of `T`'s type, and
`x'` is an instance of `T`.
A value `x` can be converted to the type of `T` in any of these cases:

- `x` is a struct and is subsumed by `T`.
- `x` and `T` are both integer or floating points.
- `x` is an integer or a byte sequence and `T` is a string.
- `x` is a string and `T` is a byte sequence.

Specific rules apply to conversions between numeric types, structs,
or to and from a string type. These conversions may change the representation
of `x`.
All other conversions only change the type but not the representation of x.


#### Conversions between numeric ranges
For the conversion of numeric values, the following rules apply:

1. Any integer value can be converted into any other integer value
   provided that it is within range.
2. When converting a decimal floating-point number to an integer, the fraction
   is discarded (truncation towards zero). TODO: or disallow truncating?

```
a: uint16(int(1000))  // uint16(1000)
b: uint8(1000)        // _|_ // overflow
c: int(2.5)           // 2  TODO: TBD
```


#### Conversions to and from a string type

Converting a list of bytes to a string type yields a string whose successive
bytes are the elements of the slice.
Invalid UTF-8 is converted to `"\uFFFD"`.

```
string('hell\xc3\xb8')   // "hellÃ¸"
string(bytes([0x20]))    // " "
```

As string value is always convertible to a list of bytes.

```
bytes("hellÃ¸")   // 'hell\xc3\xb8'
bytes("")        // ''
```

#### Conversions between list types

Conversions between list types are possible only if `T` strictly subsumes `x`
and the result will be the unification of `T` and `x`.

If we introduce named types this would be different from IP & [10, ...]

Consider removing this until it has a different meaning.

```
IP:        4*[byte]
Private10: IP([10, ...])  // [10, byte, byte, byte]
```

#### Conversions between struct types

A conversion from `x` to `T`
is applied using the following rules:

1. `x` must be an instance of `T`,
2. all fields defined for `x` that are not defined for `T` are removed from
  the result of the conversion, recursively.

<!-- jba: I don't think you say anywhere that the matching fields are unified.
mpvl: they are not, x must be an instance of T, in which case x == T&x,
so unification would be unnecessary.
-->
<!--
```
T: {
    a: { b: 1..10 }
}

x1: {
    a: { b: 8, c: 10 }
    d: 9
}

c1: T(x1)             // { a: { b: 8 } }
c2: T({})             // _|_  // missing field 'a' in '{}'
c3: T({ a: {b: 0} })  // _|_  // field a.b does not unify (0 & 1..10)
```
-->
<h3 id="calls">
    <a href="#calls" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Calls</h3>
<p>Calls can be made to core library functions, called builtins.
Given an expression <code>f</code> of function type F,</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="ZihhMSwgYTIsIOKApiBhbik=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>f(a1, a2, â€¦ an)</code></pre></div>
</div>
<p>calls <code>f</code> with arguments <code>a1, a2, â€¦ an</code>. Arguments must be expressions
of which the values are an instance of the parameter types of <code>F</code>
and are evaluated before the function is called.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogbWF0aC5BdGFuMih4LCB5KQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: math.Atan2(x, y)</code></pre></div>
</div>
<p>In a function call, the function value and arguments are evaluated in the usual
order.
After they are evaluated, the parameters of the call are passed by value
to the function and the called function begins execution.
The return parameters
of the function are passed by value back to the calling function when the
function returns.</p>
<h3 id="comprehensions">
    <a href="#comprehensions" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Comprehensions</h3>
<p>Lists and fields can be constructed using comprehensions.</p>
<p>Comprehensions define a clause sequence that consists of a sequence of
<code>for</code>, <code>if</code>, and <code>let</code> clauses, nesting from left to right.
The sequence must start with a <code>for</code> or <code>if</code> clause.
The <code>for</code> and <code>let</code> clauses each define a new scope in which new values are
bound to be available for the next clause.</p>
<p>The <code>for</code> clause binds the defined identifiers, on each iteration, to the next
value of some iterable value in a new scope.
A <code>for</code> clause may bind one or two identifiers.
If there is one identifier, it binds it to the value of
a list element or struct field value.
If there are two identifiers, the first value will be the key or index,
if available, and the second will be the value.</p>
<p>For lists, <code>for</code> iterates over all elements in the list after closing it.
For structs, <code>for</code> iterates over all non-optional regular fields.</p>
<p>An <code>if</code> clause, or guard, specifies an expression that terminates the current
iteration if it evaluates to false.</p>
<p>The <code>let</code> clause binds the result of an expression to the defined identifier
in a new scope.</p>
<p>A current iteration is said to complete if the innermost block of the clause
sequence is reached.
Syntactically, the comprehension value is a struct.
A comprehension can generate non-struct values by embedding such values within
this struct.</p>
<p>Within lists, the values yielded by a comprehension are inserted in the list
at the position of the comprehension.
Within structs, the values yielded by a comprehension are embedded within the
struct.
Both structs and lists may contain multiple comprehensions.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Q29tcHJlaGVuc2lvbiAgICAgICA9IENsYXVzZXMgU3RydWN0TGl0IC4KCkNsYXVzZXMgICAgICAgICAgICAgPSBTdGFydENsYXVzZSB7IFsgIiwiIF0gQ2xhdXNlIH0gLgpTdGFydENsYXVzZSAgICAgICAgID0gRm9yQ2xhdXNlIHwgR3VhcmRDbGF1c2UgLgpDbGF1c2UgICAgICAgICAgICAgID0gU3RhcnRDbGF1c2UgfCBMZXRDbGF1c2UgLgpGb3JDbGF1c2UgICAgICAgICAgID0gImZvciIgaWRlbnRpZmllciBbICIsIiBpZGVudGlmaWVyIF0gImluIiBFeHByZXNzaW9uIC4KR3VhcmRDbGF1c2UgICAgICAgICA9ICJpZiIgRXhwcmVzc2lvbiAuCkxldENsYXVzZSAgICAgICAgICAgPSAibGV0IiBpZGVudGlmaWVyICI9IiBFeHByZXNzaW9uIC4=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Comprehension       = Clauses StructLit .

Clauses             = StartClause { [ &#34;,&#34; ] Clause } .
StartClause         = ForClause | GuardClause .
Clause              = StartClause | LetClause .
ForClause           = &#34;for&#34; identifier [ &#34;,&#34; identifier ] &#34;in&#34; Expression .
GuardClause         = &#34;if&#34; Expression .
LetClause           = &#34;let&#34; identifier &#34;=&#34; Expression .</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogWzEsIDIsIDMsIDRdCmI6IFtmb3IgeCBpbiBhIGlmIHggPiAxIHsgeCsxIH1dICAvLyBbMywgNCwgNV0KCmM6IHsKICAgIGZvciB4IGluIGEKICAgIGlmIHggPCA0CiAgICBsZXQgeSA9IDEgewogICAgICAgICJcKHgpIjogeCArIHkKICAgIH0KfQpkOiB7ICIxIjogMiwgIjIiOiAzLCAiMyI6IDQgfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: [1, 2, 3, 4]
b: [for x in a if x &gt; 1 { x+1 }]  // [3, 4, 5]

c: {
    for x in a
    if x &lt; 4
    let y = 1 {
        &#34;\(x)&#34;: x + y
    }
}
d: { &#34;1&#34;: 2, &#34;2&#34;: 3, &#34;3&#34;: 4 }</code></pre></div>
</div>
<h3 id="string-interpolation">
    <a href="#string-interpolation" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>String interpolation</h3>
<p>String interpolation allows constructing strings by replacing placeholder
expressions with their string representation.
String interpolation may be used in single- and double-quoted strings, as well
as their multiline equivalent.</p>
<p>A placeholder consists of <code>\(</code> followed by an expression and <code>)</code>.
The expression is evaluated in the scope within which the string is defined.</p>
<p>The result of the expression is substituted as follows:</p>
<ul>
<li>string: as is</li>
<li>bool: the JSON representation of the bool</li>
<li>number: a JSON representation of the number that preserves the
precision of the underlying binary coded decimal</li>
<li>bytes: as if substituted within single quotes or
converted to valid UTF-8 replacing the
maximal subpart of ill-formed subsequences with a single
replacement character (W3C encoding standard) otherwise</li>
<li>list: illegal</li>
<li>struct: illegal</li>
</ul>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogIldvcmxkIgpiOiAiSGVsbG8gXCggYSApISIgLy8gSGVsbG8gV29ybGQh">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: &#34;World&#34;
b: &#34;Hello \( a )!&#34; // Hello World!</code></pre></div>
</div>
<h2 id="builtin-functions">
    <a href="#builtin-functions" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Builtin Functions</h2>
<p>Builtin functions are predeclared. They are called like any other function.</p>
<h3 id="len">
    <a href="#len" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a><code>len</code></h3>
<p>The builtin function <code>len</code> takes arguments of various types and returns
a result of type int.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="QXJndW1lbnQgdHlwZSAgICBSZXN1bHQKCmJ5dGVzICAgICAgICAgICAgbGVuZ3RoIG9mIGJ5dGUgc2VxdWVuY2UKbGlzdCAgICAgICAgICAgICBsaXN0IGxlbmd0aCwgc21hbGxlc3QgbGVuZ3RoIGZvciBhbiBvcGVuIGxpc3QKc3RydWN0ICAgICAgICAgICBudW1iZXIgb2YgZGlzdGluY3QgZGF0YSBmaWVsZHMsIGV4Y2x1ZGluZyBmaWVsZCBjb25zdHJhaW50cw==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Argument type    Result

bytes            length of byte sequence
list             list length, smallest length for an open list
struct           number of distinct data fields, excluding field constraints</code></pre></div>
</div>
<!-- TODO: consider not supporting len, but instead rely on more
precisely named builtin functions:
  - strings.RuneLen(x)
  - bytes.Len(x)  // x may be a string
  - struct.NumFooFields(x)
  - list.Len(x)
-->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbiAgICAgICAgICAgUmVzdWx0CmxlbigiSGVsbMO4IikgICAgICAgICA2CmxlbihbMSwgMiwgM10pICAgICAgIDMKbGVuKFsxLCAyLCAuLi5dKSAgICAgMg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression           Result
len(&#34;HellÃ¸&#34;)         6
len([1, 2, 3])       3
len([1, 2, ...])     2</code></pre></div>
</div>
<h3 id="close">
    <a href="#close" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a><code>close</code></h3>
<p>The builtin function <code>close</code> converts a partially defined, or open, struct
to a fully defined, or closed, struct.</p>
<h3 id="and">
    <a href="#and" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a><code>and</code></h3>
<p>The builtin function <code>and</code> takes a list and returns the result of applying
the <code>&amp;</code> operator to all elements in the list.
It returns top for the empty list.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbjogICAgICAgICAgUmVzdWx0CmFuZChbYSwgYl0pICAgICAgICAgIGEgJiBiCmFuZChbYV0pICAgICAgICAgICAgIGEKYW5kKFtdKSAgICAgICAgICAgICAgXw==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression:          Result
and([a, b])          a &amp; b
and([a])             a
and([])              _</code></pre></div>
</div>
<h3 id="or">
    <a href="#or" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a><code>or</code></h3>
<p>The builtin function <code>or</code> takes a list and returns the result of applying
the <code>|</code> operator to all elements in the list.
It returns bottom for the empty list.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="RXhwcmVzc2lvbjogICAgICAgICAgUmVzdWx0Cm9yKFthLCBiXSkgICAgICAgICAgIGEgfCBiCm9yKFthXSkgICAgICAgICAgICAgIGEKb3IoW10pICAgICAgICAgICAgICAgX3xf">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Expression:          Result
or([a, b])           a | b
or([a])              a
or([])               _|_</code></pre></div>
</div>
<h3 id="div-mod-quo-and-rem">
    <a href="#div-mod-quo-and-rem" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a><code>div</code>, <code>mod</code>, <code>quo</code> and <code>rem</code></h3>
<p>For two integer values <code>x</code> and <code>y</code>,
the integer quotient <code>q = div(x, y)</code> and remainder <code>r = mod(x, y)</code>
implement Euclidean division and
satisfy the following relationship:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="ciA9IHggLSB5KnEgIHdpdGggMCA8PSByIDwgfHl8">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>r = x - y*q  with 0 &lt;= r &lt; |y|</code></pre></div>
</div>
<p>where <code>|y|</code> denotes the absolute value of <code>y</code>.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="IHggICAgIHkgICBkaXYoeCwgeSkgIG1vZCh4LCB5KQogNSAgICAgMyAgICAgICAgMSAgICAgICAgICAyCi01ICAgICAzICAgICAgIC0yICAgICAgICAgIDEKIDUgICAgLTMgICAgICAgLTEgICAgICAgICAgMgotNSAgICAtMyAgICAgICAgMiAgICAgICAgICAx">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code> x     y   div(x, y)  mod(x, y)
 5     3        1          2
-5     3       -2          1
 5    -3       -1          2
-5    -3        2          1</code></pre></div>
</div>
<p>For two integer values <code>x</code> and <code>y</code>,
the integer quotient <code>q = quo(x, y)</code> and remainder <code>r = rem(x, y)</code>
implement truncated division and
satisfy the following relationship:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="eCA9IHEqeSArIHIgIGFuZCAgfHJ8IDwgfHl8">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>x = q*y + r  and  |r| &lt; |y|</code></pre></div>
</div>
<p>with <code>quo(x, y)</code> truncated towards zero.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="IHggICAgIHkgICBxdW8oeCwgeSkgIHJlbSh4LCB5KQogNSAgICAgMyAgICAgICAgMSAgICAgICAgICAyCi01ICAgICAzICAgICAgIC0xICAgICAgICAgLTIKIDUgICAgLTMgICAgICAgLTEgICAgICAgICAgMgotNSAgICAtMyAgICAgICAgMSAgICAgICAgIC0y">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code> x     y   quo(x, y)  rem(x, y)
 5     3        1          2
-5     3       -1         -2
 5    -3       -1          2
-5    -3        1         -2</code></pre></div>
</div>
<p>A zero divisor in either case results in bottom (an error).</p>
<h2 id="cycles">
    <a href="#cycles" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Cycles</h2>
<p>Implementations are required to interpret or reject cycles encountered
during evaluation according to the rules in this section.</p>
<h3 id="reference-cycles">
    <a href="#reference-cycles" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Reference cycles</h3>
<p>A <em>reference cycle</em> occurs if a field references itself, either directly or
indirectly.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8geCByZWZlcmVuY2VzIGl0c2VsZgp4OiB4CgovLyBpbmRpcmVjdCBjeWNsZXMKYjogYwpjOiBkCmQ6IGI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// x references itself
x: x

// indirect cycles
b: c
c: d
d: b</code></pre></div>
</div>
<p>Implementations should treat these as <code>_</code>.
Two particular cases are discussed below.</p>
<h4 id="expressions-that-unify-an-atom-with-an-expression">
    <a href="#expressions-that-unify-an-atom-with-an-expression" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Expressions that unify an atom with an expression</h4>
<p>An expression of the form <code>a &amp; e</code>, where <code>a</code> is an atom
and <code>e</code> is an expression, always evaluates to <code>a</code> or bottom.
As it does not matter how we fail, we can assume the result to be <code>a</code>
and postpone validating <code>a == e</code> until after all references
in <code>e</code> have been resolved.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gQ29uZmlnICAgICAgICAgICAgRXZhbHVhdGVzIHRvIChyZXF1aXJpbmcgY29uY3JldGUgdmFsdWVzKQp4OiB7ICAgICAgICAgICAgICAgICAgeDogewogICAgYTogYiArIDEwMCAgICAgICAgICAgIGE6IF98XyAvLyBjeWNsZSBkZXRlY3RlZAogICAgYjogYSAtIDEwMCAgICAgICAgICAgIGI6IF98XyAvLyBjeWNsZSBkZXRlY3RlZAp9ICAgICAgICAgICAgICAgICAgICAgfQoKeTogeCAmIHsgICAgICAgICAgICAgIHk6IHsKICAgIGE6IDIwMCAgICAgICAgICAgICAgICBhOiAyMDAgLy8gYXNzZXJ0ZWQgdGhhdCAyMDAgPT0gYiArIDEwMAogICAgICAgICAgICAgICAgICAgICAgICAgIGI6IDEwMAp9ICAgICAgICAgICAgICAgICAgICAgfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// Config            Evaluates to (requiring concrete values)
x: {                  x: {
    a: b + 100            a: _|_ // cycle detected
    b: a - 100            b: _|_ // cycle detected
}                     }

y: x &amp; {              y: {
    a: 200                a: 200 // asserted that 200 == b + 100
                          b: 100
}                     }</code></pre></div>
</div>
<h4 id="field-values">
    <a href="#field-values" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Field values</h4>
<p>A field value of the form <code>r &amp; v</code>,
where <code>r</code> evaluates to a reference cycle and <code>v</code> is a concrete value,
evaluates to <code>v</code>.
Unification is idempotent and unifying a value with itself ad infinitum,
which is what the cycle represents, results in this value.
Implementations should detect cycles of this kind, ignore <code>r</code>,
and take <code>v</code> as the result of unification.</p>
<!-- Tomabechi's graph unification algorithm
can detect such cycles at near-zero cost. -->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Q29uZmlndXJhdGlvbiAgICBFdmFsdWF0ZWQKLy8gICAgYyAgICAgICAgICAgQ3ljbGVzIGluIG5vZGVzIG9mIHR5cGUgc3RydWN0IGV2YWx1YXRlCi8vICDihpnvuI4gICDihpYgICAgICAgICB0byB0aGUgZml4ZWQgcG9pbnQgb2YgdW5pZnlpbmcgdGhlaXIKLy8gYSAg4oaSICBiICAgICAgICB2YWx1ZXMgYWQgaW5maW5pdHVtLgoKYTogYiAmIHsgeDogMSB9ICAgLy8gYTogeyB4OiAxLCB5OiAyLCB6OiAzIH0KYjogYyAmIHsgeTogMiB9ICAgLy8gYjogeyB4OiAxLCB5OiAyLCB6OiAzIH0KYzogYSAmIHsgejogMyB9ICAgLy8gYzogeyB4OiAxLCB5OiAyLCB6OiAzIH0KCi8vIHJlc29sdmUgYSAgICAgICAgICAgICBiICYge3g6MX0KLy8gc3Vic3RpdHV0ZSBiICAgICAgICAgIGMgJiB7eToyfSAmIHt4OjF9Ci8vIHN1YnN0aXR1dGUgYyAgICAgICAgICBhICYge3o6M30gJiB7eToyfSAmIHt4OjF9Ci8vIGVsaW1pbmF0ZSBhIChjeWNsZSkgICB7ejozfSAmIHt5OjJ9ICYge3g6MX0KLy8gc2ltcGxpZnkgICAgICAgICAgICAgIHt4OjEseToyLHo6M30=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Configuration    Evaluated
//    c           Cycles in nodes of type struct evaluate
//  â†™ï¸Ž   â†–         to the fixed point of unifying their
// a  â†’  b        values ad infinitum.

a: b &amp; { x: 1 }   // a: { x: 1, y: 2, z: 3 }
b: c &amp; { y: 2 }   // b: { x: 1, y: 2, z: 3 }
c: a &amp; { z: 3 }   // c: { x: 1, y: 2, z: 3 }

// resolve a             b &amp; {x:1}
// substitute b          c &amp; {y:2} &amp; {x:1}
// substitute c          a &amp; {z:3} &amp; {y:2} &amp; {x:1}
// eliminate a (cycle)   {z:3} &amp; {y:2} &amp; {x:1}
// simplify              {x:1,y:2,z:3}</code></pre></div>
</div>
<p>This rule also applies to field values that are disjunctions of unification
operations of the above form.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="YTogYiZ7eDoxfSB8IHt5OjF9ICAvLyB7eDoxLHk6Myx6OjJ9IHwge3k6MX0KYjoge3g6Mn0gfCBjJnt6OjJ9ICAvLyB7eDoyfSB8IHt4OjEseTozLHo6Mn0KYzogYSZ7eTozfSB8IHt6OjN9ICAvLyB7eDoxLHk6Myx6OjJ9IHwge3o6M30KCgovLyByZXNvbHZpbmcgYSAgICAgICAgICAgYiZ7eDoxfSB8IHt5OjF9Ci8vIHN1YnN0aXR1dGUgYiAgICAgICAgICAoe3g6Mn0gfCBjJnt6OjJ9KSZ7eDoxfSB8IHt5OjF9Ci8vIHNpbXBsaWZ5ICAgICAgICAgICAgICBjJnt6OjJ9Jnt4OjF9IHwge3k6MX0KLy8gc3Vic3RpdHV0ZSBjICAgICAgICAgIChhJnt5OjN9IHwge3o6M30pJnt6OjJ9Jnt4OjF9IHwge3k6MX0KLy8gc2ltcGxpZnkgICAgICAgICAgICAgIGEme3k6M30me3o6Mn0me3g6MX0gfCB7eToxfQovLyBlbGltaW5hdGUgYSAoY3ljbGUpICAge3k6M30me3o6Mn0me3g6MX0gfCB7eToxfQovLyBleHBhbmQgICAgICAgICAgICAgICAge3g6MSx5OjMsejoyfSB8IHt5OjF9">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>a: b&amp;{x:1} | {y:1}  // {x:1,y:3,z:2} | {y:1}
b: {x:2} | c&amp;{z:2}  // {x:2} | {x:1,y:3,z:2}
c: a&amp;{y:3} | {z:3}  // {x:1,y:3,z:2} | {z:3}


// resolving a           b&amp;{x:1} | {y:1}
// substitute b          ({x:2} | c&amp;{z:2})&amp;{x:1} | {y:1}
// simplify              c&amp;{z:2}&amp;{x:1} | {y:1}
// substitute c          (a&amp;{y:3} | {z:3})&amp;{z:2}&amp;{x:1} | {y:1}
// simplify              a&amp;{y:3}&amp;{z:2}&amp;{x:1} | {y:1}
// eliminate a (cycle)   {y:3}&amp;{z:2}&amp;{x:1} | {y:1}
// expand                {x:1,y:3,z:2} | {y:1}</code></pre></div>
</div>
<p>Note that all nodes that form a reference cycle to form a struct will evaluate
to the same value.
If a field value is a disjunction, any element that is part of a cycle will
evaluate to this value.</p>
<h3 id="structural-cycles">
    <a href="#structural-cycles" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Structural cycles</h3>
<p>A structural cycle is when a node references one of its ancestor nodes.
It is possible to construct a structural cycle by unifying two acyclic values:</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gYWN5Y2xpYwp5OiB7CiAgICBmOiBoOiBnCiAgICBnOiBfCn0KLy8gYWN5Y2xpYwp4OiB7CiAgICBmOiBfCiAgICBnOiBmCn0KLy8gaW50cm9kdWNlcyBzdHJ1Y3R1cmFsIGN5Y2xlCno6IHggJiB5">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// acyclic
y: {
    f: h: g
    g: _
}
// acyclic
x: {
    f: _
    g: f
}
// introduces structural cycle
z: x &amp; y</code></pre></div>
</div>
<p>Implementations should be able to detect such structural cycles dynamically.</p>
<p>A structural cycle can result in infinite structure or evaluation loops.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gaW5maW5pdGUgc3RydWN0dXJlCmE6IGI6IGEKCi8vIGluZmluaXRlIGV2YWx1YXRpb24KZjogewogICAgbjogICBpbnQKICAgIG91dDogbiArIChmICYge246IDF9KS5vdXQKfQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// infinite structure
a: b: a

// infinite evaluation
f: {
    n:   int
    out: n + (f &amp; {n: 1}).out
}</code></pre></div>
</div>
<p>CUE must allow or disallow structural cycles under certain circumstances.</p>
<p>If a node <code>a</code> references an ancestor node, we call it and any of its
field values <code>a.f</code> <em>cyclic</em>.
So if <code>a</code> is cyclic, all of its descendants are also regarded as cyclic.
A given node <code>x</code>, whose value is composed of the conjuncts <code>c1 &amp; ... &amp; cn</code>,
is valid if any of its conjuncts is not cyclic.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="Ly8gRGlzYWxsb3dlZDogYSBsaXN0IG9mIGluZmluaXRlIGxlbmd0aCB3aXRoIGFsbCBlbGVtZW50cyBiZWluZyAxLgojTGlzdDogewogICAgaGVhZDogMQogICAgdGFpbDogI0xpc3QKfQoKLy8gRGlzYWxsb3dlZDogYW5vdGhlciBpbmZpbml0ZSBzdHJ1Y3R1cmUgKGE6e2I6e2Q6e2I6e2Q6ey4uLn19fX19LCAuLi4pLgphOiB7CiAgICBiOiBjCn0KYzogewogICAgZDogYQp9CgovLyAjTGlzdCBkZWZpbmVzIGEgbGlzdCBvZiBhcmJpdHJhcnkgbGVuZ3RoLiBCZWNhdXNlIHRoZSByZWN1cnNpdmUgcmVmZXJlbmNlCi8vIGlzIHBhcnQgb2YgYSBkaXNqdW5jdGlvbiwgdGhpcyBkb2VzIG5vdCByZXN1bHQgaW4gYSBzdHJ1Y3R1cmFsIGN5Y2xlLgojTGlzdDogewogICAgaGVhZDogXwogICAgdGFpbDogbnVsbCB8ICNMaXN0Cn0KCi8vIFVzYWdlIG9mICNMaXN0LiBUaGUgdmFsdWUgb2YgdGFpbCBpbiB0aGUgbW9zdCBkZWVwbHkgbmVzdGVkIGVsZW1lbnQgd2lsbAovLyBiZSBgbnVsbGA6IGFzIHRoZSB2YWx1ZSBvZiB0aGUgZGlzanVuY3QgcmVmZXJyaW5nIHRvIGxpc3QgaXMgdGhlIG9ubHkKLy8gY29uanVuY3QsIGFsbCBjb25qdW5jdHMgYXJlIGN5Y2xpYyBhbmQgdGhlIHZhbHVlIGlzIGludmFsaWQgYW5kIHNvCi8vIGVsaW1pbmF0ZWQgZnJvbSB0aGUgZGlzanVuY3Rpb24uCk15TGlzdDogI0xpc3QgJiB7IGhlYWQ6IDEsIHRhaWw6IHsgaGVhZDogMiB9fQ==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>// Disallowed: a list of infinite length with all elements being 1.
#List: {
    head: 1
    tail: #List
}

// Disallowed: another infinite structure (a:{b:{d:{b:{d:{...}}}}}, ...).
a: {
    b: c
}
c: {
    d: a
}

// #List defines a list of arbitrary length. Because the recursive reference
// is part of a disjunction, this does not result in a structural cycle.
#List: {
    head: _
    tail: null | #List
}

// Usage of #List. The value of tail in the most deeply nested element will
// be `null`: as the value of the disjunct referring to list is the only
// conjunct, all conjuncts are cyclic and the value is invalid and so
// eliminated from the disjunction.
MyList: #List &amp; { head: 1, tail: { head: 2 }}</code></pre></div>
</div>
<!--
### Unused fields

TODO: rules for detection of unused fields

1. Any alias value must be used
-->
<h2 id="modules-instances-and-packages">
    <a href="#modules-instances-and-packages" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Modules, instances, and packages</h2>
<p>CUE configurations are constructed combining <em>instances</em>.
An instance, in turn, is constructed from one or more source files belonging
to the same <em>package</em> that together declare the data representation.
Elements of this data representation may be exported and used
in other instances.</p>
<h3 id="source-file-organization">
    <a href="#source-file-organization" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Source file organization</h3>
<p>Each source file consists of an optional package clause defining collection
of files to which it belongs,
followed by a possibly empty set of import declarations that declare
packages whose contents it wishes to use, followed by a possibly empty set of
declarations.</p>
<p>Like with a struct, a source file may contain embeddings.
Unlike with a struct, the embedded expressions may be any value.
If the result of the unification of all embedded values is not a struct,
it will be output instead of its enclosing file when exporting CUE
to a data format</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="U291cmNlRmlsZSA9IHsgYXR0cmlidXRlICIsIiB9IFsgUGFja2FnZUNsYXVzZSAiLCIgXSB7IEltcG9ydERlY2wgIiwiIH0geyBEZWNsYXJhdGlvbiAiLCIgfSAu">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>SourceFile = { attribute &#34;,&#34; } [ PackageClause &#34;,&#34; ] { ImportDecl &#34;,&#34; } { Declaration &#34;,&#34; } .</code></pre></div>
</div>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="IkhlbGxvIFwoI3BsYWNlKSEiCgojcGxhY2U6ICJ3b3JsZCIKCi8vIE91dHB1dHMgIkhlbGxvIHdvcmxkISI=">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>&#34;Hello \(#place)!&#34;

#place: &#34;world&#34;

// Outputs &#34;Hello world!&#34;</code></pre></div>
</div>
<h3 id="package-clause">
    <a href="#package-clause" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Package clause</h3>
<p>A package clause is an optional clause that defines the package to which
a source file the file belongs.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="UGFja2FnZUNsYXVzZSAgPSAicGFja2FnZSIgUGFja2FnZU5hbWUgLgpQYWNrYWdlTmFtZSAgICA9IGlkZW50aWZpZXIgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>PackageClause  = &#34;package&#34; PackageName .
PackageName    = identifier .</code></pre></div>
</div>
<p>The PackageName must not be a definition identifier.</p>
<p>If the PackageName is the blank identifier (<code>_</code>), it is treated the same
as if there were no package clause. This can be useful to allow adding
package level attributes or doc comments to a CUE file without a package
name.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="cGFja2FnZSBtYXRo">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>package math</code></pre></div>
</div>
<h3 id="modules-and-instances">
    <a href="#modules-and-instances" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Modules and instances</h3>
<p>A <em>module</em> defines a tree of directories, rooted at the <em>module root</em>.</p>
<p>All source files within a module with the same package name belong to the same
package.</p>
<!-- jba: I can't make sense of the above sentence. -->
<p>A module may define multiple packages.</p>
<p>An <em>instance</em> of a package is any subset of files belonging
to the same package.</p>
<!-- jba: Are you saying that -->
<!-- if I have a package with files a, b and c, then there are 8 instances of -->
<!-- that package, some of which are {a, b}, {c}, {b, c}, and so on? What's the -->
<!-- purpose of that definition? -->
<p>It is interpreted as the concatenation of these files.</p>
<p>An implementation may impose conventions on the layout of package files
to determine which files of a package belongs to an instance.
For example, an instance may be defined as the subset of package files
belonging to a directory and all its ancestors.</p>
<!-- jba: OK, that helps a little, but I still don't see what the purpose is. -->
<h3 id="import-declarations">
    <a href="#import-declarations" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>Import declarations</h3>
<p>An import declaration states that the source file containing the declaration
depends on definitions of the <em>imported</em> package
and enables access to exported identifiers of that package.
The import names an identifier (PackageName) to be used for access and an
ImportPath that specifies the package to be imported.</p>
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="SW1wb3J0RGVjbCAgICAgICA9ICJpbXBvcnQiICggSW1wb3J0U3BlYyB8ICIoIiB7IEltcG9ydFNwZWMgIiwiIH0gIikiICkgLgpJbXBvcnRTcGVjICAgICAgID0gWyBQYWNrYWdlTmFtZSBdIEltcG9ydFBhdGggLgpJbXBvcnRMb2NhdGlvbiAgID0geyB1bmljb2RlX3ZhbHVlIH0gLgpJbXBvcnRQYXRoICAgICAgID0gYCJgIEltcG9ydExvY2F0aW9uIFsgIjoiIGlkZW50aWZpZXIgXSBgImAgLg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>ImportDecl       = &#34;import&#34; ( ImportSpec | &#34;(&#34; { ImportSpec &#34;,&#34; } &#34;)&#34; ) .
ImportSpec       = [ PackageName ] ImportPath .
ImportLocation   = { unicode_value } .
ImportPath       = `&#34;` ImportLocation [ &#34;:&#34; identifier ] `&#34;` .</code></pre></div>
</div>
<p>The PackageName is used in qualified identifiers to access
exported identifiers of the package within the importing source file.
It is declared in the file block.
It defaults to the identifier specified in the package clause of the imported
package, which must match either the last path component of ImportLocation
or the identifier following it.</p>
<!--
Note: this deviates from the Go spec where there is no such restriction.
This restriction has the benefit of being to determine the identifiers
for packages from within the file itself. But for CUE it is has another benefit:
when using package hierarchies, one is more likely to want to include multiple
packages within the same directory structure. This mechanism allows
disambiguation in these cases.
-->
<p>The interpretation of the ImportPath is implementation-dependent but it is
typically either the path of a builtin package or a fully qualifying location
of a package within a source code repository.</p>
<p>An ImportLocation must be a non-empty string using only characters belonging to
Unicode&rsquo;s L, M, N, P, and S general categories
(the Graphic characters without spaces)
and may not include the characters <code>!&quot;#$%&amp;'()*,:;&lt;=&gt;?[\\]^`{|}</code>
or the Unicode replacement character U+FFFD.</p>
<p>Assume we have package containing the package clause <code>package math</code>,
which exports function <code>Sin</code> at the path identified by <code>lib/math</code>.
This table illustrates how <code>Sin</code> is accessed in files
that import the package after the various types of import declaration.</p>
<!-- TODO: a better example than lib/math:math, where the suffix is a no-op -->
<div class="code-block"data-copy><div class="code-block__highlight"><button class="code-block__copy" type="button" data-copy-button data-copy-type="code" data-copy-value="SW1wb3J0IGRlY2xhcmF0aW9uICAgICAgICAgIExvY2FsIG5hbWUgb2YgU2luCgppbXBvcnQgICAibGliL21hdGgiICAgICAgICAgbWF0aC5TaW4KaW1wb3J0ICAgImxpYi9tYXRoOm1hdGgiICAgIG1hdGguU2luCmltcG9ydCBtICJsaWIvbWF0aCIgICAgICAgICBtLlNpbg==">
                <span>Copy code</span>
                <span class="code-block__message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button><pre tabindex="0"><code>Import declaration          Local name of Sin

import   &#34;lib/math&#34;         math.Sin
import   &#34;lib/math:math&#34;    math.Sin
import m &#34;lib/math&#34;         m.Sin</code></pre></div>
</div>
<p>An import declaration declares a dependency relation between the importing and
imported package. It is illegal for a package to import itself, directly or
indirectly, or to directly import a package without referring to any of its
exported identifiers.</p>
<h3 id="an-example-package">
    <a href="#an-example-package" class="anchor" aria-label="Anchor">



<svg class="icon anchor__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>
</a>An example package</h3>
<p>TODO</p>

                        
                    </div><footer class="article__footer">
    <div class="article__lastmod">
        <p class="lastmod">
         <a class="lastmod__link" href="https://github.com/cue-lang/cuelang.org/commit/517f0213e8685a81c6436cf0e6226f98facb066b">
                Last modified April 16, 2025</a>
    </p>

    </div>

    <div class="article__footer-meta"><div class="article__share"><details class="share" data-dropdown>
    <summary class="button button--icon button--light-blue share__button">
        



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--share"></use>
</svg>

        <span>Open share options</span>
    </summary>

    <ul class="share__list">
        <li class="share__item" data-copy>
            <button class="share__copy" data-copy-button data-copy-type="url" data-copy-value="//localhost:1313/docs/reference/spec/">
                



<svg class="icon share__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--link"></use>
</svg>

                <span class="share__link-text">Copy link</span>
                <span class="share__copy-message is-hidden" data-copy-message aria-hidden="true">
                    Copied!
                </span>
            </button>
        </li>

        <li class="share__item">
            <a class="share__link" target="_blank" href="https://twitter.com/intent/tweet?url=//localhost:1313/docs/reference/spec/&text=%20Note%20to%20implementors%20Notes%20on%20the%20formalism%20underlying%20this%20specification%20can%20be%20found%20here.%0aIntroduction%20This%20is%20a%20reference%20manual%20for%20the%20CUE%20data%20constraint%20language.%20CUE,%20pronounced%20cue%20or%20Q,%20is%20a%20general-purpose%20and%20strongly%20typed%20constraint-based%20language.%20It%20can%20be%20used%20for%20data%20templating,%20data%20validation,%20code%20generation,%20scripting,%20and%20many%20other%20applications%20involving%20structured%20data.%20The%20CUE%20tooling,%20layered%20on%20top%20of%20CUE,%20provides%20a%20general%20purpose%20scripting%20language%20for%20creating%20scripts%20as%20well%20as%20simple%20servers,%20also%20expressed%20in%20CUE.%0a">
                



<svg class="icon share__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-x"></use>
</svg>

                <p><span class="share__link-text">Share on X (Twitter)</span></p>
            </a>
        </li>

        <li class="share__item">
            <a class="share__link" target="_blank"
            href="https://www.linkedin.com/shareArticle?mini=true&url=//localhost:1313/docs/reference/spec/&summary=%20Note%20to%20implementors%20Notes%20on%20the%20formalism%20underlying%20this%20specification%20can%20be%20found%20here.%0aIntroduction%20This%20is%20a%20reference%20manual%20for%20the%20CUE%20data%20constraint%20language.%20CUE,%20pronounced%20cue%20or%20Q,%20is%20a%20general-purpose%20and%20strongly%20typed%20constraint-based%20language.%20It%20can%20be%20used%20for%20data%20templating,%20data%20validation,%20code%20generation,%20scripting,%20and%20many%20other%20applications%20involving%20structured%20data.%20The%20CUE%20tooling,%20layered%20on%20top%20of%20CUE,%20provides%20a%20general%20purpose%20scripting%20language%20for%20creating%20scripts%20as%20well%20as%20simple%20servers,%20also%20expressed%20in%20CUE.%0a">
                



<svg class="icon share__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-linkedin"></use>
</svg>

                <p><span class="share__link-text">Share on Linkedin</span></p>
            </a>
        </li>
    </ul>
</details>
</div>
    </div>
</footer>
</div>
            </article>

            



<div class="prevnext">
    <nav class="prevnext__container" aria-label="Previous/Next navigation"><a class="prevnext__prev" href="/docs/reference/contribution-guidelines/" aria-label="Previous - Contribution Guide">
                



<svg class="icon prevnext__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--circle-arrow-left"></use>
</svg>

                <span class="prevnext__text">Contribution Guide</span>
            </a><a class="prevnext__next" href="/docs/reference/glossary/" aria-label="Next - Glossary of terms">
                <span class="prevnext__text">Glossary of terms</span>
                



<svg class="icon prevnext__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--circle-arrow-right"></use>
</svg>

            </a></nav>
</div>

        </div>
        <div id="docs-menu" class="docs__aside">
            <div class="docs__backdrop" data-docs-close="docs"></div>
            <div class="docs__nav">
                <nav class="tree">
    <ul class="tree__list is-book">
        
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/introduction/" title="Introduction">
            <span class="tree__text">Introduction</span>
        </a>
    </li>
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/tour/" title="Tour">
            <span class="tree__text">Tour</span>
        </a>
    </li>
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/integration/" title="Integrations">
            <span class="tree__text">Integrations</span>
        </a>
    </li>
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/tutorial/" title="Tutorials">
            <span class="tree__text">Tutorials</span>
        </a>
    </li>
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/howto/" title="How-to Guides">
            <span class="tree__text">How-to Guides</span>
        </a>
    </li>
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/concept/" title="Concept Guides">
            <span class="tree__text">Concept Guides</span>
        </a>
    </li>
    
    
    

    <li class="tree__item has-children is-active-path">
        <a class="tree__link" href="/docs/reference/" title="References">
            <span class="tree__text">References</span>
        </a>
            <ul class="tree__list is-chapter">
                
                    
    
    
    

    <li class="tree__item is-active">
        <a class="tree__link" href="/docs/reference/spec/" title="The CUE Language Specification">
            <span class="tree__text">The CUE Language Specification</span>
        </a>
            

<nav id="TableOfContents" class="toc">
  <ol class="toc__list">
    <li class="toc__item"><a href="#introduction" class="toc__link"><span class="toc__text">Introduction</span></a></li>
    <li class="toc__item"><a href="#notation" class="toc__link"><span class="toc__text">Notation</span></a></li>
    <li class="toc__item"><a href="#source-code-representation" class="toc__link"><span class="toc__text">Source code representation</span></a></li>
    <li class="toc__item"><a href="#lexical-elements" class="toc__link"><span class="toc__text">Lexical elements</span></a></li>
    <li class="toc__item"><a href="#values-1" class="toc__link"><span class="toc__text">Values</span></a></li>
    <li class="toc__item"><a href="#declarations-and-scopes" class="toc__link"><span class="toc__text">Declarations and Scopes</span></a></li>
    <li class="toc__item"><a href="#expressions" class="toc__link"><span class="toc__text">Expressions</span></a></li>
    <li class="toc__item"><a href="#builtin-functions" class="toc__link"><span class="toc__text">Builtin Functions</span></a></li>
    <li class="toc__item"><a href="#cycles" class="toc__link"><span class="toc__text">Cycles</span></a></li>
    <li class="toc__item"><a href="#modules-instances-and-packages" class="toc__link"><span class="toc__text">Modules, instances, and packages</span></a></li>
  </ol>
</nav>

    </li>
                    
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/reference/glossary/" title="Glossary of terms">
            <span class="tree__text">Glossary of terms</span>
        </a>
    </li>
                    
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/reference/command/" title="The cue command">
            <span class="tree__text">The cue command</span>
        </a>
    </li>
                    
    
    
    

    <li class="tree__item">
        <a class="tree__link" href="/docs/reference/code-of-conduct/" title="Code of Conduct">
            <span class="tree__text">Code of Conduct</span>
        </a>
    </li>
            </ul>
    </li>
    </ul>
</nav>



                <button type="button" class="docs__hide button button--icon button--raised button--light-blue"
                        aria-haspopup="menu" aria-expanded="false" aria-controls="docs-menu" data-docs-toggle>



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--chevron-left"></use>
</svg>
<span>Hide side navigation</span>
                </button>
            </div>
        </div>

        <button type="button" class="docs__show button button--icon button--raised button--light-blue"
                aria-haspopup="menu" aria-expanded="false" aria-controls="docs-menu" data-docs-toggle>



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--chevron-right"></use>
</svg>
<span>Show side navigation</span>
        </button>
    </div>

            </main>

            <footer id="site-footer" class="site__footer">
                




<div class="footer">
    <div class="footer__sitemap">
        <nav class="footer__container" aria-label="Footer menu">
            
                
                <div class="nav nav--footer">
                    <p class="nav__title">Get Started</p>

                    <ul class="nav__list">
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/docs/">
                                    <span class="nav__text">Documentation</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/docs/tour/">
                                    <span class="nav__text">Language Tour</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/play/">
                                    <span class="nav__text">Playground</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/docs/introduction/installation/">
                                    <span class="nav__text">Install CUE</span>
                                </a>
                            </li>
                        
                    </ul>
                </div>
            
                
                <div class="nav nav--footer">
                    <p class="nav__title">Community</p>

                    <ul class="nav__list">
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/community">
                                    <span class="nav__text">The CUE Community</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="https://github.com/cue-lang/cue/blob/master/CONTRIBUTING.md#contribution-guide" target="_blank">
                                    <span class="nav__text">Contributing</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/docs/reference/code-of-conduct/">
                                    <span class="nav__text">Code of Conduct</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/s/slack">
                                    <span class="nav__text">Slack Workspace</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="/s/discord">
                                    <span class="nav__text">Discord Server</span>
                                </a>
                            </li>
                        
                    </ul>
                </div>
            
                
                <div class="nav nav--footer">
                    <p class="nav__title">Connect</p>

                    <ul class="nav__list">
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="https://github.com/cue-lang/cue" target="_blank">
                                    <span class="nav__text">GitHub</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="https://twitter.com/cue_lang" target="_blank">
                                    <span class="nav__text">X (Twitter)</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="https://bsky.app/profile/cuelang.org" target="_blank">
                                    <span class="nav__text">Bluesky</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav__item">
                                <a class="nav__link"
                                   href="https://www.youtube.com/@cuelang/videos" target="_blank">
                                    <span class="nav__text">YouTube</span>
                                </a>
                            </li>
                        
                    </ul>
                </div>
            
        </nav>
    </div>

    <div class="footer__legal">
        <nav class="footer__container" aria-label="Legal">
            <div class="nav nav--legal">
                <ul class="nav__list">
                    <li class="nav__item">
                        <span class="nav__text">&copy; 2025 CUE</span>
                    </li>

                    
                        <li class="nav__item"><a class="nav__link"
                               href="/privacy-policy/">
                                <span class="nav__text">Privacy policy</span>
                            </a>
                        </li>
                    

                    <li class="nav__item">
                        <a class="nav__link" href="https://github.com/cue-lang/cue/issues/new?labels=Triage,NeedsInvestigation,cuelang.org&amp;title=cuelang.org:%20&amp;template=bug_report.md&amp;body=%23%23%23&#43;What&#43;page&#43;were&#43;you&#43;looking&#43;at%3F%0A%0A%2F%2Flocalhost%3A1313%2Fdocs%2Freference%2Fspec%2F%0A%0A%23%23%23&#43;What&#43;version&#43;of&#43;the&#43;site&#43;were&#43;you&#43;looking&#43;at%3F%0A%0Ahttps%3A%2F%2Fgithub.com%2Fcue-lang%2Fcuelang.org%2Fcommit%2F51c481fbb8a5ad6f6c4ad3acc209db0d591988c7%0A%0A%23%23%23&#43;What&#43;did&#43;you&#43;do%3F%0A%0A%0A%0A%23%23%23&#43;What&#43;did&#43;you&#43;expect%3F%0A%0A%0A%0A%23%23%23&#43;What&#43;did&#43;you&#43;see&#43;instead%3F%0A%0A" target="_blank">
                            <span class="nav__text">Report an Issue</span>
                        </a>
                    </li>
                </ul>
            </div>

            <a href="/" class="footer__branding" rel="home">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><path class="logo__letters" d="M39.555 50.355c-6.853.0-11.907 5.133-11.907 13.602s5.027 13.602 11.907 13.602c5.818.0 10.073-3.648 10.94-8.883l-4.034-.012c-.686 3.389-3.532 5.252-6.88 5.252-4.541.0-7.968-3.533-7.968-9.957s3.414-9.955 7.979-9.955c3.373.0 6.207 1.902 6.865 5.328l.004-.002h4.033c-.906-5.664-5.34-8.975-10.94-8.975zm38.748.362-.002.004h.002zm0 .004v26.478H96.07v-3.44H82.297v-8.105h12.752V62.23H82.297V54.16h13.617v-3.44zm-24.823.0v17.521c0 5.974 4.651 9.4 10.51 9.4 5.86.0 10.528-3.426 10.528-9.4V50.721h-3.995v17.457c0 3.711-2.985 5.793-6.529 5.793s-6.517-2.082-6.517-5.793V50.72z"/><path class="logo__inner" d="M64 9.586C33.947 9.586 9.586 33.947 9.586 64S33.947 118.414 64 118.414 118.414 94.053 118.414 64 94.05 9.586 64 9.586zm0 105.973c-28.476.0-51.562-23.086-51.562-51.562S35.524 12.438 64 12.438 115.562 35.524 115.562 64 92.476 115.562 64 115.562z"/><path class="logo__outer" d="M64 0C28.653.0.0 28.653.0 64s28.653 64 64 64 64-28.653 64-64S99.347.0 64 0zm0 121.843C32.054 121.843 6.157 95.946 6.157 64S32.054 6.157 64 6.157 121.843 32.054 121.843 64 95.946 121.843 64 121.843z"/></svg>
                <span>Homepage of CUE</span>
            </a>
        </nav>
    </div>
</div>

            </footer>
        </div>

        
                <div class="notification-bar is-hidden" data-notification-bar="cue-minor-release-v0.13">
        <div class="notification-bar__container">
            <div class="notification-bar__content">
                <strong>CUE v0.13 is now available</strong> &ndash; learn more about its <a href="https://github.com/cue-lang/cue/releases/tag/v0.13.0">new features and improvements</a>
            </div>
            <a class="button button--outline notification-bar__cta" href="/docs/introduction/installation/">
                    <span class="button__text">Install CUE</span>
                    



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--download"></use>
</svg>

                </a>
            <button type="button" class="button button--icon button--small notification-bar__close">
                



<svg class="icon button__icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--close"></use>
</svg>

                <span class="button__text">Close</span>
            </button>
        </div>
    </div>

        
        

<div id="mobile-menu" class="drawer drawer--mobile" data-drawer="menu">
    <div class="drawer__backdrop" data-drawer-close="menu"></div>
    <div class="drawer__container" tabindex="0">
        <div class="drawer__header">
            <a href="/" class="drawer__branding" rel="home">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><path class="logo__letters" d="M39.555 50.355c-6.853.0-11.907 5.133-11.907 13.602s5.027 13.602 11.907 13.602c5.818.0 10.073-3.648 10.94-8.883l-4.034-.012c-.686 3.389-3.532 5.252-6.88 5.252-4.541.0-7.968-3.533-7.968-9.957s3.414-9.955 7.979-9.955c3.373.0 6.207 1.902 6.865 5.328l.004-.002h4.033c-.906-5.664-5.34-8.975-10.94-8.975zm38.748.362-.002.004h.002zm0 .004v26.478H96.07v-3.44H82.297v-8.105h12.752V62.23H82.297V54.16h13.617v-3.44zm-24.823.0v17.521c0 5.974 4.651 9.4 10.51 9.4 5.86.0 10.528-3.426 10.528-9.4V50.721h-3.995v17.457c0 3.711-2.985 5.793-6.529 5.793s-6.517-2.082-6.517-5.793V50.72z"/><path class="logo__inner" d="M64 9.586C33.947 9.586 9.586 33.947 9.586 64S33.947 118.414 64 118.414 118.414 94.053 118.414 64 94.05 9.586 64 9.586zm0 105.973c-28.476.0-51.562-23.086-51.562-51.562S35.524 12.438 64 12.438 115.562 35.524 115.562 64 92.476 115.562 64 115.562z"/><path class="logo__outer" d="M64 0C28.653.0.0 28.653.0 64s28.653 64 64 64 64-28.653 64-64S99.347.0 64 0zm0 121.843C32.054 121.843 6.157 95.946 6.157 64S32.054 6.157 64 6.157 121.843 32.054 121.843 64 95.946 121.843 64 121.843z"/></svg>
                <span>Homepage of CUE</span>
            </a>

            <div class="drawer__close">
                <button type="button" class="button button--white button--icon" data-drawer-close="menu">
                    



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--close"></use>
</svg>

                    <span class="button__text">Hide menu</span>
                </button>
            </div>
        </div>

        <div class="drawer__content">
            <div class="drawer__menu">
                <nav class="nav nav--mobile" aria-label="Mobile menu">
                    <ul class="nav__list">
                        
                            <li class="nav__item">
                                
                                <a class="nav__link"
                                   href="/docs/">
                                    <span class="nav__text">Documentation</span>
                                </a>
                            </li>
                        
                            <li class="nav__item">
                                
                                <a class="nav__link"
                                   href="/play/">
                                    <span class="nav__text">Play</span>
                                </a>
                            </li>
                        
                            <li class="nav__item">
                                
                                <a class="nav__link"
                                   href="/community/">
                                    <span class="nav__text">Community</span>
                                </a>
                            </li>
                        

                        
                            <li class="nav__item">
                                
                                <a class="nav__link"
                                   href="/docs/introduction/installation/">
                                    <span class="nav__text">Install</span>
                                </a>
                            </li>
                        

                        <li class="nav__item nav__item--search">





<div data-search-autocomplete="drawer"
     data-searchbar-size="small"
     data-searchbar-placeholder=""
>
    <div id="autocomplete-drawer"></div>
</div>
</li>
                    </ul>
                </nav>
            </div>
        </div>

        <div class="drawer__footer">
            <nav class="nav nav--social" aria-label="Social">
                <ul class="nav__list">
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="https://github.com/cue-lang/cue"target="_blank" >
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--github"></use>
</svg>

                                <span class="nav__text">GitHub</span>
                            </a>
                        </li>
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="/s/slack">
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--slack"></use>
</svg>

                                <span class="nav__text">Slack</span>
                            </a>
                        </li>
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="/s/discord">
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-discord"></use>
</svg>

                                <span class="nav__text">Discord</span>
                            </a>
                        </li>
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="https://twitter.com/cue_lang"target="_blank" >
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-x"></use>
</svg>

                                <span class="nav__text">X (Twitter)</span>
                            </a>
                        </li>
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="https://bsky.app/profile/cuelang.org"target="_blank" >
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-bluesky"></use>
</svg>

                                <span class="nav__text">Bluesky</span>
                            </a>
                        </li>
                    
                        <li class="nav__item">
                            
                            <a class="nav__link"
                               href="https://www.youtube.com/@cuelang/videos"target="_blank" >
                                



<svg class="icon" aria-hidden="true">
    <use xmlns:xlink="http://www.w3.org/1999/xlink"
         xlink:href="//localhost:1313/img/ui.svg#icon--social-youtube"></use>
</svg>

                                <span class="nav__text">YouTube</span>
                            </a>
                        </li>
                    
                </ul>
            </nav>
        </div>
    </div>
</div>

        

    <script src="/js/main.js" defer></script>






    </body>
</html>
